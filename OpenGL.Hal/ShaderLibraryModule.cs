
// Copyright (C) 2011-2013 Luca Piccioni
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Xml.Serialization;

namespace OpenGL
{
	/// <summary>
	/// A group of shader objects, programs and includes.
	/// </summary>
	[XmlType("ShaderModule")]
	public class ShaderLibraryModule
	{
		/// <summary>
		/// Path of the generated C# module (relative to configuration path).
		/// </summary>
		[XmlAttribute("Path")]
		public string Path;

		/// <summary>
		/// CodeNamespace used for declaring classes in this shader library module.
		/// </summary>
		[XmlAttribute("CodeNamespace")]
		public string CodeNamespace;

		/// <summary>
		/// Source licence of this module.
		/// </summary>
		[XmlAttribute("SourceLicence")]
		public string SourceLicence;

		/// <summary>
		/// Shader objects defined by the generated C# module.
		/// </summary>
		[XmlElement("ShaderObject")]
		public ShaderLibraryObject[] ShaderObjects;

		/// <summary>
		/// Shader programs defined by the generated C# module.
		/// </summary>
		[XmlElement("ShaderProgram")]
		public ShaderLibraryProgram[] ShaderPrograms;

		/// <summary>
		/// Shader includes defined by the generated C# module.
		/// </summary>
		[XmlElement("ShaderInclude")]
		public ShaderLibraryInclude[] ShaderIncludes;

		/// <summary>
		/// 
		/// </summary>
		/// <param name="libraryConfiguration"></param>
		/// <param name="libraries"></param>
		/// <param name="overwrite"></param>
		public void Generate(ShaderLibraryConfiguration libraryConfiguration, IEnumerable<ShaderLibraryConfiguration> libraries, bool overwrite)
		{
			if (libraryConfiguration == null)
				throw new ArgumentNullException("libraryConfiguration");
			if (libraries == null)
				throw new ArgumentNullException("libraries");

			// Check whether the module has to be updated
			if (File.Exists(Path) && !overwrite) {
				FileInfo info = new FileInfo(Path);

				if (info.LastWriteTime >= libraryConfiguration.ModificationDate) {
					bool dirty = false;

					// Module was generated after the last modification of the shader configuration, but
					// some shader object source could be modified since last update

					foreach (ShaderLibraryObject objectClass in ShaderObjects) {
						FileInfo objectSourceFileInfo = new FileInfo(objectClass.SourcePath);

						if (objectSourceFileInfo.LastWriteTime >= info.LastWriteTime) {
							dirty = true;
							break;
						}
					}

					// Do not update module (make-like behavior)
					if (dirty == false) {
						sLog.Debug("Module '{0}' not updated because more recent than source.", Path);
						return;
					}
				}
			}

			// Update module
			sLog.Debug("Updating module '{0}':", Path);

			string tempPath = System.IO.Path.GetTempFileName();

			using (FileStream fs = new FileStream(tempPath, FileMode.Create, FileAccess.Write)) {
				using (StreamWriter sw = new StreamWriter(fs)) {
					// First character: line feed
					sw.WriteLine();

					// Source licence
					if (String.IsNullOrEmpty(SourceLicence) == false) {
						string licenceText = libraryConfiguration.GetLicenceText(SourceLicence);

						if (licenceText != null) {
							foreach (string licenceLine in licenceText.Split('\n'))
								sw.WriteLine("// {0}", licenceLine.Trim());
							sw.WriteLine();
						}
					}

					sw.WriteLine("// Automatically generated by Derm");		// Required for compiling
					sw.WriteLine();

					// Namespace
					string moduleNamespace = libraryConfiguration.CodeNamespace;

					if (CodeNamespace != null)
						moduleNamespace = CodeNamespace;

					// Using declarations
					bool usingDeclarations = false;
					
					if (libraryConfiguration.CodeNamespace.StartsWith("OpenGL") == false) {
						sw.WriteLine("using OpenGL;");		// Required for compiling
						usingDeclarations = true;
					}
					if (libraryConfiguration.CodeNamespace.StartsWith("OpenGL") == false) {
						sw.WriteLine("using OpenGL;");		// Required for compiling
						usingDeclarations = true;
					}
					if (usingDeclarations)
						sw.WriteLine();

					// CodeNamespace (open)
					sw.WriteLine("namespace {0} {1}", moduleNamespace, "{");
					sw.WriteLine();

					// Shader programs
					if (ShaderPrograms != null) {
						foreach (ShaderLibraryProgram programClass in ShaderPrograms) {
							sLog.Info("	Defining shader program '{0}'", programClass.ClassName);

							long streamPosition = sw.BaseStream.Position;
							try {
								programClass.Generate(sw, libraries, this);
							} catch (Exception exception) {
								sLog.Warn(String.Format("The shader program {0} cannot be generated.", programClass.ClassName), exception);
								sw.BaseStream.Seek(streamPosition, SeekOrigin.Begin);
							}
						}
					}

					// Shader objects
					if (ShaderObjects != null) {
						foreach (ShaderLibraryObject objectClass in ShaderObjects) {
							sLog.Info("	Defining shader object '{0}'", objectClass.ClassName);

							long streamPosition = sw.BaseStream.Position;
							try {
								objectClass.Generate(sw, CodeNamespace);
							} catch (Exception exception) {
								sLog.Warn(String.Format("The shader object {0} cannot be generated.", objectClass.ClassName), exception);
								sw.BaseStream.Seek(streamPosition, SeekOrigin.Begin);
							}
						}
					}

					// Shader includes
					if (ShaderIncludes != null) {
						foreach (ShaderLibraryInclude includeClass in ShaderIncludes) {
							sLog.Info("	Defining shader include '{0}'", includeClass.ClassName);

							long streamPosition = sw.BaseStream.Position;
							try {
								includeClass.Generate(sw);
							} catch (Exception exception) {
								sLog.Warn(String.Format("The shader include {0} cannot be generated.", includeClass.ClassName), exception);
								sw.BaseStream.Seek(streamPosition, SeekOrigin.Begin);
							}
						}
					}

					// CodeNamespace (close)
					sw.WriteLine("}");
					sw.WriteLine();
				}
			}

			// Module generated successfully: copy to the destination path
			File.Copy(tempPath, Path, true);
		}

		#region Logging

		/// <summary>
		/// Logger of this class.
		/// </summary>
		private static readonly ILogger sLog = Log.GetLogger(MethodBase.GetCurrentMethod().DeclaringType);

		#endregion
	}
}
