
// MIT License
// 
// Copyright (c) 2009-2017 Luca Piccioni
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// 
// This file is automatically generated

#pragma warning disable 649, 1572, 1573

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Security;
using System.Text;

using Khronos;

namespace OpenVX
{
	public partial class VX
	{
		public const uint VENDOR_MASK = 0xFFF00000;

		public const uint TYPE_MASK = 0x000FFF00;

		public const uint LIBRARY_MASK = 0x000FF000;

		public const uint KERNEL_MASK = 0x00000FFF;

		public const uint ATTRIBUTE_ID_MASK = 0x000000FF;

		public const uint ENUM_TYPE_MASK = 0x000FF000;

		public const uint ENUM_MASK = 0x00000FFF;

		public const string FMT_REF = "%I64u";

		public const string FMT_SIZE = "%I64u";

		public const uint SCALE_UNITY = 1024u;

		public const float SCALE_PYRAMID_HALF = 0.5f;

		public const float SCALE_PYRAMID_ORB = 0.8408964f;

		public const int TYPE_INVALID = 0x000;

		public const int TYPE_CHAR = 0x001;

		public const int TYPE_INT8 = 0x002;

		public const int TYPE_UINT8 = 0x003;

		public const int TYPE_INT16 = 0x004;

		public const int TYPE_UINT16 = 0x005;

		public const int TYPE_INT32 = 0x006;

		public const int TYPE_UINT32 = 0x007;

		public const int TYPE_INT64 = 0x008;

		public const int TYPE_UINT64 = 0x009;

		public const int TYPE_FLOAT32 = 0x00A;

		public const int TYPE_FLOAT64 = 0x00B;

		public const int TYPE_ENUM = 0x00C;

		public const int TYPE_SIZE = 0x00D;

		public const int TYPE_DF_IMAGE = 0x00E;

		public const int TYPE_FLOAT16 = 0x00F;

		public const int TYPE_BOOL = 0x010;

		public const int TYPE_RECTANGLE = 0x020;

		public const int TYPE_KEYPOINT = 0x021;

		public const int TYPE_COORDINATES2D = 0x022;

		public const int TYPE_COORDINATES3D = 0x023;

		public const int TYPE_USER_STRUCT_START = 0x100;

		public const int TYPE_VENDOR_STRUCT_START = 0x400;

		public const int TYPE_KHRONOS_OBJECT_START = 0x800;

		public const int TYPE_VENDOR_OBJECT_START = 0xC00;

		public const int TYPE_KHRONOS_STRUCT_MAX = TYPE_USER_STRUCT_START - 1;

		public const int TYPE_USER_STRUCT_END = TYPE_VENDOR_STRUCT_START - 1;

		public const int TYPE_VENDOR_STRUCT_END = TYPE_KHRONOS_OBJECT_START - 1;

		public const int TYPE_KHRONOS_OBJECT_END = TYPE_VENDOR_OBJECT_START - 1;

		public const int TYPE_VENDOR_OBJECT_END = 0xFFF;

		public const int TYPE_REFERENCE = 0x800;

		public const int TYPE_CONTEXT = 0x801;

		public const int TYPE_GRAPH = 0x802;

		public const int TYPE_NODE = 0x803;

		public const int TYPE_KERNEL = 0x804;

		public const int TYPE_PARAMETER = 0x805;

		public const int TYPE_DELAY = 0x806;

		public const int TYPE_LUT = 0x807;

		public const int TYPE_DISTRIBUTION = 0x808;

		public const int TYPE_PYRAMID = 0x809;

		public const int TYPE_THRESHOLD = 0x80A;

		public const int TYPE_MATRIX = 0x80B;

		public const int TYPE_CONVOLUTION = 0x80C;

		public const int TYPE_SCALAR = 0x80D;

		public const int TYPE_ARRAY = 0x80E;

		public const int TYPE_IMAGE = 0x80F;

		public const int TYPE_REMAP = 0x810;

		public const int TYPE_ERROR = 0x811;

		public const int TYPE_META_FORMAT = 0x812;

		public const int TYPE_OBJECT_ARRAY = 0x813;

		public const int STATUS_MIN = -25;

		public const int ERROR_REFERENCE_NONZERO = -24;

		public const int ERROR_MULTIPLE_WRITERS = -23;

		public const int ERROR_GRAPH_ABANDONED = -22;

		public const int ERROR_GRAPH_SCHEDULED = -21;

		public const int ERROR_INVALID_SCOPE = -20;

		public const int ERROR_INVALID_NODE = -19;

		public const int ERROR_INVALID_GRAPH = -18;

		public const int ERROR_INVALID_TYPE = -17;

		public const int ERROR_INVALID_VALUE = -16;

		public const int ERROR_INVALID_DIMENSION = -15;

		public const int ERROR_INVALID_FORMAT = -14;

		public const int ERROR_INVALID_LINK = -13;

		public const int ERROR_INVALID_REFERENCE = -12;

		public const int ERROR_INVALID_MODULE = -11;

		public const int ERROR_INVALID_PARAMETERS = -10;

		public const int ERROR_OPTIMIZED_AWAY = -9;

		public const int ERROR_NO_MEMORY = -8;

		public const int ERROR_NO_RESOURCES = -7;

		public const int ERROR_NOT_COMPATIBLE = -6;

		public const int ERROR_NOT_ALLOCATED = -5;

		public const int ERROR_NOT_SUFFICIENT = -4;

		public const int ERROR_NOT_SUPPORTED = -3;

		public const int ERROR_NOT_IMPLEMENTED = -2;

		public const int FAILURE = -1;

		public const int SUCCESS = 0;

		public const int ENUM_DIRECTION = 0x00;

		public const int ENUM_ACTION = 0x01;

		public const int ENUM_HINT = 0x02;

		public const int ENUM_DIRECTIVE = 0x03;

		public const int ENUM_INTERPOLATION = 0x04;

		public const int ENUM_OVERFLOW = 0x05;

		public const int ENUM_COLOR_SPACE = 0x06;

		public const int ENUM_COLOR_RANGE = 0x07;

		public const int ENUM_PARAMETER_STATE = 0x08;

		public const int ENUM_CHANNEL = 0x09;

		public const int ENUM_CONVERT_POLICY = 0x0A;

		public const int ENUM_THRESHOLD_TYPE = 0x0B;

		public const int ENUM_BORDER = 0x0C;

		public const int ENUM_COMPARISON = 0x0D;

		public const int ENUM_MEMORY_TYPE = 0x0E;

		public const int ENUM_TERM_CRITERIA = 0x0F;

		public const int ENUM_NORM_TYPE = 0x10;

		public const int ENUM_ACCESSOR = 0x11;

		public const int ENUM_ROUND_POLICY = 0x12;

		public const int ENUM_TARGET = 0x13;

		public const int ENUM_BORDER_POLICY = 0x14;

		public const int ENUM_GRAPH_STATE = 0x15;

		public const int ENUM_NONLINEAR = 0x16;

		public const int ENUM_PATTERN = 0x17;

		public const int ACTION_CONTINUE = ((ID_KHRONOS << 20) | ( ENUM_ACTION << 12)) + 0x0;

		public const int ACTION_ABANDON = ((ID_KHRONOS << 20) | ( ENUM_ACTION << 12)) + 0x1;

		public const int INPUT = ((ID_KHRONOS << 20) | ( ENUM_DIRECTION << 12)) + 0x0;

		public const int OUTPUT = ((ID_KHRONOS << 20) | ( ENUM_DIRECTION << 12)) + 0x1;

		public const int BIDIRECTIONAL = ((ID_KHRONOS << 20) | ( ENUM_DIRECTION << 12)) + 0x2;

		public const int HINT_PERFORMANCE_DEFAULT = ((ID_KHRONOS << 20) | ( ENUM_HINT << 12)) + 0x1;

		public const int HINT_PERFORMANCE_LOW_POWER = ((ID_KHRONOS << 20) | ( ENUM_HINT << 12)) + 0x2;

		public const int HINT_PERFORMANCE_HIGH_SPEED = ((ID_KHRONOS << 20) | ( ENUM_HINT << 12)) + 0x3;

		public const int DIRECTIVE_DISABLE_LOGGING = ((ID_KHRONOS << 20) | ( ENUM_DIRECTIVE << 12)) + 0x0;

		public const int DIRECTIVE_ENABLE_LOGGING = ((ID_KHRONOS << 20) | ( ENUM_DIRECTIVE << 12)) + 0x1;

		public const int DIRECTIVE_DISABLE_PERFORMANCE = ((ID_KHRONOS << 20) | ( ENUM_DIRECTIVE << 12)) + 0x2;

		public const int DIRECTIVE_ENABLE_PERFORMANCE = ((ID_KHRONOS << 20) | ( ENUM_DIRECTIVE << 12)) + 0x3;

		public const int GRAPH_STATE_UNVERIFIED = ((ID_KHRONOS << 20) | ( ENUM_GRAPH_STATE << 12)) + 0x0;

		public const int GRAPH_STATE_VERIFIED = ((ID_KHRONOS << 20) | ( ENUM_GRAPH_STATE << 12)) + 0x1;

		public const int GRAPH_STATE_RUNNING = ((ID_KHRONOS << 20) | ( ENUM_GRAPH_STATE << 12)) + 0x2;

		public const int GRAPH_STATE_ABANDONED = ((ID_KHRONOS << 20) | ( ENUM_GRAPH_STATE << 12)) + 0x3;

		public const int GRAPH_STATE_COMPLETED = ((ID_KHRONOS << 20) | ( ENUM_GRAPH_STATE << 12)) + 0x4;

		public const int GRAPH_NUMNODES = (((ID_KHRONOS) << 20) | ( TYPE_GRAPH << 8)) + 0x0;

		public const int GRAPH_PERFORMANCE = (((ID_KHRONOS) << 20) | ( TYPE_GRAPH << 8)) + 0x2;

		public const int GRAPH_NUMPARAMETERS = (((ID_KHRONOS) << 20) | ( TYPE_GRAPH << 8)) + 0x3;

		public const int GRAPH_STATE = (((ID_KHRONOS) << 20) | ( TYPE_GRAPH << 8)) + 0x4;

		public const int CONVERT_POLICY_WRAP = ((ID_KHRONOS << 20) | ( ENUM_CONVERT_POLICY << 12)) + 0x0;

		public const int CONVERT_POLICY_SATURATE = ((ID_KHRONOS << 20) | ( ENUM_CONVERT_POLICY << 12)) + 0x1;

		public const int DF_IMAGE_VIRT = ((byte)'V') | ((byte)'I' << 8) | ((byte)'R' << 16) | ((byte)'T' << 24);

		public const int DF_IMAGE_RGB = ((byte)'R') | ((byte)'G' << 8) | ((byte)'B' << 16) | ((byte)'2' << 24);

		public const int DF_IMAGE_RGBX = ((byte)'R') | ((byte)'G' << 8) | ((byte)'B' << 16) | ((byte)'A' << 24);

		public const int DF_IMAGE_NV12 = ((byte)'N') | ((byte)'V' << 8) | ((byte)'1' << 16) | ((byte)'2' << 24);

		public const int DF_IMAGE_NV21 = ((byte)'N') | ((byte)'V' << 8) | ((byte)'2' << 16) | ((byte)'1' << 24);

		public const int DF_IMAGE_UYVY = ((byte)'U') | ((byte)'Y' << 8) | ((byte)'V' << 16) | ((byte)'Y' << 24);

		public const int DF_IMAGE_YUYV = ((byte)'Y') | ((byte)'U' << 8) | ((byte)'Y' << 16) | ((byte)'V' << 24);

		public const int DF_IMAGE_IYUV = ((byte)'I') | ((byte)'Y' << 8) | ((byte)'U' << 16) | ((byte)'V' << 24);

		public const int DF_IMAGE_YUV4 = ((byte)'Y') | ((byte)'U' << 8) | ((byte)'V' << 16) | ((byte)'4' << 24);

		public const int DF_IMAGE_U8 = ((byte)'U') | ((byte)'0' << 8) | ((byte)'0' << 16) | ((byte)'8' << 24);

		public const int DF_IMAGE_U16 = ((byte)'U') | ((byte)'0' << 8) | ((byte)'1' << 16) | ((byte)'6' << 24);

		public const int DF_IMAGE_S16 = ((byte)'S') | ((byte)'0' << 8) | ((byte)'1' << 16) | ((byte)'6' << 24);

		public const int DF_IMAGE_U32 = ((byte)'U') | ((byte)'0' << 8) | ((byte)'3' << 16) | ((byte)'2' << 24);

		public const int DF_IMAGE_S32 = ((byte)'S') | ((byte)'0' << 8) | ((byte)'3' << 16) | ((byte)'2' << 24);

		public const int TARGET_ANY = ((ID_KHRONOS << 20) | ( ENUM_TARGET << 12)) + 0x0000;

		public const int TARGET_STRING = ((ID_KHRONOS << 20) | ( ENUM_TARGET << 12)) + 0x0001;

		public const int TARGET_VENDOR_BEGIN = ((ID_KHRONOS << 20) | ( ENUM_TARGET << 12)) + 0x1000;

		public const int REFERENCE_COUNT = (((ID_KHRONOS) << 20) | ( TYPE_REFERENCE << 8)) + 0x0;

		public const int REFERENCE_TYPE = (((ID_KHRONOS) << 20) | ( TYPE_REFERENCE << 8)) + 0x1;

		public const int REFERENCE_NAME = (((ID_KHRONOS) << 20) | ( TYPE_REFERENCE << 8)) + 0x2;

		public const int CONTEXT_VENDOR_ID = (((ID_KHRONOS) << 20) | ( TYPE_CONTEXT << 8)) + 0x0;

		public const int CONTEXT_VERSION = (((ID_KHRONOS) << 20) | ( TYPE_CONTEXT << 8)) + 0x1;

		public const int CONTEXT_UNIQUE_KERNELS = (((ID_KHRONOS) << 20) | ( TYPE_CONTEXT << 8)) + 0x2;

		public const int CONTEXT_MODULES = (((ID_KHRONOS) << 20) | ( TYPE_CONTEXT << 8)) + 0x3;

		public const int CONTEXT_REFERENCES = (((ID_KHRONOS) << 20) | ( TYPE_CONTEXT << 8)) + 0x4;

		public const int CONTEXT_IMPLEMENTATION = (((ID_KHRONOS) << 20) | ( TYPE_CONTEXT << 8)) + 0x5;

		public const int CONTEXT_EXTENSIONS_SIZE = (((ID_KHRONOS) << 20) | ( TYPE_CONTEXT << 8)) + 0x6;

		public const int CONTEXT_EXTENSIONS = (((ID_KHRONOS) << 20) | ( TYPE_CONTEXT << 8)) + 0x7;

		public const int CONTEXT_CONVOLUTION_MAX_DIMENSION = (((ID_KHRONOS) << 20) | ( TYPE_CONTEXT << 8)) + 0x8;

		public const int CONTEXT_OPTICAL_FLOW_MAX_WINDOW_DIMENSION = (((ID_KHRONOS) << 20) | ( TYPE_CONTEXT << 8)) + 0x9;

		public const int CONTEXT_IMMEDIATE_BORDER = (((ID_KHRONOS) << 20) | ( TYPE_CONTEXT << 8)) + 0xA;

		public const int CONTEXT_UNIQUE_KERNEL_TABLE = (((ID_KHRONOS) << 20) | ( TYPE_CONTEXT << 8)) + 0xB;

		public const int CONTEXT_IMMEDIATE_BORDER_POLICY = (((ID_KHRONOS) << 20) | ( TYPE_CONTEXT << 8)) + 0xC;

		public const int CONTEXT_NONLINEAR_MAX_DIMENSION = (((ID_KHRONOS) << 20) | ( TYPE_CONTEXT << 8)) + 0xd;

		public const int KERNEL_PARAMETERS = (((ID_KHRONOS) << 20) | ( TYPE_KERNEL << 8)) + 0x0;

		public const int KERNEL_NAME = (((ID_KHRONOS) << 20) | ( TYPE_KERNEL << 8)) + 0x1;

		public const int KERNEL_ENUM = (((ID_KHRONOS) << 20) | ( TYPE_KERNEL << 8)) + 0x2;

		public const int KERNEL_LOCAL_DATA_SIZE = (((ID_KHRONOS) << 20) | ( TYPE_KERNEL << 8)) + 0x3;

		public const int NODE_STATUS = (((ID_KHRONOS) << 20) | ( TYPE_NODE << 8)) + 0x0;

		public const int NODE_PERFORMANCE = (((ID_KHRONOS) << 20) | ( TYPE_NODE << 8)) + 0x1;

		public const int NODE_BORDER = (((ID_KHRONOS) << 20) | ( TYPE_NODE << 8)) + 0x2;

		public const int NODE_LOCAL_DATA_SIZE = (((ID_KHRONOS) << 20) | ( TYPE_NODE << 8)) + 0x3;

		public const int NODE_LOCAL_DATA_PTR = (((ID_KHRONOS) << 20) | ( TYPE_NODE << 8)) + 0x4;

		public const int NODE_PARAMETERS = (((ID_KHRONOS) << 20) | ( TYPE_NODE << 8)) + 0x5;

		public const int NODE_IS_REPLICATED = (((ID_KHRONOS) << 20) | ( TYPE_NODE << 8)) + 0x6;

		public const int NODE_REPLICATE_FLAGS = (((ID_KHRONOS) << 20) | ( TYPE_NODE << 8)) + 0x7;

		public const int NODE_VALID_RECT_RESET = (((ID_KHRONOS) << 20) | ( TYPE_NODE << 8)) + 0x8;

		public const int PARAMETER_INDEX = (((ID_KHRONOS) << 20) | ( TYPE_PARAMETER << 8)) + 0x0;

		public const int PARAMETER_DIRECTION = (((ID_KHRONOS) << 20) | ( TYPE_PARAMETER << 8)) + 0x1;

		public const int PARAMETER_TYPE = (((ID_KHRONOS) << 20) | ( TYPE_PARAMETER << 8)) + 0x2;

		public const int PARAMETER_STATE = (((ID_KHRONOS) << 20) | ( TYPE_PARAMETER << 8)) + 0x3;

		public const int PARAMETER_REF = (((ID_KHRONOS) << 20) | ( TYPE_PARAMETER << 8)) + 0x4;

		public const int IMAGE_WIDTH = (((ID_KHRONOS) << 20) | ( TYPE_IMAGE << 8)) + 0x0;

		public const int IMAGE_HEIGHT = (((ID_KHRONOS) << 20) | ( TYPE_IMAGE << 8)) + 0x1;

		public const int IMAGE_FORMAT = (((ID_KHRONOS) << 20) | ( TYPE_IMAGE << 8)) + 0x2;

		public const int IMAGE_PLANES = (((ID_KHRONOS) << 20) | ( TYPE_IMAGE << 8)) + 0x3;

		public const int IMAGE_SPACE = (((ID_KHRONOS) << 20) | ( TYPE_IMAGE << 8)) + 0x4;

		public const int IMAGE_RANGE = (((ID_KHRONOS) << 20) | ( TYPE_IMAGE << 8)) + 0x5;

		public const int IMAGE_SIZE = (((ID_KHRONOS) << 20) | ( TYPE_IMAGE << 8)) + 0x6;

		public const int IMAGE_MEMORY_TYPE = (((ID_KHRONOS) << 20) | ( TYPE_IMAGE << 8)) + 0x7;

		public const int SCALAR_TYPE = (((ID_KHRONOS) << 20) | ( TYPE_SCALAR << 8)) + 0x0;

		public const int LUT_TYPE = (((ID_KHRONOS) << 20) | (TYPE_LUT << 8)) + 0x0;

		public const int LUT_COUNT = (((ID_KHRONOS) << 20) | (TYPE_LUT << 8)) + 0x1;

		public const int LUT_SIZE = (((ID_KHRONOS) << 20) | (TYPE_LUT << 8)) + 0x2;

		public const int LUT_OFFSET = (((ID_KHRONOS) << 20) | (TYPE_LUT << 8)) + 0x3;

		public const int DISTRIBUTION_DIMENSIONS = (((ID_KHRONOS) << 20) | ( TYPE_DISTRIBUTION << 8)) + 0x0;

		public const int DISTRIBUTION_OFFSET = (((ID_KHRONOS) << 20) | ( TYPE_DISTRIBUTION << 8)) + 0x1;

		public const int DISTRIBUTION_RANGE = (((ID_KHRONOS) << 20) | ( TYPE_DISTRIBUTION << 8)) + 0x2;

		public const int DISTRIBUTION_BINS = (((ID_KHRONOS) << 20) | ( TYPE_DISTRIBUTION << 8)) + 0x3;

		public const int DISTRIBUTION_WINDOW = (((ID_KHRONOS) << 20) | ( TYPE_DISTRIBUTION << 8)) + 0x4;

		public const int DISTRIBUTION_SIZE = (((ID_KHRONOS) << 20) | ( TYPE_DISTRIBUTION << 8)) + 0x5;

		public const int THRESHOLD_TYPE_BINARY = ((ID_KHRONOS << 20) | ( ENUM_THRESHOLD_TYPE << 12)) + 0x0;

		public const int THRESHOLD_TYPE_RANGE = ((ID_KHRONOS << 20) | ( ENUM_THRESHOLD_TYPE << 12)) + 0x1;

		public const int THRESHOLD_TYPE = (((ID_KHRONOS) << 20) | ( TYPE_THRESHOLD << 8)) + 0x0;

		public const int THRESHOLD_THRESHOLD_VALUE = (((ID_KHRONOS) << 20) | ( TYPE_THRESHOLD << 8)) + 0x1;

		public const int THRESHOLD_THRESHOLD_LOWER = (((ID_KHRONOS) << 20) | ( TYPE_THRESHOLD << 8)) + 0x2;

		public const int THRESHOLD_THRESHOLD_UPPER = (((ID_KHRONOS) << 20) | ( TYPE_THRESHOLD << 8)) + 0x3;

		public const int THRESHOLD_TRUE_VALUE = (((ID_KHRONOS) << 20) | ( TYPE_THRESHOLD << 8)) + 0x4;

		public const int THRESHOLD_FALSE_VALUE = (((ID_KHRONOS) << 20) | ( TYPE_THRESHOLD << 8)) + 0x5;

		public const int THRESHOLD_DATA_TYPE = (((ID_KHRONOS) << 20) | ( TYPE_THRESHOLD << 8)) + 0x6;

		public const int MATRIX_TYPE = (((ID_KHRONOS) << 20) | ( TYPE_MATRIX << 8)) + 0x0;

		public const int MATRIX_ROWS = (((ID_KHRONOS) << 20) | ( TYPE_MATRIX << 8)) + 0x1;

		public const int MATRIX_COLUMNS = (((ID_KHRONOS) << 20) | ( TYPE_MATRIX << 8)) + 0x2;

		public const int MATRIX_SIZE = (((ID_KHRONOS) << 20) | ( TYPE_MATRIX << 8)) + 0x3;

		public const int MATRIX_ORIGIN = (((ID_KHRONOS) << 20) | ( TYPE_MATRIX << 8)) + 0x4;

		public const int MATRIX_PATTERN = (((ID_KHRONOS) << 20) | ( TYPE_MATRIX << 8)) + 0x5;

		public const int CONVOLUTION_ROWS = (((ID_KHRONOS) << 20) | ( TYPE_CONVOLUTION << 8)) + 0x0;

		public const int CONVOLUTION_COLUMNS = (((ID_KHRONOS) << 20) | ( TYPE_CONVOLUTION << 8)) + 0x1;

		public const int CONVOLUTION_SCALE = (((ID_KHRONOS) << 20) | ( TYPE_CONVOLUTION << 8)) + 0x2;

		public const int CONVOLUTION_SIZE = (((ID_KHRONOS) << 20) | ( TYPE_CONVOLUTION << 8)) + 0x3;

		public const int PYRAMID_LEVELS = (((ID_KHRONOS) << 20) | ( TYPE_PYRAMID << 8)) + 0x0;

		public const int PYRAMID_SCALE = (((ID_KHRONOS) << 20) | ( TYPE_PYRAMID << 8)) + 0x1;

		public const int PYRAMID_WIDTH = (((ID_KHRONOS) << 20) | ( TYPE_PYRAMID << 8)) + 0x2;

		public const int PYRAMID_HEIGHT = (((ID_KHRONOS) << 20) | ( TYPE_PYRAMID << 8)) + 0x3;

		public const int PYRAMID_FORMAT = (((ID_KHRONOS) << 20) | ( TYPE_PYRAMID << 8)) + 0x4;

		public const int REMAP_SOURCE_WIDTH = (((ID_KHRONOS) << 20) | ( TYPE_REMAP << 8)) + 0x0;

		public const int REMAP_SOURCE_HEIGHT = (((ID_KHRONOS) << 20) | ( TYPE_REMAP << 8)) + 0x1;

		public const int REMAP_DESTINATION_WIDTH = (((ID_KHRONOS) << 20) | ( TYPE_REMAP << 8)) + 0x2;

		public const int REMAP_DESTINATION_HEIGHT = (((ID_KHRONOS) << 20) | ( TYPE_REMAP << 8)) + 0x3;

		public const int ARRAY_ITEMTYPE = (((ID_KHRONOS) << 20) | ( TYPE_ARRAY << 8)) + 0x0;

		public const int ARRAY_NUMITEMS = (((ID_KHRONOS) << 20) | ( TYPE_ARRAY << 8)) + 0x1;

		public const int ARRAY_CAPACITY = (((ID_KHRONOS) << 20) | ( TYPE_ARRAY << 8)) + 0x2;

		public const int ARRAY_ITEMSIZE = (((ID_KHRONOS) << 20) | ( TYPE_ARRAY << 8)) + 0x3;

		public const int OBJECT_ARRAY_ITEMTYPE = (((ID_KHRONOS) << 20) | ( TYPE_OBJECT_ARRAY << 8)) + 0x0;

		public const int OBJECT_ARRAY_NUMITEMS = (((ID_KHRONOS) << 20) | ( TYPE_OBJECT_ARRAY << 8)) + 0x1;

		public const int VALID_RECT_CALLBACK = (((ID_KHRONOS) << 20) | ( TYPE_META_FORMAT << 8)) + 0x1;

		public const int CHANNEL_0 = ((ID_KHRONOS << 20) | ( ENUM_CHANNEL << 12)) + 0x0;

		public const int CHANNEL_1 = ((ID_KHRONOS << 20) | ( ENUM_CHANNEL << 12)) + 0x1;

		public const int CHANNEL_2 = ((ID_KHRONOS << 20) | ( ENUM_CHANNEL << 12)) + 0x2;

		public const int CHANNEL_3 = ((ID_KHRONOS << 20) | ( ENUM_CHANNEL << 12)) + 0x3;

		public const int CHANNEL_R = ((ID_KHRONOS << 20) | ( ENUM_CHANNEL << 12)) + 0x10;

		public const int CHANNEL_G = ((ID_KHRONOS << 20) | ( ENUM_CHANNEL << 12)) + 0x11;

		public const int CHANNEL_B = ((ID_KHRONOS << 20) | ( ENUM_CHANNEL << 12)) + 0x12;

		public const int CHANNEL_A = ((ID_KHRONOS << 20) | ( ENUM_CHANNEL << 12)) + 0x13;

		public const int CHANNEL_Y = ((ID_KHRONOS << 20) | ( ENUM_CHANNEL << 12)) + 0x14;

		public const int CHANNEL_U = ((ID_KHRONOS << 20) | ( ENUM_CHANNEL << 12)) + 0x15;

		public const int CHANNEL_V = ((ID_KHRONOS << 20) | ( ENUM_CHANNEL << 12)) + 0x16;

		public const int MEMORY_TYPE_NONE = ((ID_KHRONOS << 20) | ( ENUM_MEMORY_TYPE << 12)) + 0x0;

		public const int MEMORY_TYPE_HOST = ((ID_KHRONOS << 20) | ( ENUM_MEMORY_TYPE << 12)) + 0x1;

		public const int INTERPOLATION_NEAREST_NEIGHBOR = ((ID_KHRONOS << 20) | ( ENUM_INTERPOLATION << 12)) + 0x0;

		public const int INTERPOLATION_BILINEAR = ((ID_KHRONOS << 20) | ( ENUM_INTERPOLATION << 12)) + 0x1;

		public const int INTERPOLATION_AREA = ((ID_KHRONOS << 20) | ( ENUM_INTERPOLATION << 12)) + 0x2;

		public const int NONLINEAR_FILTER_MEDIAN = ((ID_KHRONOS << 20) | ( ENUM_NONLINEAR << 12)) + 0x0;

		public const int NONLINEAR_FILTER_MIN = ((ID_KHRONOS << 20) | ( ENUM_NONLINEAR << 12)) + 0x1;

		public const int NONLINEAR_FILTER_MAX = ((ID_KHRONOS << 20) | ( ENUM_NONLINEAR << 12)) + 0x2;

		public const int PATTERN_BOX = ((ID_KHRONOS << 20) | ( ENUM_PATTERN << 12)) + 0x0;

		public const int PATTERN_CROSS = ((ID_KHRONOS << 20) | ( ENUM_PATTERN << 12)) + 0x1;

		public const int PATTERN_DISK = ((ID_KHRONOS << 20) | ( ENUM_PATTERN << 12)) + 0x2;

		public const int PATTERN_OTHER = ((ID_KHRONOS << 20) | ( ENUM_PATTERN << 12)) + 0x3;

		public const int COLOR_SPACE_NONE = ((ID_KHRONOS << 20) | ( ENUM_COLOR_SPACE << 12)) + 0x0;

		public const int COLOR_SPACE_BT601_525 = ((ID_KHRONOS << 20) | ( ENUM_COLOR_SPACE << 12)) + 0x1;

		public const int COLOR_SPACE_BT601_625 = ((ID_KHRONOS << 20) | ( ENUM_COLOR_SPACE << 12)) + 0x2;

		public const int COLOR_SPACE_BT709 = ((ID_KHRONOS << 20) | ( ENUM_COLOR_SPACE << 12)) + 0x3;

		public const int COLOR_SPACE_DEFAULT = COLOR_SPACE_BT709;

		public const int CHANNEL_RANGE_FULL = ((ID_KHRONOS << 20) | ( ENUM_COLOR_RANGE << 12)) + 0x0;

		public const int CHANNEL_RANGE_RESTRICTED = ((ID_KHRONOS << 20) | ( ENUM_COLOR_RANGE << 12)) + 0x1;

		public const int PARAMETER_STATE_REQUIRED = ((ID_KHRONOS << 20) | ( ENUM_PARAMETER_STATE << 12)) + 0x0;

		public const int PARAMETER_STATE_OPTIONAL = ((ID_KHRONOS << 20) | ( ENUM_PARAMETER_STATE << 12)) + 0x1;

		public const int BORDER_UNDEFINED = ((ID_KHRONOS << 20) | ( ENUM_BORDER << 12)) + 0x0;

		public const int BORDER_CONSTANT = ((ID_KHRONOS << 20) | ( ENUM_BORDER << 12)) + 0x1;

		public const int BORDER_REPLICATE = ((ID_KHRONOS << 20) | ( ENUM_BORDER << 12)) + 0x2;

		public const int BORDER_POLICY_DEFAULT_TO_UNDEFINED = ((ID_KHRONOS << 20) | ( ENUM_BORDER_POLICY << 12)) + 0x0;

		public const int BORDER_POLICY_RETURN_ERROR = ((ID_KHRONOS << 20) | ( ENUM_BORDER_POLICY << 12)) + 0x1;

		public const int TERM_CRITERIA_ITERATIONS = ((ID_KHRONOS << 20) | ( ENUM_TERM_CRITERIA << 12)) + 0x0;

		public const int TERM_CRITERIA_EPSILON = ((ID_KHRONOS << 20) | ( ENUM_TERM_CRITERIA << 12)) + 0x1;

		public const int TERM_CRITERIA_BOTH = ((ID_KHRONOS << 20) | ( ENUM_TERM_CRITERIA << 12)) + 0x2;

		public const int NORM_L1 = ((ID_KHRONOS << 20) | ( ENUM_NORM_TYPE << 12)) + 0x0;

		public const int NORM_L2 = ((ID_KHRONOS << 20) | ( ENUM_NORM_TYPE << 12)) + 0x1;

		public const int DELAY_TYPE = (((ID_KHRONOS) << 20) | ( TYPE_DELAY << 8)) + 0x0;

		public const int DELAY_SLOTS = (((ID_KHRONOS) << 20) | ( TYPE_DELAY << 8)) + 0x1;

		public const int READ_ONLY = ((ID_KHRONOS << 20) | ( ENUM_ACCESSOR << 12)) + 0x1;

		public const int WRITE_ONLY = ((ID_KHRONOS << 20) | ( ENUM_ACCESSOR << 12)) + 0x2;

		public const int READ_AND_WRITE = ((ID_KHRONOS << 20) | ( ENUM_ACCESSOR << 12)) + 0x3;

		public const int ROUND_POLICY_TO_ZERO = ((ID_KHRONOS << 20) | ( ENUM_ROUND_POLICY << 12)) + 0x1;

		public const int ROUND_POLICY_TO_NEAREST_EVEN = ((ID_KHRONOS << 20) | ( ENUM_ROUND_POLICY << 12)) + 0x2;

		public const int NOGAP_X = 1;

		public const int LIBRARY_KHR_BASE = 0x0;

		public const int KERNEL_COLOR_CONVERT = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x1;

		public const int KERNEL_CHANNEL_EXTRACT = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x2;

		public const int KERNEL_CHANNEL_COMBINE = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x3;

		public const int KERNEL_SOBEL_3x3 = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x4;

		public const int KERNEL_MAGNITUDE = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x5;

		public const int KERNEL_PHASE = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x6;

		public const int KERNEL_SCALE_IMAGE = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x7;

		public const int KERNEL_TABLE_LOOKUP = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x8;

		public const int KERNEL_HISTOGRAM = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x9;

		public const int KERNEL_EQUALIZE_HISTOGRAM = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0xA;

		public const int KERNEL_ABSDIFF = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0xB;

		public const int KERNEL_MEAN_STDDEV = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0xC;

		public const int KERNEL_THRESHOLD = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0xD;

		public const int KERNEL_INTEGRAL_IMAGE = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0xE;

		public const int KERNEL_DILATE_3x3 = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0xF;

		public const int KERNEL_ERODE_3x3 = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x10;

		public const int KERNEL_MEDIAN_3x3 = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x11;

		public const int KERNEL_BOX_3x3 = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x12;

		public const int KERNEL_GAUSSIAN_3x3 = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x13;

		public const int KERNEL_CUSTOM_CONVOLUTION = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x14;

		public const int KERNEL_GAUSSIAN_PYRAMID = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x15;

		public const int KERNEL_ACCUMULATE = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x16;

		public const int KERNEL_ACCUMULATE_WEIGHTED = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x17;

		public const int KERNEL_ACCUMULATE_SQUARE = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x18;

		public const int KERNEL_MINMAXLOC = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x19;

		public const int KERNEL_CONVERTDEPTH = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x1A;

		public const int KERNEL_CANNY_EDGE_DETECTOR = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x1B;

		public const int KERNEL_AND = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x1C;

		public const int KERNEL_OR = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x1D;

		public const int KERNEL_XOR = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x1E;

		public const int KERNEL_NOT = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x1F;

		public const int KERNEL_MULTIPLY = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x20;

		public const int KERNEL_ADD = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x21;

		public const int KERNEL_SUBTRACT = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x22;

		public const int KERNEL_WARP_AFFINE = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x23;

		public const int KERNEL_WARP_PERSPECTIVE = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x24;

		public const int KERNEL_HARRIS_CORNERS = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x25;

		public const int KERNEL_FAST_CORNERS = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x26;

		public const int KERNEL_OPTICAL_FLOW_PYR_LK = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x27;

		public const int KERNEL_REMAP = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x28;

		public const int KERNEL_HALFSCALE_GAUSSIAN = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x29;

		public const int KERNEL_LAPLACIAN_PYRAMID = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x2A;

		public const int KERNEL_LAPLACIAN_RECONSTRUCT = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x2B;

		public const int KERNEL_NON_LINEAR_FILTER = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x2C;

		public const int ID_KHRONOS = 0x000;

		public const int ID_TI = 0x001;

		public const int ID_QUALCOMM = 0x002;

		public const int ID_NVIDIA = 0x003;

		public const int ID_ARM = 0x004;

		public const int ID_BDTI = 0x005;

		public const int ID_RENESAS = 0x006;

		public const int ID_VIVANTE = 0x007;

		public const int ID_XILINX = 0x008;

		public const int ID_AXIS = 0x009;

		public const int ID_MOVIDIUS = 0x00A;

		public const int ID_SAMSUNG = 0x00B;

		public const int ID_FREESCALE = 0x00C;

		public const int ID_AMD = 0x00D;

		public const int ID_BROADCOM = 0x00E;

		public const int ID_INTEL = 0x00F;

		public const int ID_MARVELL = 0x010;

		public const int ID_MEDIATEK = 0x011;

		public const int ID_ST = 0x012;

		public const int ID_CEVA = 0x013;

		public const int ID_ITSEEZ = 0x014;

		public const int ID_NXP = 0x016;

		public const int ID_VIDEANTIS = 0x017;

		public const int ID_SYNOPSYS = 0x018;

		public const int ID_CADENCE = 0x019;

		public const int ID_HUAWEI = 0x01A;

		public const int ID_USER = 0xFFE;

		public const int ID_MAX = 0xFFF;

		public const int ID_DEFAULT = ID_MAX;

		public static IntPtr CreateContext()
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxCreateContext != null, "pvxCreateContext not implemented");
			retValue = Delegates.pvxCreateContext();
			LogCommand("vxCreateContext", retValue			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int ReleaseContext(IntPtr[] context)
		{
			int retValue;

			unsafe {
				fixed (IntPtr* p_context = context)
				{
					Debug.Assert(Delegates.pvxReleaseContext != null, "pvxReleaseContext not implemented");
					retValue = Delegates.pvxReleaseContext(p_context);
					LogCommand("vxReleaseContext", retValue, context					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr GetContext(IntPtr reference)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxGetContext != null, "pvxGetContext not implemented");
			retValue = Delegates.pvxGetContext(reference);
			LogCommand("vxGetContext", retValue, reference			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int QueryContext(IntPtr context, int attribute, IntPtr ptr, uint size)
		{
			int retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryContext != null, "pvxQueryContext not implemented");
					retValue = Delegates.pvxQueryContext(context, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryContext", retValue, context, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int SetContextAttribute(IntPtr context, int attribute, IntPtr ptr, uint size)
		{
			int retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxSetContextAttribute != null, "pvxSetContextAttribute not implemented");
					retValue = Delegates.pvxSetContextAttribute(context, attribute, ptr.ToPointer(), size);
					LogCommand("vxSetContextAttribute", retValue, context, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int Hint(IntPtr reference, int hint, IntPtr data, uint data_size)
		{
			int retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxHint != null, "pvxHint not implemented");
					retValue = Delegates.pvxHint(reference, hint, data.ToPointer(), data_size);
					LogCommand("vxHint", retValue, reference, hint, data, data_size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int Directive(IntPtr reference, int directive)
		{
			int retValue;

			Debug.Assert(Delegates.pvxDirective != null, "pvxDirective not implemented");
			retValue = Delegates.pvxDirective(reference, directive);
			LogCommand("vxDirective", retValue, reference, directive			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int GetStatus(IntPtr reference)
		{
			int retValue;

			Debug.Assert(Delegates.pvxGetStatus != null, "pvxGetStatus not implemented");
			retValue = Delegates.pvxGetStatus(reference);
			LogCommand("vxGetStatus", retValue, reference			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int RegisterUserStruct(IntPtr context, uint size)
		{
			int retValue;

			Debug.Assert(Delegates.pvxRegisterUserStruct != null, "pvxRegisterUserStruct not implemented");
			retValue = Delegates.pvxRegisterUserStruct(context, size);
			LogCommand("vxRegisterUserStruct", retValue, context, size			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int AllocateUserKernelId(IntPtr context, int[] pKernelEnumId)
		{
			int retValue;

			unsafe {
				fixed (int* p_pKernelEnumId = pKernelEnumId)
				{
					Debug.Assert(Delegates.pvxAllocateUserKernelId != null, "pvxAllocateUserKernelId not implemented");
					retValue = Delegates.pvxAllocateUserKernelId(context, p_pKernelEnumId);
					LogCommand("vxAllocateUserKernelId", retValue, context, pKernelEnumId					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int AllocateUserKernelLibraryId(IntPtr context, int[] pLibraryId)
		{
			int retValue;

			unsafe {
				fixed (int* p_pLibraryId = pLibraryId)
				{
					Debug.Assert(Delegates.pvxAllocateUserKernelLibraryId != null, "pvxAllocateUserKernelLibraryId not implemented");
					retValue = Delegates.pvxAllocateUserKernelLibraryId(context, p_pLibraryId);
					LogCommand("vxAllocateUserKernelLibraryId", retValue, context, pLibraryId					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int SetImmediateModeTarget(IntPtr context, int target_enum, string target_string)
		{
			int retValue;

			Debug.Assert(Delegates.pvxSetImmediateModeTarget != null, "pvxSetImmediateModeTarget not implemented");
			retValue = Delegates.pvxSetImmediateModeTarget(context, target_enum, target_string);
			LogCommand("vxSetImmediateModeTarget", retValue, context, target_enum, target_string			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr CreateImage(IntPtr context, uint width, uint height, uint color)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxCreateImage != null, "pvxCreateImage not implemented");
			retValue = Delegates.pvxCreateImage(context, width, height, color);
			LogCommand("vxCreateImage", retValue, context, width, height, color			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr CreateImageFromROI(IntPtr img, Rectangle[] rect)
		{
			IntPtr retValue;

			unsafe {
				fixed (Rectangle* p_rect = rect)
				{
					Debug.Assert(Delegates.pvxCreateImageFromROI != null, "pvxCreateImageFromROI not implemented");
					retValue = Delegates.pvxCreateImageFromROI(img, p_rect);
					LogCommand("vxCreateImageFromROI", retValue, img, rect					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr CreateUniformImage(IntPtr context, uint width, uint height, uint color, PixelValue value)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxCreateUniformImage != null, "pvxCreateUniformImage not implemented");
			retValue = Delegates.pvxCreateUniformImage(context, width, height, color, value);
			LogCommand("vxCreateUniformImage", retValue, context, width, height, color, value			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr CreateVirtualImage(IntPtr graph, uint width, uint height, uint color)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxCreateVirtualImage != null, "pvxCreateVirtualImage not implemented");
			retValue = Delegates.pvxCreateVirtualImage(graph, width, height, color);
			LogCommand("vxCreateVirtualImage", retValue, graph, width, height, color			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr CreateImageFromHandle(IntPtr context, uint color, ImagePatchAddressing[] addrs, IntPtr[] ptrs, int memory_type)
		{
			IntPtr retValue;

			unsafe {
				fixed (ImagePatchAddressing* p_addrs = addrs)
				fixed (IntPtr* p_ptrs = ptrs)
				{
					Debug.Assert(Delegates.pvxCreateImageFromHandle != null, "pvxCreateImageFromHandle not implemented");
					retValue = Delegates.pvxCreateImageFromHandle(context, color, p_addrs, p_ptrs, memory_type);
					LogCommand("vxCreateImageFromHandle", retValue, context, color, addrs, ptrs, memory_type					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int SwapImageHandle(IntPtr image, IntPtr[] new_ptrs, IntPtr[] prev_ptrs, uint num_planes)
		{
			int retValue;

			unsafe {
				fixed (IntPtr* p_new_ptrs = new_ptrs)
				fixed (IntPtr* p_prev_ptrs = prev_ptrs)
				{
					Debug.Assert(Delegates.pvxSwapImageHandle != null, "pvxSwapImageHandle not implemented");
					retValue = Delegates.pvxSwapImageHandle(image, p_new_ptrs, p_prev_ptrs, num_planes);
					LogCommand("vxSwapImageHandle", retValue, image, new_ptrs, prev_ptrs, num_planes					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int QueryImage(IntPtr image, int attribute, IntPtr ptr, uint size)
		{
			int retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryImage != null, "pvxQueryImage not implemented");
					retValue = Delegates.pvxQueryImage(image, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryImage", retValue, image, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int SetImageAttribute(IntPtr image, int attribute, IntPtr ptr, uint size)
		{
			int retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxSetImageAttribute != null, "pvxSetImageAttribute not implemented");
					retValue = Delegates.pvxSetImageAttribute(image, attribute, ptr.ToPointer(), size);
					LogCommand("vxSetImageAttribute", retValue, image, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int ReleaseImage(IntPtr[] image)
		{
			int retValue;

			unsafe {
				fixed (IntPtr* p_image = image)
				{
					Debug.Assert(Delegates.pvxReleaseImage != null, "pvxReleaseImage not implemented");
					retValue = Delegates.pvxReleaseImage(p_image);
					LogCommand("vxReleaseImage", retValue, image					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static uint ComputeImagePatchSize(IntPtr image, Rectangle[] rect, uint plane_index)
		{
			uint retValue;

			unsafe {
				fixed (Rectangle* p_rect = rect)
				{
					Debug.Assert(Delegates.pvxComputeImagePatchSize != null, "pvxComputeImagePatchSize not implemented");
					retValue = Delegates.pvxComputeImagePatchSize(image, p_rect, plane_index);
					LogCommand("vxComputeImagePatchSize", retValue, image, rect, plane_index					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr FormatImagePatchAdd(IntPtr ptr, uint index, ImagePatchAddressing[] addr)
		{
			IntPtr retValue;

			unsafe {
				fixed (ImagePatchAddressing* p_addr = addr)
				{
					Debug.Assert(Delegates.pvxFormatImagePatchAddress1d != null, "pvxFormatImagePatchAddress1d not implemented");
					retValue = Delegates.pvxFormatImagePatchAddress1d(ptr.ToPointer(), index, p_addr);
					LogCommand("vxFormatImagePatchAddress1d", retValue, ptr, index, addr					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr FormatImagePatchAdd(IntPtr ptr, uint x, uint y, ImagePatchAddressing[] addr)
		{
			IntPtr retValue;

			unsafe {
				fixed (ImagePatchAddressing* p_addr = addr)
				{
					Debug.Assert(Delegates.pvxFormatImagePatchAddress2d != null, "pvxFormatImagePatchAddress2d not implemented");
					retValue = Delegates.pvxFormatImagePatchAddress2d(ptr.ToPointer(), x, y, p_addr);
					LogCommand("vxFormatImagePatchAddress2d", retValue, ptr, x, y, addr					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int GetValidRegionImage(IntPtr image, [Out] Rectangle[] rect)
		{
			int retValue;

			unsafe {
				fixed (Rectangle* p_rect = rect)
				{
					Debug.Assert(Delegates.pvxGetValidRegionImage != null, "pvxGetValidRegionImage not implemented");
					retValue = Delegates.pvxGetValidRegionImage(image, p_rect);
					LogCommand("vxGetValidRegionImage", retValue, image, rect					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int CopyImagePatch(IntPtr image, Rectangle[] image_rect, uint image_plane_index, ImagePatchAddressing[] user_addr, IntPtr user_ptr, int usage, int user_mem_type)
		{
			int retValue;

			unsafe {
				fixed (Rectangle* p_image_rect = image_rect)
				fixed (ImagePatchAddressing* p_user_addr = user_addr)
				{
					Debug.Assert(Delegates.pvxCopyImagePatch != null, "pvxCopyImagePatch not implemented");
					retValue = Delegates.pvxCopyImagePatch(image, p_image_rect, image_plane_index, p_user_addr, user_ptr.ToPointer(), usage, user_mem_type);
					LogCommand("vxCopyImagePatch", retValue, image, image_rect, image_plane_index, user_addr, user_ptr, usage, user_mem_type					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int MapImagePatch(IntPtr image, Rectangle[] rect, uint plane_index, UIntPtr[] map_id, ImagePatchAddressing[] addr, IntPtr[] ptr, int usage, int mem_type, uint flags)
		{
			int retValue;

			unsafe {
				fixed (Rectangle* p_rect = rect)
				fixed (UIntPtr* p_map_id = map_id)
				fixed (ImagePatchAddressing* p_addr = addr)
				fixed (IntPtr* p_ptr = ptr)
				{
					Debug.Assert(Delegates.pvxMapImagePatch != null, "pvxMapImagePatch not implemented");
					retValue = Delegates.pvxMapImagePatch(image, p_rect, plane_index, p_map_id, p_addr, p_ptr, usage, mem_type, flags);
					LogCommand("vxMapImagePatch", retValue, image, rect, plane_index, map_id, addr, ptr, usage, mem_type, flags					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int UnmapImagePatch(IntPtr image, UIntPtr map_id)
		{
			int retValue;

			Debug.Assert(Delegates.pvxUnmapImagePatch != null, "pvxUnmapImagePatch not implemented");
			retValue = Delegates.pvxUnmapImagePatch(image, map_id);
			LogCommand("vxUnmapImagePatch", retValue, image, map_id			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr CreateImageFromChannel(IntPtr img, int channel)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxCreateImageFromChannel != null, "pvxCreateImageFromChannel not implemented");
			retValue = Delegates.pvxCreateImageFromChannel(img, channel);
			LogCommand("vxCreateImageFromChannel", retValue, img, channel			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int SetImageValidRectangle(IntPtr image, Rectangle[] rect)
		{
			int retValue;

			unsafe {
				fixed (Rectangle* p_rect = rect)
				{
					Debug.Assert(Delegates.pvxSetImageValidRectangle != null, "pvxSetImageValidRectangle not implemented");
					retValue = Delegates.pvxSetImageValidRectangle(image, p_rect);
					LogCommand("vxSetImageValidRectangle", retValue, image, rect					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int LoadKernels(IntPtr context, string module)
		{
			int retValue;

			Debug.Assert(Delegates.pvxLoadKernels != null, "pvxLoadKernels not implemented");
			retValue = Delegates.pvxLoadKernels(context, module);
			LogCommand("vxLoadKernels", retValue, context, module			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int UnloadKernels(IntPtr context, string module)
		{
			int retValue;

			Debug.Assert(Delegates.pvxUnloadKernels != null, "pvxUnloadKernels not implemented");
			retValue = Delegates.pvxUnloadKernels(context, module);
			LogCommand("vxUnloadKernels", retValue, context, module			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr GetKernelByName(IntPtr context, string name)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxGetKernelByName != null, "pvxGetKernelByName not implemented");
			retValue = Delegates.pvxGetKernelByName(context, name);
			LogCommand("vxGetKernelByName", retValue, context, name			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr GetKernelByEnum(IntPtr context, int kernel)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxGetKernelByEnum != null, "pvxGetKernelByEnum not implemented");
			retValue = Delegates.pvxGetKernelByEnum(context, kernel);
			LogCommand("vxGetKernelByEnum", retValue, context, kernel			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int QueryKernel(IntPtr kernel, int attribute, IntPtr ptr, uint size)
		{
			int retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryKernel != null, "pvxQueryKernel not implemented");
					retValue = Delegates.pvxQueryKernel(kernel, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryKernel", retValue, kernel, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int ReleaseKernel(IntPtr[] kernel)
		{
			int retValue;

			unsafe {
				fixed (IntPtr* p_kernel = kernel)
				{
					Debug.Assert(Delegates.pvxReleaseKernel != null, "pvxReleaseKernel not implemented");
					retValue = Delegates.pvxReleaseKernel(p_kernel);
					LogCommand("vxReleaseKernel", retValue, kernel					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr AddUserKernel(IntPtr context, string name, int enumeration, KernelCallback func_ptr, uint numParams, KernelValidateCallbackCallback validate, KernelInitializeCallback init, KernelDeinitializeCallback deinit)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxAddUserKernel != null, "pvxAddUserKernel not implemented");
			retValue = Delegates.pvxAddUserKernel(context, name, enumeration, func_ptr, numParams, validate, init, deinit);
			LogCommand("vxAddUserKernel", retValue, context, name, enumeration, func_ptr, numParams, validate, init, deinit			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int FinalizeKernel(IntPtr kernel)
		{
			int retValue;

			Debug.Assert(Delegates.pvxFinalizeKernel != null, "pvxFinalizeKernel not implemented");
			retValue = Delegates.pvxFinalizeKernel(kernel);
			LogCommand("vxFinalizeKernel", retValue, kernel			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int AddParameterToKernel(IntPtr kernel, uint index, int dir, int data_type, int state)
		{
			int retValue;

			Debug.Assert(Delegates.pvxAddParameterToKernel != null, "pvxAddParameterToKernel not implemented");
			retValue = Delegates.pvxAddParameterToKernel(kernel, index, dir, data_type, state);
			LogCommand("vxAddParameterToKernel", retValue, kernel, index, dir, data_type, state			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int RemoveKernel(IntPtr kernel)
		{
			int retValue;

			Debug.Assert(Delegates.pvxRemoveKernel != null, "pvxRemoveKernel not implemented");
			retValue = Delegates.pvxRemoveKernel(kernel);
			LogCommand("vxRemoveKernel", retValue, kernel			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int SetKernelAttribute(IntPtr kernel, int attribute, IntPtr ptr, uint size)
		{
			int retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxSetKernelAttribute != null, "pvxSetKernelAttribute not implemented");
					retValue = Delegates.pvxSetKernelAttribute(kernel, attribute, ptr.ToPointer(), size);
					LogCommand("vxSetKernelAttribute", retValue, kernel, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr GetKernelParameterByIndex(IntPtr kernel, uint index)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxGetKernelParameterByIndex != null, "pvxGetKernelParameterByIndex not implemented");
			retValue = Delegates.pvxGetKernelParameterByIndex(kernel, index);
			LogCommand("vxGetKernelParameterByIndex", retValue, kernel, index			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr CreateGraph(IntPtr context)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxCreateGraph != null, "pvxCreateGraph not implemented");
			retValue = Delegates.pvxCreateGraph(context);
			LogCommand("vxCreateGraph", retValue, context			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int ReleaseGraph(IntPtr[] graph)
		{
			int retValue;

			unsafe {
				fixed (IntPtr* p_graph = graph)
				{
					Debug.Assert(Delegates.pvxReleaseGraph != null, "pvxReleaseGraph not implemented");
					retValue = Delegates.pvxReleaseGraph(p_graph);
					LogCommand("vxReleaseGraph", retValue, graph					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int VerifyGraph(IntPtr graph)
		{
			int retValue;

			Debug.Assert(Delegates.pvxVerifyGraph != null, "pvxVerifyGraph not implemented");
			retValue = Delegates.pvxVerifyGraph(graph);
			LogCommand("vxVerifyGraph", retValue, graph			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int ProcessGraph(IntPtr graph)
		{
			int retValue;

			Debug.Assert(Delegates.pvxProcessGraph != null, "pvxProcessGraph not implemented");
			retValue = Delegates.pvxProcessGraph(graph);
			LogCommand("vxProcessGraph", retValue, graph			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int ScheduleGraph(IntPtr graph)
		{
			int retValue;

			Debug.Assert(Delegates.pvxScheduleGraph != null, "pvxScheduleGraph not implemented");
			retValue = Delegates.pvxScheduleGraph(graph);
			LogCommand("vxScheduleGraph", retValue, graph			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int WaitGraph(IntPtr graph)
		{
			int retValue;

			Debug.Assert(Delegates.pvxWaitGraph != null, "pvxWaitGraph not implemented");
			retValue = Delegates.pvxWaitGraph(graph);
			LogCommand("vxWaitGraph", retValue, graph			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int QueryGraph(IntPtr graph, int attribute, IntPtr ptr, uint size)
		{
			int retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryGraph != null, "pvxQueryGraph not implemented");
					retValue = Delegates.pvxQueryGraph(graph, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryGraph", retValue, graph, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int SetGraphAttribute(IntPtr graph, int attribute, IntPtr ptr, uint size)
		{
			int retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxSetGraphAttribute != null, "pvxSetGraphAttribute not implemented");
					retValue = Delegates.pvxSetGraphAttribute(graph, attribute, ptr.ToPointer(), size);
					LogCommand("vxSetGraphAttribute", retValue, graph, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int AddParameterToGraph(IntPtr graph, IntPtr parameter)
		{
			int retValue;

			Debug.Assert(Delegates.pvxAddParameterToGraph != null, "pvxAddParameterToGraph not implemented");
			retValue = Delegates.pvxAddParameterToGraph(graph, parameter);
			LogCommand("vxAddParameterToGraph", retValue, graph, parameter			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int SetGraphParameterByIndex(IntPtr graph, uint index, IntPtr value)
		{
			int retValue;

			Debug.Assert(Delegates.pvxSetGraphParameterByIndex != null, "pvxSetGraphParameterByIndex not implemented");
			retValue = Delegates.pvxSetGraphParameterByIndex(graph, index, value);
			LogCommand("vxSetGraphParameterByIndex", retValue, graph, index, value			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr GetGraphParameterByIndex(IntPtr graph, uint index)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxGetGraphParameterByIndex != null, "pvxGetGraphParameterByIndex not implemented");
			retValue = Delegates.pvxGetGraphParameterByIndex(graph, index);
			LogCommand("vxGetGraphParameterByIndex", retValue, graph, index			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int IsGraph(IntPtr graph)
		{
			int retValue;

			Debug.Assert(Delegates.pvxIsGraphVerified != null, "pvxIsGraphVerified not implemented");
			retValue = Delegates.pvxIsGraphVerified(graph);
			LogCommand("vxIsGraphVerified", retValue, graph			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr CreateGenericNode(IntPtr graph, IntPtr kernel)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxCreateGenericNode != null, "pvxCreateGenericNode not implemented");
			retValue = Delegates.pvxCreateGenericNode(graph, kernel);
			LogCommand("vxCreateGenericNode", retValue, graph, kernel			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int QueryNode(IntPtr node, int attribute, IntPtr ptr, uint size)
		{
			int retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryNode != null, "pvxQueryNode not implemented");
					retValue = Delegates.pvxQueryNode(node, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryNode", retValue, node, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int SetNodeAttribute(IntPtr node, int attribute, IntPtr ptr, uint size)
		{
			int retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxSetNodeAttribute != null, "pvxSetNodeAttribute not implemented");
					retValue = Delegates.pvxSetNodeAttribute(node, attribute, ptr.ToPointer(), size);
					LogCommand("vxSetNodeAttribute", retValue, node, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int ReleaseNode(IntPtr[] node)
		{
			int retValue;

			unsafe {
				fixed (IntPtr* p_node = node)
				{
					Debug.Assert(Delegates.pvxReleaseNode != null, "pvxReleaseNode not implemented");
					retValue = Delegates.pvxReleaseNode(p_node);
					LogCommand("vxReleaseNode", retValue, node					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int RemoveNode(IntPtr[] node)
		{
			int retValue;

			unsafe {
				fixed (IntPtr* p_node = node)
				{
					Debug.Assert(Delegates.pvxRemoveNode != null, "pvxRemoveNode not implemented");
					retValue = Delegates.pvxRemoveNode(p_node);
					LogCommand("vxRemoveNode", retValue, node					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int AssignNodeCallback(IntPtr node, NodeCompleteCallback callback)
		{
			int retValue;

			Debug.Assert(Delegates.pvxAssignNodeCallback != null, "pvxAssignNodeCallback not implemented");
			retValue = Delegates.pvxAssignNodeCallback(node, callback);
			LogCommand("vxAssignNodeCallback", retValue, node, callback			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static NodeCompleteCallback RetrieveNodeCallback(IntPtr node)
		{
			NodeCompleteCallback retValue;

			Debug.Assert(Delegates.pvxRetrieveNodeCallback != null, "pvxRetrieveNodeCallback not implemented");
			retValue = Delegates.pvxRetrieveNodeCallback(node);
			LogCommand("vxRetrieveNodeCallback", retValue, node			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int SetNodeTarget(IntPtr node, int target_enum, string target_string)
		{
			int retValue;

			Debug.Assert(Delegates.pvxSetNodeTarget != null, "pvxSetNodeTarget not implemented");
			retValue = Delegates.pvxSetNodeTarget(node, target_enum, target_string);
			LogCommand("vxSetNodeTarget", retValue, node, target_enum, target_string			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int ReplicateNode(IntPtr graph, IntPtr first_node, int[] replicate, uint number_of_parameters)
		{
			int retValue;

			unsafe {
				fixed (int* p_replicate = replicate)
				{
					Debug.Assert(Delegates.pvxReplicateNode != null, "pvxReplicateNode not implemented");
					retValue = Delegates.pvxReplicateNode(graph, first_node, p_replicate, number_of_parameters);
					LogCommand("vxReplicateNode", retValue, graph, first_node, replicate, number_of_parameters					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr GetParameterByIndex(IntPtr node, uint index)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxGetParameterByIndex != null, "pvxGetParameterByIndex not implemented");
			retValue = Delegates.pvxGetParameterByIndex(node, index);
			LogCommand("vxGetParameterByIndex", retValue, node, index			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int ReleaseParameter(IntPtr[] param)
		{
			int retValue;

			unsafe {
				fixed (IntPtr* p_param = param)
				{
					Debug.Assert(Delegates.pvxReleaseParameter != null, "pvxReleaseParameter not implemented");
					retValue = Delegates.pvxReleaseParameter(p_param);
					LogCommand("vxReleaseParameter", retValue, param					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int SetParameterByIndex(IntPtr node, uint index, IntPtr value)
		{
			int retValue;

			Debug.Assert(Delegates.pvxSetParameterByIndex != null, "pvxSetParameterByIndex not implemented");
			retValue = Delegates.pvxSetParameterByIndex(node, index, value);
			LogCommand("vxSetParameterByIndex", retValue, node, index, value			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int SetParameterByReference(IntPtr parameter, IntPtr value)
		{
			int retValue;

			Debug.Assert(Delegates.pvxSetParameterByReference != null, "pvxSetParameterByReference not implemented");
			retValue = Delegates.pvxSetParameterByReference(parameter, value);
			LogCommand("vxSetParameterByReference", retValue, parameter, value			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int QueryParameter(IntPtr parameter, int attribute, IntPtr ptr, uint size)
		{
			int retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryParameter != null, "pvxQueryParameter not implemented");
					retValue = Delegates.pvxQueryParameter(parameter, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryParameter", retValue, parameter, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr CreateScalar(IntPtr context, int data_type, IntPtr ptr)
		{
			IntPtr retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxCreateScalar != null, "pvxCreateScalar not implemented");
					retValue = Delegates.pvxCreateScalar(context, data_type, ptr.ToPointer());
					LogCommand("vxCreateScalar", retValue, context, data_type, ptr					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int ReleaseScalar(IntPtr[] scalar)
		{
			int retValue;

			unsafe {
				fixed (IntPtr* p_scalar = scalar)
				{
					Debug.Assert(Delegates.pvxReleaseScalar != null, "pvxReleaseScalar not implemented");
					retValue = Delegates.pvxReleaseScalar(p_scalar);
					LogCommand("vxReleaseScalar", retValue, scalar					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int QueryScalar(IntPtr scalar, int attribute, IntPtr ptr, uint size)
		{
			int retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryScalar != null, "pvxQueryScalar not implemented");
					retValue = Delegates.pvxQueryScalar(scalar, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryScalar", retValue, scalar, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int CopyScalar(IntPtr scalar, IntPtr user_ptr, int usage, int user_mem_type)
		{
			int retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxCopyScalar != null, "pvxCopyScalar not implemented");
					retValue = Delegates.pvxCopyScalar(scalar, user_ptr.ToPointer(), usage, user_mem_type);
					LogCommand("vxCopyScalar", retValue, scalar, user_ptr, usage, user_mem_type					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int QueryReference(IntPtr @ref, int attribute, IntPtr ptr, uint size)
		{
			int retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryReference != null, "pvxQueryReference not implemented");
					retValue = Delegates.pvxQueryReference(@ref, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryReference", retValue, @ref, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int ReleaseReference(IntPtr[] ref_ptr)
		{
			int retValue;

			unsafe {
				fixed (IntPtr* p_ref_ptr = ref_ptr)
				{
					Debug.Assert(Delegates.pvxReleaseReference != null, "pvxReleaseReference not implemented");
					retValue = Delegates.pvxReleaseReference(p_ref_ptr);
					LogCommand("vxReleaseReference", retValue, ref_ptr					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int RetainReference(IntPtr @ref)
		{
			int retValue;

			Debug.Assert(Delegates.pvxRetainReference != null, "pvxRetainReference not implemented");
			retValue = Delegates.pvxRetainReference(@ref);
			LogCommand("vxRetainReference", retValue, @ref			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int SetReferenceName(IntPtr @ref, string name)
		{
			int retValue;

			Debug.Assert(Delegates.pvxSetReferenceName != null, "pvxSetReferenceName not implemented");
			retValue = Delegates.pvxSetReferenceName(@ref, name);
			LogCommand("vxSetReferenceName", retValue, @ref, name			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int QueryDelay(IntPtr delay, int attribute, IntPtr ptr, uint size)
		{
			int retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryDelay != null, "pvxQueryDelay not implemented");
					retValue = Delegates.pvxQueryDelay(delay, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryDelay", retValue, delay, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int ReleaseDelay(IntPtr[] delay)
		{
			int retValue;

			unsafe {
				fixed (IntPtr* p_delay = delay)
				{
					Debug.Assert(Delegates.pvxReleaseDelay != null, "pvxReleaseDelay not implemented");
					retValue = Delegates.pvxReleaseDelay(p_delay);
					LogCommand("vxReleaseDelay", retValue, delay					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr CreateDelay(IntPtr context, IntPtr exemplar, uint num_slots)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxCreateDelay != null, "pvxCreateDelay not implemented");
			retValue = Delegates.pvxCreateDelay(context, exemplar, num_slots);
			LogCommand("vxCreateDelay", retValue, context, exemplar, num_slots			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr GetReferenceFromDelay(IntPtr delay, int index)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxGetReferenceFromDelay != null, "pvxGetReferenceFromDelay not implemented");
			retValue = Delegates.pvxGetReferenceFromDelay(delay, index);
			LogCommand("vxGetReferenceFromDelay", retValue, delay, index			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int AgeDelay(IntPtr delay)
		{
			int retValue;

			Debug.Assert(Delegates.pvxAgeDelay != null, "pvxAgeDelay not implemented");
			retValue = Delegates.pvxAgeDelay(delay);
			LogCommand("vxAgeDelay", retValue, delay			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int RegisterAutoAging(IntPtr graph, IntPtr delay)
		{
			int retValue;

			Debug.Assert(Delegates.pvxRegisterAutoAging != null, "pvxRegisterAutoAging not implemented");
			retValue = Delegates.pvxRegisterAutoAging(graph, delay);
			LogCommand("vxRegisterAutoAging", retValue, graph, delay			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static void AddLogEntry(IntPtr @ref, int status, string message, Int32 vaArgs)
		{
			Debug.Assert(Delegates.pvxAddLogEntry != null, "pvxAddLogEntry not implemented");
			Delegates.pvxAddLogEntry(@ref, status, message, vaArgs);
			LogCommand("vxAddLogEntry", null, @ref, status, message, vaArgs			);
			DebugCheckErrors(null);
		}

		public static void RegisterLogCallback(IntPtr context, LogCallback callback, int reentrant)
		{
			Debug.Assert(Delegates.pvxRegisterLogCallback != null, "pvxRegisterLogCallback not implemented");
			Delegates.pvxRegisterLogCallback(context, callback, reentrant);
			LogCommand("vxRegisterLogCallback", null, context, callback, reentrant			);
			DebugCheckErrors(null);
		}

		public static IntPtr CreateLUT(IntPtr context, int data_type, uint count)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxCreateLUT != null, "pvxCreateLUT not implemented");
			retValue = Delegates.pvxCreateLUT(context, data_type, count);
			LogCommand("vxCreateLUT", retValue, context, data_type, count			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int ReleaseLUT(IntPtr[] lut)
		{
			int retValue;

			unsafe {
				fixed (IntPtr* p_lut = lut)
				{
					Debug.Assert(Delegates.pvxReleaseLUT != null, "pvxReleaseLUT not implemented");
					retValue = Delegates.pvxReleaseLUT(p_lut);
					LogCommand("vxReleaseLUT", retValue, lut					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int QueryLUT(IntPtr lut, int attribute, IntPtr ptr, uint size)
		{
			int retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryLUT != null, "pvxQueryLUT not implemented");
					retValue = Delegates.pvxQueryLUT(lut, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryLUT", retValue, lut, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int CopyLUT(IntPtr lut, IntPtr user_ptr, int usage, int user_mem_type)
		{
			int retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxCopyLUT != null, "pvxCopyLUT not implemented");
					retValue = Delegates.pvxCopyLUT(lut, user_ptr.ToPointer(), usage, user_mem_type);
					LogCommand("vxCopyLUT", retValue, lut, user_ptr, usage, user_mem_type					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int MapLUT(IntPtr lut, UIntPtr[] map_id, IntPtr[] ptr, int usage, int mem_type, uint flags)
		{
			int retValue;

			unsafe {
				fixed (UIntPtr* p_map_id = map_id)
				fixed (IntPtr* p_ptr = ptr)
				{
					Debug.Assert(Delegates.pvxMapLUT != null, "pvxMapLUT not implemented");
					retValue = Delegates.pvxMapLUT(lut, p_map_id, p_ptr, usage, mem_type, flags);
					LogCommand("vxMapLUT", retValue, lut, map_id, ptr, usage, mem_type, flags					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int UnmapLUT(IntPtr lut, UIntPtr map_id)
		{
			int retValue;

			Debug.Assert(Delegates.pvxUnmapLUT != null, "pvxUnmapLUT not implemented");
			retValue = Delegates.pvxUnmapLUT(lut, map_id);
			LogCommand("vxUnmapLUT", retValue, lut, map_id			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr CreateDistribution(IntPtr context, uint numBins, int offset, uint range)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxCreateDistribution != null, "pvxCreateDistribution not implemented");
			retValue = Delegates.pvxCreateDistribution(context, numBins, offset, range);
			LogCommand("vxCreateDistribution", retValue, context, numBins, offset, range			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int ReleaseDistribution(IntPtr[] distribution)
		{
			int retValue;

			unsafe {
				fixed (IntPtr* p_distribution = distribution)
				{
					Debug.Assert(Delegates.pvxReleaseDistribution != null, "pvxReleaseDistribution not implemented");
					retValue = Delegates.pvxReleaseDistribution(p_distribution);
					LogCommand("vxReleaseDistribution", retValue, distribution					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int QueryDistribution(IntPtr distribution, int attribute, IntPtr ptr, uint size)
		{
			int retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryDistribution != null, "pvxQueryDistribution not implemented");
					retValue = Delegates.pvxQueryDistribution(distribution, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryDistribution", retValue, distribution, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int CopyDistribution(IntPtr distribution, IntPtr user_ptr, int usage, int user_mem_type)
		{
			int retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxCopyDistribution != null, "pvxCopyDistribution not implemented");
					retValue = Delegates.pvxCopyDistribution(distribution, user_ptr.ToPointer(), usage, user_mem_type);
					LogCommand("vxCopyDistribution", retValue, distribution, user_ptr, usage, user_mem_type					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int MapDistribution(IntPtr distribution, UIntPtr[] map_id, IntPtr[] ptr, int usage, int mem_type, uint flags)
		{
			int retValue;

			unsafe {
				fixed (UIntPtr* p_map_id = map_id)
				fixed (IntPtr* p_ptr = ptr)
				{
					Debug.Assert(Delegates.pvxMapDistribution != null, "pvxMapDistribution not implemented");
					retValue = Delegates.pvxMapDistribution(distribution, p_map_id, p_ptr, usage, mem_type, flags);
					LogCommand("vxMapDistribution", retValue, distribution, map_id, ptr, usage, mem_type, flags					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int UnmapDistribution(IntPtr distribution, UIntPtr map_id)
		{
			int retValue;

			Debug.Assert(Delegates.pvxUnmapDistribution != null, "pvxUnmapDistribution not implemented");
			retValue = Delegates.pvxUnmapDistribution(distribution, map_id);
			LogCommand("vxUnmapDistribution", retValue, distribution, map_id			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr CreateThreshold(IntPtr c, int thresh_type, int data_type)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxCreateThreshold != null, "pvxCreateThreshold not implemented");
			retValue = Delegates.pvxCreateThreshold(c, thresh_type, data_type);
			LogCommand("vxCreateThreshold", retValue, c, thresh_type, data_type			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int ReleaseThreshold(IntPtr[] thresh)
		{
			int retValue;

			unsafe {
				fixed (IntPtr* p_thresh = thresh)
				{
					Debug.Assert(Delegates.pvxReleaseThreshold != null, "pvxReleaseThreshold not implemented");
					retValue = Delegates.pvxReleaseThreshold(p_thresh);
					LogCommand("vxReleaseThreshold", retValue, thresh					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int SetThresholdAttribute(IntPtr thresh, int attribute, IntPtr ptr, uint size)
		{
			int retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxSetThresholdAttribute != null, "pvxSetThresholdAttribute not implemented");
					retValue = Delegates.pvxSetThresholdAttribute(thresh, attribute, ptr.ToPointer(), size);
					LogCommand("vxSetThresholdAttribute", retValue, thresh, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int QueryThreshold(IntPtr thresh, int attribute, IntPtr ptr, uint size)
		{
			int retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryThreshold != null, "pvxQueryThreshold not implemented");
					retValue = Delegates.pvxQueryThreshold(thresh, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryThreshold", retValue, thresh, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr CreateMatrix(IntPtr c, int data_type, uint columns, uint rows)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxCreateMatrix != null, "pvxCreateMatrix not implemented");
			retValue = Delegates.pvxCreateMatrix(c, data_type, columns, rows);
			LogCommand("vxCreateMatrix", retValue, c, data_type, columns, rows			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int ReleaseMatrix(IntPtr[] mat)
		{
			int retValue;

			unsafe {
				fixed (IntPtr* p_mat = mat)
				{
					Debug.Assert(Delegates.pvxReleaseMatrix != null, "pvxReleaseMatrix not implemented");
					retValue = Delegates.pvxReleaseMatrix(p_mat);
					LogCommand("vxReleaseMatrix", retValue, mat					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int QueryMatrix(IntPtr mat, int attribute, IntPtr ptr, uint size)
		{
			int retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryMatrix != null, "pvxQueryMatrix not implemented");
					retValue = Delegates.pvxQueryMatrix(mat, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryMatrix", retValue, mat, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int CopyMatrix(IntPtr matrix, IntPtr user_ptr, int usage, int user_mem_type)
		{
			int retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxCopyMatrix != null, "pvxCopyMatrix not implemented");
					retValue = Delegates.pvxCopyMatrix(matrix, user_ptr.ToPointer(), usage, user_mem_type);
					LogCommand("vxCopyMatrix", retValue, matrix, user_ptr, usage, user_mem_type					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr CreateMatrixFromPattern(IntPtr context, int pattern, uint columns, uint rows)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxCreateMatrixFromPattern != null, "pvxCreateMatrixFromPattern not implemented");
			retValue = Delegates.pvxCreateMatrixFromPattern(context, pattern, columns, rows);
			LogCommand("vxCreateMatrixFromPattern", retValue, context, pattern, columns, rows			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr CreateConvolution(IntPtr context, uint columns, uint rows)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxCreateConvolution != null, "pvxCreateConvolution not implemented");
			retValue = Delegates.pvxCreateConvolution(context, columns, rows);
			LogCommand("vxCreateConvolution", retValue, context, columns, rows			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int ReleaseConvolution(IntPtr[] conv)
		{
			int retValue;

			unsafe {
				fixed (IntPtr* p_conv = conv)
				{
					Debug.Assert(Delegates.pvxReleaseConvolution != null, "pvxReleaseConvolution not implemented");
					retValue = Delegates.pvxReleaseConvolution(p_conv);
					LogCommand("vxReleaseConvolution", retValue, conv					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int QueryConvolution(IntPtr conv, int attribute, IntPtr ptr, uint size)
		{
			int retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryConvolution != null, "pvxQueryConvolution not implemented");
					retValue = Delegates.pvxQueryConvolution(conv, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryConvolution", retValue, conv, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int SetConvolutionAttribute(IntPtr conv, int attribute, IntPtr ptr, uint size)
		{
			int retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxSetConvolutionAttribute != null, "pvxSetConvolutionAttribute not implemented");
					retValue = Delegates.pvxSetConvolutionAttribute(conv, attribute, ptr.ToPointer(), size);
					LogCommand("vxSetConvolutionAttribute", retValue, conv, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int CopyConvolutionCoefficients(IntPtr conv, IntPtr user_ptr, int usage, int user_mem_type)
		{
			int retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxCopyConvolutionCoefficients != null, "pvxCopyConvolutionCoefficients not implemented");
					retValue = Delegates.pvxCopyConvolutionCoefficients(conv, user_ptr.ToPointer(), usage, user_mem_type);
					LogCommand("vxCopyConvolutionCoefficients", retValue, conv, user_ptr, usage, user_mem_type					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr CreatePyramid(IntPtr context, uint levels, float scale, uint width, uint height, uint format)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxCreatePyramid != null, "pvxCreatePyramid not implemented");
			retValue = Delegates.pvxCreatePyramid(context, levels, scale, width, height, format);
			LogCommand("vxCreatePyramid", retValue, context, levels, scale, width, height, format			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr CreateVirtualPyramid(IntPtr graph, uint levels, float scale, uint width, uint height, uint format)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxCreateVirtualPyramid != null, "pvxCreateVirtualPyramid not implemented");
			retValue = Delegates.pvxCreateVirtualPyramid(graph, levels, scale, width, height, format);
			LogCommand("vxCreateVirtualPyramid", retValue, graph, levels, scale, width, height, format			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int ReleasePyramid(IntPtr[] pyr)
		{
			int retValue;

			unsafe {
				fixed (IntPtr* p_pyr = pyr)
				{
					Debug.Assert(Delegates.pvxReleasePyramid != null, "pvxReleasePyramid not implemented");
					retValue = Delegates.pvxReleasePyramid(p_pyr);
					LogCommand("vxReleasePyramid", retValue, pyr					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int QueryPyramid(IntPtr pyr, int attribute, IntPtr ptr, uint size)
		{
			int retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryPyramid != null, "pvxQueryPyramid not implemented");
					retValue = Delegates.pvxQueryPyramid(pyr, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryPyramid", retValue, pyr, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr GetPyramidLevel(IntPtr pyr, uint index)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxGetPyramidLevel != null, "pvxGetPyramidLevel not implemented");
			retValue = Delegates.pvxGetPyramidLevel(pyr, index);
			LogCommand("vxGetPyramidLevel", retValue, pyr, index			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr CreateRemap(IntPtr context, uint src_width, uint src_height, uint dst_width, uint dst_height)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxCreateRemap != null, "pvxCreateRemap not implemented");
			retValue = Delegates.pvxCreateRemap(context, src_width, src_height, dst_width, dst_height);
			LogCommand("vxCreateRemap", retValue, context, src_width, src_height, dst_width, dst_height			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int ReleaseRemap(IntPtr[] table)
		{
			int retValue;

			unsafe {
				fixed (IntPtr* p_table = table)
				{
					Debug.Assert(Delegates.pvxReleaseRemap != null, "pvxReleaseRemap not implemented");
					retValue = Delegates.pvxReleaseRemap(p_table);
					LogCommand("vxReleaseRemap", retValue, table					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int SetRemapPoint(IntPtr table, uint dst_x, uint dst_y, float src_x, float src_y)
		{
			int retValue;

			Debug.Assert(Delegates.pvxSetRemapPoint != null, "pvxSetRemapPoint not implemented");
			retValue = Delegates.pvxSetRemapPoint(table, dst_x, dst_y, src_x, src_y);
			LogCommand("vxSetRemapPoint", retValue, table, dst_x, dst_y, src_x, src_y			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int GetRemapPoint(IntPtr table, uint dst_x, uint dst_y, [Out] float[] src_x, [Out] float[] src_y)
		{
			int retValue;

			unsafe {
				fixed (float* p_src_x = src_x)
				fixed (float* p_src_y = src_y)
				{
					Debug.Assert(Delegates.pvxGetRemapPoint != null, "pvxGetRemapPoint not implemented");
					retValue = Delegates.pvxGetRemapPoint(table, dst_x, dst_y, p_src_x, p_src_y);
					LogCommand("vxGetRemapPoint", retValue, table, dst_x, dst_y, src_x, src_y					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int QueryRemap(IntPtr table, int attribute, IntPtr ptr, uint size)
		{
			int retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryRemap != null, "pvxQueryRemap not implemented");
					retValue = Delegates.pvxQueryRemap(table, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryRemap", retValue, table, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr CreateArray(IntPtr context, int item_type, uint capacity)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxCreateArray != null, "pvxCreateArray not implemented");
			retValue = Delegates.pvxCreateArray(context, item_type, capacity);
			LogCommand("vxCreateArray", retValue, context, item_type, capacity			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr CreateVirtualArray(IntPtr graph, int item_type, uint capacity)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxCreateVirtualArray != null, "pvxCreateVirtualArray not implemented");
			retValue = Delegates.pvxCreateVirtualArray(graph, item_type, capacity);
			LogCommand("vxCreateVirtualArray", retValue, graph, item_type, capacity			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int ReleaseArray(IntPtr[] arr)
		{
			int retValue;

			unsafe {
				fixed (IntPtr* p_arr = arr)
				{
					Debug.Assert(Delegates.pvxReleaseArray != null, "pvxReleaseArray not implemented");
					retValue = Delegates.pvxReleaseArray(p_arr);
					LogCommand("vxReleaseArray", retValue, arr					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int QueryArray(IntPtr arr, int attribute, IntPtr ptr, uint size)
		{
			int retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryArray != null, "pvxQueryArray not implemented");
					retValue = Delegates.pvxQueryArray(arr, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryArray", retValue, arr, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int AddArrayItems(IntPtr arr, uint count, IntPtr ptr, uint stride)
		{
			int retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxAddArrayItems != null, "pvxAddArrayItems not implemented");
					retValue = Delegates.pvxAddArrayItems(arr, count, ptr.ToPointer(), stride);
					LogCommand("vxAddArrayItems", retValue, arr, count, ptr, stride					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int TruncateArray(IntPtr arr, uint new_num_items)
		{
			int retValue;

			Debug.Assert(Delegates.pvxTruncateArray != null, "pvxTruncateArray not implemented");
			retValue = Delegates.pvxTruncateArray(arr, new_num_items);
			LogCommand("vxTruncateArray", retValue, arr, new_num_items			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int CopyArrayRange(IntPtr array, uint range_start, uint range_end, uint user_stride, IntPtr user_ptr, int usage, int user_mem_type)
		{
			int retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxCopyArrayRange != null, "pvxCopyArrayRange not implemented");
					retValue = Delegates.pvxCopyArrayRange(array, range_start, range_end, user_stride, user_ptr.ToPointer(), usage, user_mem_type);
					LogCommand("vxCopyArrayRange", retValue, array, range_start, range_end, user_stride, user_ptr, usage, user_mem_type					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int MapArrayRange(IntPtr array, uint range_start, uint range_end, UIntPtr[] map_id, uint[] stride, IntPtr[] ptr, int usage, int mem_type, uint flags)
		{
			int retValue;

			unsafe {
				fixed (UIntPtr* p_map_id = map_id)
				fixed (uint* p_stride = stride)
				fixed (IntPtr* p_ptr = ptr)
				{
					Debug.Assert(Delegates.pvxMapArrayRange != null, "pvxMapArrayRange not implemented");
					retValue = Delegates.pvxMapArrayRange(array, range_start, range_end, p_map_id, p_stride, p_ptr, usage, mem_type, flags);
					LogCommand("vxMapArrayRange", retValue, array, range_start, range_end, map_id, stride, ptr, usage, mem_type, flags					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int UnmapArrayRange(IntPtr array, UIntPtr map_id)
		{
			int retValue;

			Debug.Assert(Delegates.pvxUnmapArrayRange != null, "pvxUnmapArrayRange not implemented");
			retValue = Delegates.pvxUnmapArrayRange(array, map_id);
			LogCommand("vxUnmapArrayRange", retValue, array, map_id			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr CreateObjectArray(IntPtr context, IntPtr exemplar, uint count)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxCreateObjectArray != null, "pvxCreateObjectArray not implemented");
			retValue = Delegates.pvxCreateObjectArray(context, exemplar, count);
			LogCommand("vxCreateObjectArray", retValue, context, exemplar, count			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr CreateVirtualObjectArray(IntPtr graph, IntPtr exemplar, uint count)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxCreateVirtualObjectArray != null, "pvxCreateVirtualObjectArray not implemented");
			retValue = Delegates.pvxCreateVirtualObjectArray(graph, exemplar, count);
			LogCommand("vxCreateVirtualObjectArray", retValue, graph, exemplar, count			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr GetObjectArrayItem(IntPtr arr, uint index)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxGetObjectArrayItem != null, "pvxGetObjectArrayItem not implemented");
			retValue = Delegates.pvxGetObjectArrayItem(arr, index);
			LogCommand("vxGetObjectArrayItem", retValue, arr, index			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int ReleaseObjectArray(IntPtr[] arr)
		{
			int retValue;

			unsafe {
				fixed (IntPtr* p_arr = arr)
				{
					Debug.Assert(Delegates.pvxReleaseObjectArray != null, "pvxReleaseObjectArray not implemented");
					retValue = Delegates.pvxReleaseObjectArray(p_arr);
					LogCommand("vxReleaseObjectArray", retValue, arr					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int QueryObjectArray(IntPtr arr, int attribute, IntPtr ptr, uint size)
		{
			int retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryObjectArray != null, "pvxQueryObjectArray not implemented");
					retValue = Delegates.pvxQueryObjectArray(arr, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryObjectArray", retValue, arr, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int SetMetaFormatAttribute(IntPtr meta, int attribute, IntPtr ptr, uint size)
		{
			int retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxSetMetaFormatAttribute != null, "pvxSetMetaFormatAttribute not implemented");
					retValue = Delegates.pvxSetMetaFormatAttribute(meta, attribute, ptr.ToPointer(), size);
					LogCommand("vxSetMetaFormatAttribute", retValue, meta, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int SetMetaFormatFromReference(IntPtr meta, IntPtr exemplar)
		{
			int retValue;

			Debug.Assert(Delegates.pvxSetMetaFormatFromReference != null, "pvxSetMetaFormatFromReference not implemented");
			retValue = Delegates.pvxSetMetaFormatFromReference(meta, exemplar);
			LogCommand("vxSetMetaFormatFromReference", retValue, meta, exemplar			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr ColorConvertNode(IntPtr graph, IntPtr input, IntPtr output)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxColorConvertNode != null, "pvxColorConvertNode not implemented");
			retValue = Delegates.pvxColorConvertNode(graph, input, output);
			LogCommand("vxColorConvertNode", retValue, graph, input, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr ChannelExtractNode(IntPtr graph, IntPtr input, int channel, IntPtr output)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxChannelExtractNode != null, "pvxChannelExtractNode not implemented");
			retValue = Delegates.pvxChannelExtractNode(graph, input, channel, output);
			LogCommand("vxChannelExtractNode", retValue, graph, input, channel, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr ChannelCombineNode(IntPtr graph, IntPtr plane0, IntPtr plane1, IntPtr plane2, IntPtr plane3, IntPtr output)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxChannelCombineNode != null, "pvxChannelCombineNode not implemented");
			retValue = Delegates.pvxChannelCombineNode(graph, plane0, plane1, plane2, plane3, output);
			LogCommand("vxChannelCombineNode", retValue, graph, plane0, plane1, plane2, plane3, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr PhaseNode(IntPtr graph, IntPtr grad_x, IntPtr grad_y, IntPtr orientation)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxPhaseNode != null, "pvxPhaseNode not implemented");
			retValue = Delegates.pvxPhaseNode(graph, grad_x, grad_y, orientation);
			LogCommand("vxPhaseNode", retValue, graph, grad_x, grad_y, orientation			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr Sobel3x3Node(IntPtr graph, IntPtr input, IntPtr output_x, IntPtr output_y)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxSobel3x3Node != null, "pvxSobel3x3Node not implemented");
			retValue = Delegates.pvxSobel3x3Node(graph, input, output_x, output_y);
			LogCommand("vxSobel3x3Node", retValue, graph, input, output_x, output_y			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr MagnitudeNode(IntPtr graph, IntPtr grad_x, IntPtr grad_y, IntPtr mag)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxMagnitudeNode != null, "pvxMagnitudeNode not implemented");
			retValue = Delegates.pvxMagnitudeNode(graph, grad_x, grad_y, mag);
			LogCommand("vxMagnitudeNode", retValue, graph, grad_x, grad_y, mag			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr ScaleImageNode(IntPtr graph, IntPtr src, IntPtr dst, int type)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxScaleImageNode != null, "pvxScaleImageNode not implemented");
			retValue = Delegates.pvxScaleImageNode(graph, src, dst, type);
			LogCommand("vxScaleImageNode", retValue, graph, src, dst, type			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr TableLookupNode(IntPtr graph, IntPtr input, IntPtr lut, IntPtr output)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxTableLookupNode != null, "pvxTableLookupNode not implemented");
			retValue = Delegates.pvxTableLookupNode(graph, input, lut, output);
			LogCommand("vxTableLookupNode", retValue, graph, input, lut, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr HistogramNode(IntPtr graph, IntPtr input, IntPtr distribution)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxHistogramNode != null, "pvxHistogramNode not implemented");
			retValue = Delegates.pvxHistogramNode(graph, input, distribution);
			LogCommand("vxHistogramNode", retValue, graph, input, distribution			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr EqualizeHistNode(IntPtr graph, IntPtr input, IntPtr output)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxEqualizeHistNode != null, "pvxEqualizeHistNode not implemented");
			retValue = Delegates.pvxEqualizeHistNode(graph, input, output);
			LogCommand("vxEqualizeHistNode", retValue, graph, input, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr AbsDiffNode(IntPtr graph, IntPtr in1, IntPtr in2, IntPtr @out)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxAbsDiffNode != null, "pvxAbsDiffNode not implemented");
			retValue = Delegates.pvxAbsDiffNode(graph, in1, in2, @out);
			LogCommand("vxAbsDiffNode", retValue, graph, in1, in2, @out			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr MeanStdDevNode(IntPtr graph, IntPtr input, IntPtr mean, IntPtr stddev)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxMeanStdDevNode != null, "pvxMeanStdDevNode not implemented");
			retValue = Delegates.pvxMeanStdDevNode(graph, input, mean, stddev);
			LogCommand("vxMeanStdDevNode", retValue, graph, input, mean, stddev			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr ThresholdNode(IntPtr graph, IntPtr input, IntPtr thresh, IntPtr output)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxThresholdNode != null, "pvxThresholdNode not implemented");
			retValue = Delegates.pvxThresholdNode(graph, input, thresh, output);
			LogCommand("vxThresholdNode", retValue, graph, input, thresh, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr IntegralImageNode(IntPtr graph, IntPtr input, IntPtr output)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxIntegralImageNode != null, "pvxIntegralImageNode not implemented");
			retValue = Delegates.pvxIntegralImageNode(graph, input, output);
			LogCommand("vxIntegralImageNode", retValue, graph, input, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr Erode3x3Node(IntPtr graph, IntPtr input, IntPtr output)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxErode3x3Node != null, "pvxErode3x3Node not implemented");
			retValue = Delegates.pvxErode3x3Node(graph, input, output);
			LogCommand("vxErode3x3Node", retValue, graph, input, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr Dilate3x3Node(IntPtr graph, IntPtr input, IntPtr output)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxDilate3x3Node != null, "pvxDilate3x3Node not implemented");
			retValue = Delegates.pvxDilate3x3Node(graph, input, output);
			LogCommand("vxDilate3x3Node", retValue, graph, input, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr Median3x3Node(IntPtr graph, IntPtr input, IntPtr output)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxMedian3x3Node != null, "pvxMedian3x3Node not implemented");
			retValue = Delegates.pvxMedian3x3Node(graph, input, output);
			LogCommand("vxMedian3x3Node", retValue, graph, input, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr Box3x3Node(IntPtr graph, IntPtr input, IntPtr output)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxBox3x3Node != null, "pvxBox3x3Node not implemented");
			retValue = Delegates.pvxBox3x3Node(graph, input, output);
			LogCommand("vxBox3x3Node", retValue, graph, input, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr Gaussian3x3Node(IntPtr graph, IntPtr input, IntPtr output)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxGaussian3x3Node != null, "pvxGaussian3x3Node not implemented");
			retValue = Delegates.pvxGaussian3x3Node(graph, input, output);
			LogCommand("vxGaussian3x3Node", retValue, graph, input, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr NonLinearFilterNode(IntPtr graph, int function, IntPtr input, IntPtr mask, IntPtr output)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxNonLinearFilterNode != null, "pvxNonLinearFilterNode not implemented");
			retValue = Delegates.pvxNonLinearFilterNode(graph, function, input, mask, output);
			LogCommand("vxNonLinearFilterNode", retValue, graph, function, input, mask, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr ConvolveNode(IntPtr graph, IntPtr input, IntPtr conv, IntPtr output)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxConvolveNode != null, "pvxConvolveNode not implemented");
			retValue = Delegates.pvxConvolveNode(graph, input, conv, output);
			LogCommand("vxConvolveNode", retValue, graph, input, conv, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr GaussianPyramidNode(IntPtr graph, IntPtr input, IntPtr gaussian)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxGaussianPyramidNode != null, "pvxGaussianPyramidNode not implemented");
			retValue = Delegates.pvxGaussianPyramidNode(graph, input, gaussian);
			LogCommand("vxGaussianPyramidNode", retValue, graph, input, gaussian			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr LaplacianPyramidNode(IntPtr graph, IntPtr input, IntPtr laplacian, IntPtr output)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxLaplacianPyramidNode != null, "pvxLaplacianPyramidNode not implemented");
			retValue = Delegates.pvxLaplacianPyramidNode(graph, input, laplacian, output);
			LogCommand("vxLaplacianPyramidNode", retValue, graph, input, laplacian, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr LaplacianReconstructNode(IntPtr graph, IntPtr laplacian, IntPtr input, IntPtr output)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxLaplacianReconstructNode != null, "pvxLaplacianReconstructNode not implemented");
			retValue = Delegates.pvxLaplacianReconstructNode(graph, laplacian, input, output);
			LogCommand("vxLaplacianReconstructNode", retValue, graph, laplacian, input, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr AccumulateImageNode(IntPtr graph, IntPtr input, IntPtr accum)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxAccumulateImageNode != null, "pvxAccumulateImageNode not implemented");
			retValue = Delegates.pvxAccumulateImageNode(graph, input, accum);
			LogCommand("vxAccumulateImageNode", retValue, graph, input, accum			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr AccumulateWeightedImageNode(IntPtr graph, IntPtr input, IntPtr alpha, IntPtr accum)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxAccumulateWeightedImageNode != null, "pvxAccumulateWeightedImageNode not implemented");
			retValue = Delegates.pvxAccumulateWeightedImageNode(graph, input, alpha, accum);
			LogCommand("vxAccumulateWeightedImageNode", retValue, graph, input, alpha, accum			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr AccumulateSquareImageNode(IntPtr graph, IntPtr input, IntPtr shift, IntPtr accum)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxAccumulateSquareImageNode != null, "pvxAccumulateSquareImageNode not implemented");
			retValue = Delegates.pvxAccumulateSquareImageNode(graph, input, shift, accum);
			LogCommand("vxAccumulateSquareImageNode", retValue, graph, input, shift, accum			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr MinMaxLocNode(IntPtr graph, IntPtr input, IntPtr minVal, IntPtr maxVal, IntPtr minLoc, IntPtr maxLoc, IntPtr minCount, IntPtr maxCount)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxMinMaxLocNode != null, "pvxMinMaxLocNode not implemented");
			retValue = Delegates.pvxMinMaxLocNode(graph, input, minVal, maxVal, minLoc, maxLoc, minCount, maxCount);
			LogCommand("vxMinMaxLocNode", retValue, graph, input, minVal, maxVal, minLoc, maxLoc, minCount, maxCount			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr AndNode(IntPtr graph, IntPtr in1, IntPtr in2, IntPtr @out)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxAndNode != null, "pvxAndNode not implemented");
			retValue = Delegates.pvxAndNode(graph, in1, in2, @out);
			LogCommand("vxAndNode", retValue, graph, in1, in2, @out			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr OrNode(IntPtr graph, IntPtr in1, IntPtr in2, IntPtr @out)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxOrNode != null, "pvxOrNode not implemented");
			retValue = Delegates.pvxOrNode(graph, in1, in2, @out);
			LogCommand("vxOrNode", retValue, graph, in1, in2, @out			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr XorNode(IntPtr graph, IntPtr in1, IntPtr in2, IntPtr @out)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxXorNode != null, "pvxXorNode not implemented");
			retValue = Delegates.pvxXorNode(graph, in1, in2, @out);
			LogCommand("vxXorNode", retValue, graph, in1, in2, @out			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr NotNode(IntPtr graph, IntPtr input, IntPtr output)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxNotNode != null, "pvxNotNode not implemented");
			retValue = Delegates.pvxNotNode(graph, input, output);
			LogCommand("vxNotNode", retValue, graph, input, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr MultiplyNode(IntPtr graph, IntPtr in1, IntPtr in2, IntPtr scale, int overflow_policy, int rounding_policy, IntPtr @out)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxMultiplyNode != null, "pvxMultiplyNode not implemented");
			retValue = Delegates.pvxMultiplyNode(graph, in1, in2, scale, overflow_policy, rounding_policy, @out);
			LogCommand("vxMultiplyNode", retValue, graph, in1, in2, scale, overflow_policy, rounding_policy, @out			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr AddNode(IntPtr graph, IntPtr in1, IntPtr in2, int policy, IntPtr @out)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxAddNode != null, "pvxAddNode not implemented");
			retValue = Delegates.pvxAddNode(graph, in1, in2, policy, @out);
			LogCommand("vxAddNode", retValue, graph, in1, in2, policy, @out			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr SubtractNode(IntPtr graph, IntPtr in1, IntPtr in2, int policy, IntPtr @out)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxSubtractNode != null, "pvxSubtractNode not implemented");
			retValue = Delegates.pvxSubtractNode(graph, in1, in2, policy, @out);
			LogCommand("vxSubtractNode", retValue, graph, in1, in2, policy, @out			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr ConvertDepthNode(IntPtr graph, IntPtr input, IntPtr output, int policy, IntPtr shift)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxConvertDepthNode != null, "pvxConvertDepthNode not implemented");
			retValue = Delegates.pvxConvertDepthNode(graph, input, output, policy, shift);
			LogCommand("vxConvertDepthNode", retValue, graph, input, output, policy, shift			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr CannyEdgeDetectorNode(IntPtr graph, IntPtr input, IntPtr hyst, int gradient_size, int norm_type, IntPtr output)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxCannyEdgeDetectorNode != null, "pvxCannyEdgeDetectorNode not implemented");
			retValue = Delegates.pvxCannyEdgeDetectorNode(graph, input, hyst, gradient_size, norm_type, output);
			LogCommand("vxCannyEdgeDetectorNode", retValue, graph, input, hyst, gradient_size, norm_type, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr WarpAffineNode(IntPtr graph, IntPtr input, IntPtr matrix, int type, IntPtr output)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxWarpAffineNode != null, "pvxWarpAffineNode not implemented");
			retValue = Delegates.pvxWarpAffineNode(graph, input, matrix, type, output);
			LogCommand("vxWarpAffineNode", retValue, graph, input, matrix, type, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr WarpPerspectiveNode(IntPtr graph, IntPtr input, IntPtr matrix, int type, IntPtr output)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxWarpPerspectiveNode != null, "pvxWarpPerspectiveNode not implemented");
			retValue = Delegates.pvxWarpPerspectiveNode(graph, input, matrix, type, output);
			LogCommand("vxWarpPerspectiveNode", retValue, graph, input, matrix, type, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr HarrisCornersNode(IntPtr graph, IntPtr input, IntPtr strength_thresh, IntPtr min_distance, IntPtr sensitivity, int gradient_size, int block_size, IntPtr corners, IntPtr num_corners)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxHarrisCornersNode != null, "pvxHarrisCornersNode not implemented");
			retValue = Delegates.pvxHarrisCornersNode(graph, input, strength_thresh, min_distance, sensitivity, gradient_size, block_size, corners, num_corners);
			LogCommand("vxHarrisCornersNode", retValue, graph, input, strength_thresh, min_distance, sensitivity, gradient_size, block_size, corners, num_corners			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr FastCornersNode(IntPtr graph, IntPtr input, IntPtr strength_thresh, int nonmax_suppression, IntPtr corners, IntPtr num_corners)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxFastCornersNode != null, "pvxFastCornersNode not implemented");
			retValue = Delegates.pvxFastCornersNode(graph, input, strength_thresh, nonmax_suppression, corners, num_corners);
			LogCommand("vxFastCornersNode", retValue, graph, input, strength_thresh, nonmax_suppression, corners, num_corners			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr OpticalFlowPyrLKNode(IntPtr graph, IntPtr old_images, IntPtr new_images, IntPtr old_points, IntPtr new_points_estimates, IntPtr new_points, int termination, IntPtr epsilon, IntPtr num_iterations, IntPtr use_initial_estimate, uint window_dimension)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxOpticalFlowPyrLKNode != null, "pvxOpticalFlowPyrLKNode not implemented");
			retValue = Delegates.pvxOpticalFlowPyrLKNode(graph, old_images, new_images, old_points, new_points_estimates, new_points, termination, epsilon, num_iterations, use_initial_estimate, window_dimension);
			LogCommand("vxOpticalFlowPyrLKNode", retValue, graph, old_images, new_images, old_points, new_points_estimates, new_points, termination, epsilon, num_iterations, use_initial_estimate, window_dimension			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr RemapNode(IntPtr graph, IntPtr input, IntPtr table, int policy, IntPtr output)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxRemapNode != null, "pvxRemapNode not implemented");
			retValue = Delegates.pvxRemapNode(graph, input, table, policy, output);
			LogCommand("vxRemapNode", retValue, graph, input, table, policy, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr HalfScaleGaussianNode(IntPtr graph, IntPtr input, IntPtr output, int kernel_size)
		{
			IntPtr retValue;

			Debug.Assert(Delegates.pvxHalfScaleGaussianNode != null, "pvxHalfScaleGaussianNode not implemented");
			retValue = Delegates.pvxHalfScaleGaussianNode(graph, input, output, kernel_size);
			LogCommand("vxHalfScaleGaussianNode", retValue, graph, input, output, kernel_size			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		internal unsafe static partial class Delegates
		{
			[SuppressUnmanagedCodeSecurity()]
			internal delegate IntPtr vxCreateContext();

			internal static vxCreateContext pvxCreateContext;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxReleaseContext(IntPtr* context);

			internal static vxReleaseContext pvxReleaseContext;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxGetContext(IntPtr reference);

			internal static vxGetContext pvxGetContext;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxQueryContext(IntPtr context, int attribute, void* ptr, uint size);

			internal static vxQueryContext pvxQueryContext;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxSetContextAttribute(IntPtr context, int attribute, void* ptr, uint size);

			internal static vxSetContextAttribute pvxSetContextAttribute;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxHint(IntPtr reference, int hint, void* data, uint data_size);

			internal static vxHint pvxHint;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxDirective(IntPtr reference, int directive);

			internal static vxDirective pvxDirective;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxGetStatus(IntPtr reference);

			internal static vxGetStatus pvxGetStatus;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxRegisterUserStruct(IntPtr context, uint size);

			internal static vxRegisterUserStruct pvxRegisterUserStruct;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxAllocateUserKernelId(IntPtr context, int* pKernelEnumId);

			internal static vxAllocateUserKernelId pvxAllocateUserKernelId;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxAllocateUserKernelLibraryId(IntPtr context, int* pLibraryId);

			internal static vxAllocateUserKernelLibraryId pvxAllocateUserKernelLibraryId;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxSetImmediateModeTarget(IntPtr context, int target_enum, string target_string);

			internal static vxSetImmediateModeTarget pvxSetImmediateModeTarget;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxCreateImage(IntPtr context, uint width, uint height, uint color);

			internal static vxCreateImage pvxCreateImage;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxCreateImageFromROI(IntPtr img, Rectangle* rect);

			internal static vxCreateImageFromROI pvxCreateImageFromROI;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxCreateUniformImage(IntPtr context, uint width, uint height, uint color, PixelValue value);

			internal static vxCreateUniformImage pvxCreateUniformImage;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxCreateVirtualImage(IntPtr graph, uint width, uint height, uint color);

			internal static vxCreateVirtualImage pvxCreateVirtualImage;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxCreateImageFromHandle(IntPtr context, uint color, ImagePatchAddressing* addrs, IntPtr* ptrs, int memory_type);

			internal static vxCreateImageFromHandle pvxCreateImageFromHandle;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxSwapImageHandle(IntPtr image, IntPtr* new_ptrs, IntPtr* prev_ptrs, uint num_planes);

			internal static vxSwapImageHandle pvxSwapImageHandle;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxQueryImage(IntPtr image, int attribute, void* ptr, uint size);

			internal static vxQueryImage pvxQueryImage;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxSetImageAttribute(IntPtr image, int attribute, void* ptr, uint size);

			internal static vxSetImageAttribute pvxSetImageAttribute;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxReleaseImage(IntPtr* image);

			internal static vxReleaseImage pvxReleaseImage;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate uint vxComputeImagePatchSize(IntPtr image, Rectangle* rect, uint plane_index);

			internal static vxComputeImagePatchSize pvxComputeImagePatchSize;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxFormatImagePatchAddress1d(void* ptr, uint index, ImagePatchAddressing* addr);

			internal static vxFormatImagePatchAddress1d pvxFormatImagePatchAddress1d;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxFormatImagePatchAddress2d(void* ptr, uint x, uint y, ImagePatchAddressing* addr);

			internal static vxFormatImagePatchAddress2d pvxFormatImagePatchAddress2d;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxGetValidRegionImage(IntPtr image, Rectangle* rect);

			internal static vxGetValidRegionImage pvxGetValidRegionImage;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxCopyImagePatch(IntPtr image, Rectangle* image_rect, uint image_plane_index, ImagePatchAddressing* user_addr, void* user_ptr, int usage, int user_mem_type);

			internal static vxCopyImagePatch pvxCopyImagePatch;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxMapImagePatch(IntPtr image, Rectangle* rect, uint plane_index, UIntPtr* map_id, ImagePatchAddressing* addr, IntPtr* ptr, int usage, int mem_type, uint flags);

			internal static vxMapImagePatch pvxMapImagePatch;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxUnmapImagePatch(IntPtr image, UIntPtr map_id);

			internal static vxUnmapImagePatch pvxUnmapImagePatch;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxCreateImageFromChannel(IntPtr img, int channel);

			internal static vxCreateImageFromChannel pvxCreateImageFromChannel;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxSetImageValidRectangle(IntPtr image, Rectangle* rect);

			internal static vxSetImageValidRectangle pvxSetImageValidRectangle;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxLoadKernels(IntPtr context, string module);

			internal static vxLoadKernels pvxLoadKernels;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxUnloadKernels(IntPtr context, string module);

			internal static vxUnloadKernels pvxUnloadKernels;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxGetKernelByName(IntPtr context, string name);

			internal static vxGetKernelByName pvxGetKernelByName;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxGetKernelByEnum(IntPtr context, int kernel);

			internal static vxGetKernelByEnum pvxGetKernelByEnum;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxQueryKernel(IntPtr kernel, int attribute, void* ptr, uint size);

			internal static vxQueryKernel pvxQueryKernel;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxReleaseKernel(IntPtr* kernel);

			internal static vxReleaseKernel pvxReleaseKernel;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxAddUserKernel(IntPtr context, string name, int enumeration, KernelCallback func_ptr, uint numParams, KernelValidateCallbackCallback validate, KernelInitializeCallback init, KernelDeinitializeCallback deinit);

			internal static vxAddUserKernel pvxAddUserKernel;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxFinalizeKernel(IntPtr kernel);

			internal static vxFinalizeKernel pvxFinalizeKernel;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxAddParameterToKernel(IntPtr kernel, uint index, int dir, int data_type, int state);

			internal static vxAddParameterToKernel pvxAddParameterToKernel;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxRemoveKernel(IntPtr kernel);

			internal static vxRemoveKernel pvxRemoveKernel;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxSetKernelAttribute(IntPtr kernel, int attribute, void* ptr, uint size);

			internal static vxSetKernelAttribute pvxSetKernelAttribute;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxGetKernelParameterByIndex(IntPtr kernel, uint index);

			internal static vxGetKernelParameterByIndex pvxGetKernelParameterByIndex;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxCreateGraph(IntPtr context);

			internal static vxCreateGraph pvxCreateGraph;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxReleaseGraph(IntPtr* graph);

			internal static vxReleaseGraph pvxReleaseGraph;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxVerifyGraph(IntPtr graph);

			internal static vxVerifyGraph pvxVerifyGraph;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxProcessGraph(IntPtr graph);

			internal static vxProcessGraph pvxProcessGraph;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxScheduleGraph(IntPtr graph);

			internal static vxScheduleGraph pvxScheduleGraph;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxWaitGraph(IntPtr graph);

			internal static vxWaitGraph pvxWaitGraph;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxQueryGraph(IntPtr graph, int attribute, void* ptr, uint size);

			internal static vxQueryGraph pvxQueryGraph;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxSetGraphAttribute(IntPtr graph, int attribute, void* ptr, uint size);

			internal static vxSetGraphAttribute pvxSetGraphAttribute;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxAddParameterToGraph(IntPtr graph, IntPtr parameter);

			internal static vxAddParameterToGraph pvxAddParameterToGraph;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxSetGraphParameterByIndex(IntPtr graph, uint index, IntPtr value);

			internal static vxSetGraphParameterByIndex pvxSetGraphParameterByIndex;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxGetGraphParameterByIndex(IntPtr graph, uint index);

			internal static vxGetGraphParameterByIndex pvxGetGraphParameterByIndex;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxIsGraphVerified(IntPtr graph);

			internal static vxIsGraphVerified pvxIsGraphVerified;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxCreateGenericNode(IntPtr graph, IntPtr kernel);

			internal static vxCreateGenericNode pvxCreateGenericNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxQueryNode(IntPtr node, int attribute, void* ptr, uint size);

			internal static vxQueryNode pvxQueryNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxSetNodeAttribute(IntPtr node, int attribute, void* ptr, uint size);

			internal static vxSetNodeAttribute pvxSetNodeAttribute;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxReleaseNode(IntPtr* node);

			internal static vxReleaseNode pvxReleaseNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxRemoveNode(IntPtr* node);

			internal static vxRemoveNode pvxRemoveNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxAssignNodeCallback(IntPtr node, NodeCompleteCallback callback);

			internal static vxAssignNodeCallback pvxAssignNodeCallback;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate NodeCompleteCallback vxRetrieveNodeCallback(IntPtr node);

			internal static vxRetrieveNodeCallback pvxRetrieveNodeCallback;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxSetNodeTarget(IntPtr node, int target_enum, string target_string);

			internal static vxSetNodeTarget pvxSetNodeTarget;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxReplicateNode(IntPtr graph, IntPtr first_node, int* replicate, uint number_of_parameters);

			internal static vxReplicateNode pvxReplicateNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxGetParameterByIndex(IntPtr node, uint index);

			internal static vxGetParameterByIndex pvxGetParameterByIndex;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxReleaseParameter(IntPtr* param);

			internal static vxReleaseParameter pvxReleaseParameter;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxSetParameterByIndex(IntPtr node, uint index, IntPtr value);

			internal static vxSetParameterByIndex pvxSetParameterByIndex;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxSetParameterByReference(IntPtr parameter, IntPtr value);

			internal static vxSetParameterByReference pvxSetParameterByReference;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxQueryParameter(IntPtr parameter, int attribute, void* ptr, uint size);

			internal static vxQueryParameter pvxQueryParameter;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxCreateScalar(IntPtr context, int data_type, void* ptr);

			internal static vxCreateScalar pvxCreateScalar;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxReleaseScalar(IntPtr* scalar);

			internal static vxReleaseScalar pvxReleaseScalar;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxQueryScalar(IntPtr scalar, int attribute, void* ptr, uint size);

			internal static vxQueryScalar pvxQueryScalar;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxCopyScalar(IntPtr scalar, void* user_ptr, int usage, int user_mem_type);

			internal static vxCopyScalar pvxCopyScalar;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxQueryReference(IntPtr @ref, int attribute, void* ptr, uint size);

			internal static vxQueryReference pvxQueryReference;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxReleaseReference(IntPtr* ref_ptr);

			internal static vxReleaseReference pvxReleaseReference;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxRetainReference(IntPtr @ref);

			internal static vxRetainReference pvxRetainReference;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxSetReferenceName(IntPtr @ref, string name);

			internal static vxSetReferenceName pvxSetReferenceName;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxQueryDelay(IntPtr delay, int attribute, void* ptr, uint size);

			internal static vxQueryDelay pvxQueryDelay;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxReleaseDelay(IntPtr* delay);

			internal static vxReleaseDelay pvxReleaseDelay;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxCreateDelay(IntPtr context, IntPtr exemplar, uint num_slots);

			internal static vxCreateDelay pvxCreateDelay;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxGetReferenceFromDelay(IntPtr delay, int index);

			internal static vxGetReferenceFromDelay pvxGetReferenceFromDelay;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxAgeDelay(IntPtr delay);

			internal static vxAgeDelay pvxAgeDelay;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxRegisterAutoAging(IntPtr graph, IntPtr delay);

			internal static vxRegisterAutoAging pvxRegisterAutoAging;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate void vxAddLogEntry(IntPtr @ref, int status, string message, Int32 vaArgs);

			internal static vxAddLogEntry pvxAddLogEntry;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate void vxRegisterLogCallback(IntPtr context, LogCallback callback, int reentrant);

			internal static vxRegisterLogCallback pvxRegisterLogCallback;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxCreateLUT(IntPtr context, int data_type, uint count);

			internal static vxCreateLUT pvxCreateLUT;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxReleaseLUT(IntPtr* lut);

			internal static vxReleaseLUT pvxReleaseLUT;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxQueryLUT(IntPtr lut, int attribute, void* ptr, uint size);

			internal static vxQueryLUT pvxQueryLUT;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxCopyLUT(IntPtr lut, void* user_ptr, int usage, int user_mem_type);

			internal static vxCopyLUT pvxCopyLUT;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxMapLUT(IntPtr lut, UIntPtr* map_id, IntPtr* ptr, int usage, int mem_type, uint flags);

			internal static vxMapLUT pvxMapLUT;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxUnmapLUT(IntPtr lut, UIntPtr map_id);

			internal static vxUnmapLUT pvxUnmapLUT;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxCreateDistribution(IntPtr context, uint numBins, int offset, uint range);

			internal static vxCreateDistribution pvxCreateDistribution;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxReleaseDistribution(IntPtr* distribution);

			internal static vxReleaseDistribution pvxReleaseDistribution;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxQueryDistribution(IntPtr distribution, int attribute, void* ptr, uint size);

			internal static vxQueryDistribution pvxQueryDistribution;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxCopyDistribution(IntPtr distribution, void* user_ptr, int usage, int user_mem_type);

			internal static vxCopyDistribution pvxCopyDistribution;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxMapDistribution(IntPtr distribution, UIntPtr* map_id, IntPtr* ptr, int usage, int mem_type, uint flags);

			internal static vxMapDistribution pvxMapDistribution;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxUnmapDistribution(IntPtr distribution, UIntPtr map_id);

			internal static vxUnmapDistribution pvxUnmapDistribution;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxCreateThreshold(IntPtr c, int thresh_type, int data_type);

			internal static vxCreateThreshold pvxCreateThreshold;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxReleaseThreshold(IntPtr* thresh);

			internal static vxReleaseThreshold pvxReleaseThreshold;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxSetThresholdAttribute(IntPtr thresh, int attribute, void* ptr, uint size);

			internal static vxSetThresholdAttribute pvxSetThresholdAttribute;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxQueryThreshold(IntPtr thresh, int attribute, void* ptr, uint size);

			internal static vxQueryThreshold pvxQueryThreshold;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxCreateMatrix(IntPtr c, int data_type, uint columns, uint rows);

			internal static vxCreateMatrix pvxCreateMatrix;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxReleaseMatrix(IntPtr* mat);

			internal static vxReleaseMatrix pvxReleaseMatrix;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxQueryMatrix(IntPtr mat, int attribute, void* ptr, uint size);

			internal static vxQueryMatrix pvxQueryMatrix;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxCopyMatrix(IntPtr matrix, void* user_ptr, int usage, int user_mem_type);

			internal static vxCopyMatrix pvxCopyMatrix;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxCreateMatrixFromPattern(IntPtr context, int pattern, uint columns, uint rows);

			internal static vxCreateMatrixFromPattern pvxCreateMatrixFromPattern;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxCreateConvolution(IntPtr context, uint columns, uint rows);

			internal static vxCreateConvolution pvxCreateConvolution;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxReleaseConvolution(IntPtr* conv);

			internal static vxReleaseConvolution pvxReleaseConvolution;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxQueryConvolution(IntPtr conv, int attribute, void* ptr, uint size);

			internal static vxQueryConvolution pvxQueryConvolution;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxSetConvolutionAttribute(IntPtr conv, int attribute, void* ptr, uint size);

			internal static vxSetConvolutionAttribute pvxSetConvolutionAttribute;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxCopyConvolutionCoefficients(IntPtr conv, void* user_ptr, int usage, int user_mem_type);

			internal static vxCopyConvolutionCoefficients pvxCopyConvolutionCoefficients;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxCreatePyramid(IntPtr context, uint levels, float scale, uint width, uint height, uint format);

			internal static vxCreatePyramid pvxCreatePyramid;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxCreateVirtualPyramid(IntPtr graph, uint levels, float scale, uint width, uint height, uint format);

			internal static vxCreateVirtualPyramid pvxCreateVirtualPyramid;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxReleasePyramid(IntPtr* pyr);

			internal static vxReleasePyramid pvxReleasePyramid;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxQueryPyramid(IntPtr pyr, int attribute, void* ptr, uint size);

			internal static vxQueryPyramid pvxQueryPyramid;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxGetPyramidLevel(IntPtr pyr, uint index);

			internal static vxGetPyramidLevel pvxGetPyramidLevel;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxCreateRemap(IntPtr context, uint src_width, uint src_height, uint dst_width, uint dst_height);

			internal static vxCreateRemap pvxCreateRemap;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxReleaseRemap(IntPtr* table);

			internal static vxReleaseRemap pvxReleaseRemap;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxSetRemapPoint(IntPtr table, uint dst_x, uint dst_y, float src_x, float src_y);

			internal static vxSetRemapPoint pvxSetRemapPoint;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxGetRemapPoint(IntPtr table, uint dst_x, uint dst_y, float* src_x, float* src_y);

			internal static vxGetRemapPoint pvxGetRemapPoint;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxQueryRemap(IntPtr table, int attribute, void* ptr, uint size);

			internal static vxQueryRemap pvxQueryRemap;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxCreateArray(IntPtr context, int item_type, uint capacity);

			internal static vxCreateArray pvxCreateArray;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxCreateVirtualArray(IntPtr graph, int item_type, uint capacity);

			internal static vxCreateVirtualArray pvxCreateVirtualArray;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxReleaseArray(IntPtr* arr);

			internal static vxReleaseArray pvxReleaseArray;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxQueryArray(IntPtr arr, int attribute, void* ptr, uint size);

			internal static vxQueryArray pvxQueryArray;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxAddArrayItems(IntPtr arr, uint count, void* ptr, uint stride);

			internal static vxAddArrayItems pvxAddArrayItems;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxTruncateArray(IntPtr arr, uint new_num_items);

			internal static vxTruncateArray pvxTruncateArray;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxCopyArrayRange(IntPtr array, uint range_start, uint range_end, uint user_stride, void* user_ptr, int usage, int user_mem_type);

			internal static vxCopyArrayRange pvxCopyArrayRange;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxMapArrayRange(IntPtr array, uint range_start, uint range_end, UIntPtr* map_id, uint* stride, IntPtr* ptr, int usage, int mem_type, uint flags);

			internal static vxMapArrayRange pvxMapArrayRange;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxUnmapArrayRange(IntPtr array, UIntPtr map_id);

			internal static vxUnmapArrayRange pvxUnmapArrayRange;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxCreateObjectArray(IntPtr context, IntPtr exemplar, uint count);

			internal static vxCreateObjectArray pvxCreateObjectArray;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxCreateVirtualObjectArray(IntPtr graph, IntPtr exemplar, uint count);

			internal static vxCreateVirtualObjectArray pvxCreateVirtualObjectArray;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxGetObjectArrayItem(IntPtr arr, uint index);

			internal static vxGetObjectArrayItem pvxGetObjectArrayItem;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxReleaseObjectArray(IntPtr* arr);

			internal static vxReleaseObjectArray pvxReleaseObjectArray;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxQueryObjectArray(IntPtr arr, int attribute, void* ptr, uint size);

			internal static vxQueryObjectArray pvxQueryObjectArray;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxSetMetaFormatAttribute(IntPtr meta, int attribute, void* ptr, uint size);

			internal static vxSetMetaFormatAttribute pvxSetMetaFormatAttribute;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate int vxSetMetaFormatFromReference(IntPtr meta, IntPtr exemplar);

			internal static vxSetMetaFormatFromReference pvxSetMetaFormatFromReference;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxColorConvertNode(IntPtr graph, IntPtr input, IntPtr output);

			internal static vxColorConvertNode pvxColorConvertNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxChannelExtractNode(IntPtr graph, IntPtr input, int channel, IntPtr output);

			internal static vxChannelExtractNode pvxChannelExtractNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxChannelCombineNode(IntPtr graph, IntPtr plane0, IntPtr plane1, IntPtr plane2, IntPtr plane3, IntPtr output);

			internal static vxChannelCombineNode pvxChannelCombineNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxPhaseNode(IntPtr graph, IntPtr grad_x, IntPtr grad_y, IntPtr orientation);

			internal static vxPhaseNode pvxPhaseNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxSobel3x3Node(IntPtr graph, IntPtr input, IntPtr output_x, IntPtr output_y);

			internal static vxSobel3x3Node pvxSobel3x3Node;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxMagnitudeNode(IntPtr graph, IntPtr grad_x, IntPtr grad_y, IntPtr mag);

			internal static vxMagnitudeNode pvxMagnitudeNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxScaleImageNode(IntPtr graph, IntPtr src, IntPtr dst, int type);

			internal static vxScaleImageNode pvxScaleImageNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxTableLookupNode(IntPtr graph, IntPtr input, IntPtr lut, IntPtr output);

			internal static vxTableLookupNode pvxTableLookupNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxHistogramNode(IntPtr graph, IntPtr input, IntPtr distribution);

			internal static vxHistogramNode pvxHistogramNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxEqualizeHistNode(IntPtr graph, IntPtr input, IntPtr output);

			internal static vxEqualizeHistNode pvxEqualizeHistNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxAbsDiffNode(IntPtr graph, IntPtr in1, IntPtr in2, IntPtr @out);

			internal static vxAbsDiffNode pvxAbsDiffNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxMeanStdDevNode(IntPtr graph, IntPtr input, IntPtr mean, IntPtr stddev);

			internal static vxMeanStdDevNode pvxMeanStdDevNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxThresholdNode(IntPtr graph, IntPtr input, IntPtr thresh, IntPtr output);

			internal static vxThresholdNode pvxThresholdNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxIntegralImageNode(IntPtr graph, IntPtr input, IntPtr output);

			internal static vxIntegralImageNode pvxIntegralImageNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxErode3x3Node(IntPtr graph, IntPtr input, IntPtr output);

			internal static vxErode3x3Node pvxErode3x3Node;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxDilate3x3Node(IntPtr graph, IntPtr input, IntPtr output);

			internal static vxDilate3x3Node pvxDilate3x3Node;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxMedian3x3Node(IntPtr graph, IntPtr input, IntPtr output);

			internal static vxMedian3x3Node pvxMedian3x3Node;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxBox3x3Node(IntPtr graph, IntPtr input, IntPtr output);

			internal static vxBox3x3Node pvxBox3x3Node;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxGaussian3x3Node(IntPtr graph, IntPtr input, IntPtr output);

			internal static vxGaussian3x3Node pvxGaussian3x3Node;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxNonLinearFilterNode(IntPtr graph, int function, IntPtr input, IntPtr mask, IntPtr output);

			internal static vxNonLinearFilterNode pvxNonLinearFilterNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxConvolveNode(IntPtr graph, IntPtr input, IntPtr conv, IntPtr output);

			internal static vxConvolveNode pvxConvolveNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxGaussianPyramidNode(IntPtr graph, IntPtr input, IntPtr gaussian);

			internal static vxGaussianPyramidNode pvxGaussianPyramidNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxLaplacianPyramidNode(IntPtr graph, IntPtr input, IntPtr laplacian, IntPtr output);

			internal static vxLaplacianPyramidNode pvxLaplacianPyramidNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxLaplacianReconstructNode(IntPtr graph, IntPtr laplacian, IntPtr input, IntPtr output);

			internal static vxLaplacianReconstructNode pvxLaplacianReconstructNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxAccumulateImageNode(IntPtr graph, IntPtr input, IntPtr accum);

			internal static vxAccumulateImageNode pvxAccumulateImageNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxAccumulateWeightedImageNode(IntPtr graph, IntPtr input, IntPtr alpha, IntPtr accum);

			internal static vxAccumulateWeightedImageNode pvxAccumulateWeightedImageNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxAccumulateSquareImageNode(IntPtr graph, IntPtr input, IntPtr shift, IntPtr accum);

			internal static vxAccumulateSquareImageNode pvxAccumulateSquareImageNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxMinMaxLocNode(IntPtr graph, IntPtr input, IntPtr minVal, IntPtr maxVal, IntPtr minLoc, IntPtr maxLoc, IntPtr minCount, IntPtr maxCount);

			internal static vxMinMaxLocNode pvxMinMaxLocNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxAndNode(IntPtr graph, IntPtr in1, IntPtr in2, IntPtr @out);

			internal static vxAndNode pvxAndNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxOrNode(IntPtr graph, IntPtr in1, IntPtr in2, IntPtr @out);

			internal static vxOrNode pvxOrNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxXorNode(IntPtr graph, IntPtr in1, IntPtr in2, IntPtr @out);

			internal static vxXorNode pvxXorNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxNotNode(IntPtr graph, IntPtr input, IntPtr output);

			internal static vxNotNode pvxNotNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxMultiplyNode(IntPtr graph, IntPtr in1, IntPtr in2, IntPtr scale, int overflow_policy, int rounding_policy, IntPtr @out);

			internal static vxMultiplyNode pvxMultiplyNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxAddNode(IntPtr graph, IntPtr in1, IntPtr in2, int policy, IntPtr @out);

			internal static vxAddNode pvxAddNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxSubtractNode(IntPtr graph, IntPtr in1, IntPtr in2, int policy, IntPtr @out);

			internal static vxSubtractNode pvxSubtractNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxConvertDepthNode(IntPtr graph, IntPtr input, IntPtr output, int policy, IntPtr shift);

			internal static vxConvertDepthNode pvxConvertDepthNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxCannyEdgeDetectorNode(IntPtr graph, IntPtr input, IntPtr hyst, int gradient_size, int norm_type, IntPtr output);

			internal static vxCannyEdgeDetectorNode pvxCannyEdgeDetectorNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxWarpAffineNode(IntPtr graph, IntPtr input, IntPtr matrix, int type, IntPtr output);

			internal static vxWarpAffineNode pvxWarpAffineNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxWarpPerspectiveNode(IntPtr graph, IntPtr input, IntPtr matrix, int type, IntPtr output);

			internal static vxWarpPerspectiveNode pvxWarpPerspectiveNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxHarrisCornersNode(IntPtr graph, IntPtr input, IntPtr strength_thresh, IntPtr min_distance, IntPtr sensitivity, int gradient_size, int block_size, IntPtr corners, IntPtr num_corners);

			internal static vxHarrisCornersNode pvxHarrisCornersNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxFastCornersNode(IntPtr graph, IntPtr input, IntPtr strength_thresh, int nonmax_suppression, IntPtr corners, IntPtr num_corners);

			internal static vxFastCornersNode pvxFastCornersNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxOpticalFlowPyrLKNode(IntPtr graph, IntPtr old_images, IntPtr new_images, IntPtr old_points, IntPtr new_points_estimates, IntPtr new_points, int termination, IntPtr epsilon, IntPtr num_iterations, IntPtr use_initial_estimate, uint window_dimension);

			internal static vxOpticalFlowPyrLKNode pvxOpticalFlowPyrLKNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxRemapNode(IntPtr graph, IntPtr input, IntPtr table, int policy, IntPtr output);

			internal static vxRemapNode pvxRemapNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxHalfScaleGaussianNode(IntPtr graph, IntPtr input, IntPtr output, int kernel_size);

			internal static vxHalfScaleGaussianNode pvxHalfScaleGaussianNode;

		}
	}

}
