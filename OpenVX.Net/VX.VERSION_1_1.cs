
// MIT License
// 
// Copyright (c) 2009-2017 Luca Piccioni
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// 
// This file is automatically generated

#pragma warning disable 649, 1572, 1573

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Security;
using System.Text;

using Khronos;

namespace OpenVX
{
	public partial class VX
	{
		public const uint VENDOR_MASK = 0xFFF00000;

		public const uint TYPE_MASK = 0x000FFF00;

		public const uint LIBRARY_MASK = 0x000FF000;

		public const uint KERNEL_MASK = 0x00000FFF;

		public const uint ATTRIBUTE_ID_MASK = 0x000000FF;

		public const uint ENUM_TYPE_MASK = 0x000FF000;

		public const uint ENUM_MASK = 0x00000FFF;

		public const string FMT_REF = "%I64u";

		public const string FMT_SIZE = "%I64u";

		public const uint SCALE_UNITY = 1024u;

		public const float SCALE_PYRAMID_HALF = 0.5f;

		public const float SCALE_PYRAMID_ORB = 0.8408964f;

		public const int TYPE_INVALID = 0x000;

		public const int TYPE_CHAR = 0x001;

		public const int TYPE_INT8 = 0x002;

		public const int TYPE_UINT8 = 0x003;

		public const int TYPE_INT16 = 0x004;

		public const int TYPE_UINT16 = 0x005;

		public const int TYPE_INT32 = 0x006;

		public const int TYPE_UINT32 = 0x007;

		public const int TYPE_INT64 = 0x008;

		public const int TYPE_UINT64 = 0x009;

		public const int TYPE_FLOAT32 = 0x00A;

		public const int TYPE_FLOAT64 = 0x00B;

		public const int TYPE_ENUM = 0x00C;

		public const int TYPE_SIZE = 0x00D;

		public const int TYPE_DF_IMAGE = 0x00E;

		public const int TYPE_FLOAT16 = 0x00F;

		public const int TYPE_BOOL = 0x010;

		public const int TYPE_RECTANGLE = 0x020;

		public const int TYPE_KEYPOINT = 0x021;

		public const int TYPE_COORDINATES2D = 0x022;

		public const int TYPE_COORDINATES3D = 0x023;

		public const int TYPE_USER_STRUCT_START = 0x100;

		public const int TYPE_VENDOR_STRUCT_START = 0x400;

		public const int TYPE_KHRONOS_OBJECT_START = 0x800;

		public const int TYPE_VENDOR_OBJECT_START = 0xC00;

		public const int TYPE_KHRONOS_STRUCT_MAX = TYPE_USER_STRUCT_START - 1;

		public const int TYPE_USER_STRUCT_END = TYPE_VENDOR_STRUCT_START - 1;

		public const int TYPE_VENDOR_STRUCT_END = TYPE_KHRONOS_OBJECT_START - 1;

		public const int TYPE_KHRONOS_OBJECT_END = TYPE_VENDOR_OBJECT_START - 1;

		public const int TYPE_VENDOR_OBJECT_END = 0xFFF;

		public const int TYPE_REFERENCE = 0x800;

		public const int TYPE_CONTEXT = 0x801;

		public const int TYPE_GRAPH = 0x802;

		public const int TYPE_NODE = 0x803;

		public const int TYPE_KERNEL = 0x804;

		public const int TYPE_PARAMETER = 0x805;

		public const int TYPE_DELAY = 0x806;

		public const int TYPE_LUT = 0x807;

		public const int TYPE_DISTRIBUTION = 0x808;

		public const int TYPE_PYRAMID = 0x809;

		public const int TYPE_THRESHOLD = 0x80A;

		public const int TYPE_MATRIX = 0x80B;

		public const int TYPE_CONVOLUTION = 0x80C;

		public const int TYPE_SCALAR = 0x80D;

		public const int TYPE_ARRAY = 0x80E;

		public const int TYPE_IMAGE = 0x80F;

		public const int TYPE_REMAP = 0x810;

		public const int TYPE_ERROR = 0x811;

		public const int TYPE_META_FORMAT = 0x812;

		public const int TYPE_OBJECT_ARRAY = 0x813;

		public const int STATUS_MIN = -25;

		public const int ERROR_REFERENCE_NONZERO = -24;

		public const int ERROR_MULTIPLE_WRITERS = -23;

		public const int ERROR_GRAPH_ABANDONED = -22;

		public const int ERROR_GRAPH_SCHEDULED = -21;

		public const int ERROR_INVALID_SCOPE = -20;

		public const int ERROR_INVALID_NODE = -19;

		public const int ERROR_INVALID_GRAPH = -18;

		public const int ERROR_INVALID_TYPE = -17;

		public const int ERROR_INVALID_VALUE = -16;

		public const int ERROR_INVALID_DIMENSION = -15;

		public const int ERROR_INVALID_FORMAT = -14;

		public const int ERROR_INVALID_LINK = -13;

		public const int ERROR_INVALID_REFERENCE = -12;

		public const int ERROR_INVALID_MODULE = -11;

		public const int ERROR_INVALID_PARAMETERS = -10;

		public const int ERROR_OPTIMIZED_AWAY = -9;

		public const int ERROR_NO_MEMORY = -8;

		public const int ERROR_NO_RESOURCES = -7;

		public const int ERROR_NOT_COMPATIBLE = -6;

		public const int ERROR_NOT_ALLOCATED = -5;

		public const int ERROR_NOT_SUFFICIENT = -4;

		public const int ERROR_NOT_SUPPORTED = -3;

		public const int ERROR_NOT_IMPLEMENTED = -2;

		public const int FAILURE = -1;

		public const int SUCCESS = 0;

		public const int ENUM_DIRECTION = 0x00;

		public const int ENUM_ACTION = 0x01;

		public const int ENUM_HINT = 0x02;

		public const int ENUM_DIRECTIVE = 0x03;

		public const int ENUM_INTERPOLATION = 0x04;

		public const int ENUM_OVERFLOW = 0x05;

		public const int ENUM_COLOR_SPACE = 0x06;

		public const int ENUM_COLOR_RANGE = 0x07;

		public const int ENUM_PARAMETER_STATE = 0x08;

		public const int ENUM_CHANNEL = 0x09;

		public const int ENUM_CONVERT_POLICY = 0x0A;

		public const int ENUM_THRESHOLD_TYPE = 0x0B;

		public const int ENUM_BORDER = 0x0C;

		public const int ENUM_COMPARISON = 0x0D;

		public const int ENUM_MEMORY_TYPE = 0x0E;

		public const int ENUM_TERM_CRITERIA = 0x0F;

		public const int ENUM_NORM_TYPE = 0x10;

		public const int ENUM_ACCESSOR = 0x11;

		public const int ENUM_ROUND_POLICY = 0x12;

		public const int ENUM_TARGET = 0x13;

		public const int ENUM_BORDER_POLICY = 0x14;

		public const int ENUM_GRAPH_STATE = 0x15;

		public const int ENUM_NONLINEAR = 0x16;

		public const int ENUM_PATTERN = 0x17;

		public const int ACTION_CONTINUE = ((ID_KHRONOS << 20) | ( ENUM_ACTION << 12)) + 0x0;

		public const int ACTION_ABANDON = ((ID_KHRONOS << 20) | ( ENUM_ACTION << 12)) + 0x1;

		public const int INPUT = ((ID_KHRONOS << 20) | ( ENUM_DIRECTION << 12)) + 0x0;

		public const int OUTPUT = ((ID_KHRONOS << 20) | ( ENUM_DIRECTION << 12)) + 0x1;

		public const int BIDIRECTIONAL = ((ID_KHRONOS << 20) | ( ENUM_DIRECTION << 12)) + 0x2;

		public const int HINT_PERFORMANCE_DEFAULT = ((ID_KHRONOS << 20) | ( ENUM_HINT << 12)) + 0x1;

		public const int HINT_PERFORMANCE_LOW_POWER = ((ID_KHRONOS << 20) | ( ENUM_HINT << 12)) + 0x2;

		public const int HINT_PERFORMANCE_HIGH_SPEED = ((ID_KHRONOS << 20) | ( ENUM_HINT << 12)) + 0x3;

		public const int DIRECTIVE_DISABLE_LOGGING = ((ID_KHRONOS << 20) | ( ENUM_DIRECTIVE << 12)) + 0x0;

		public const int DIRECTIVE_ENABLE_LOGGING = ((ID_KHRONOS << 20) | ( ENUM_DIRECTIVE << 12)) + 0x1;

		public const int DIRECTIVE_DISABLE_PERFORMANCE = ((ID_KHRONOS << 20) | ( ENUM_DIRECTIVE << 12)) + 0x2;

		public const int DIRECTIVE_ENABLE_PERFORMANCE = ((ID_KHRONOS << 20) | ( ENUM_DIRECTIVE << 12)) + 0x3;

		public const int GRAPH_STATE_UNVERIFIED = ((ID_KHRONOS << 20) | ( ENUM_GRAPH_STATE << 12)) + 0x0;

		public const int GRAPH_STATE_VERIFIED = ((ID_KHRONOS << 20) | ( ENUM_GRAPH_STATE << 12)) + 0x1;

		public const int GRAPH_STATE_RUNNING = ((ID_KHRONOS << 20) | ( ENUM_GRAPH_STATE << 12)) + 0x2;

		public const int GRAPH_STATE_ABANDONED = ((ID_KHRONOS << 20) | ( ENUM_GRAPH_STATE << 12)) + 0x3;

		public const int GRAPH_STATE_COMPLETED = ((ID_KHRONOS << 20) | ( ENUM_GRAPH_STATE << 12)) + 0x4;

		public const int GRAPH_NUMNODES = (((ID_KHRONOS) << 20) | ( TYPE_GRAPH << 8)) + 0x0;

		public const int GRAPH_PERFORMANCE = (((ID_KHRONOS) << 20) | ( TYPE_GRAPH << 8)) + 0x2;

		public const int GRAPH_NUMPARAMETERS = (((ID_KHRONOS) << 20) | ( TYPE_GRAPH << 8)) + 0x3;

		public const int GRAPH_STATE = (((ID_KHRONOS) << 20) | ( TYPE_GRAPH << 8)) + 0x4;

		public const int CONVERT_POLICY_WRAP = ((ID_KHRONOS << 20) | ( ENUM_CONVERT_POLICY << 12)) + 0x0;

		public const int CONVERT_POLICY_SATURATE = ((ID_KHRONOS << 20) | ( ENUM_CONVERT_POLICY << 12)) + 0x1;

		public const int DF_IMAGE_VIRT = ((byte)'V') | ((byte)'I' << 8) | ((byte)'R' << 16) | ((byte)'T' << 24);

		public const int DF_IMAGE_RGB = ((byte)'R') | ((byte)'G' << 8) | ((byte)'B' << 16) | ((byte)'2' << 24);

		public const int DF_IMAGE_RGBX = ((byte)'R') | ((byte)'G' << 8) | ((byte)'B' << 16) | ((byte)'A' << 24);

		public const int DF_IMAGE_NV12 = ((byte)'N') | ((byte)'V' << 8) | ((byte)'1' << 16) | ((byte)'2' << 24);

		public const int DF_IMAGE_NV21 = ((byte)'N') | ((byte)'V' << 8) | ((byte)'2' << 16) | ((byte)'1' << 24);

		public const int DF_IMAGE_UYVY = ((byte)'U') | ((byte)'Y' << 8) | ((byte)'V' << 16) | ((byte)'Y' << 24);

		public const int DF_IMAGE_YUYV = ((byte)'Y') | ((byte)'U' << 8) | ((byte)'Y' << 16) | ((byte)'V' << 24);

		public const int DF_IMAGE_IYUV = ((byte)'I') | ((byte)'Y' << 8) | ((byte)'U' << 16) | ((byte)'V' << 24);

		public const int DF_IMAGE_YUV4 = ((byte)'Y') | ((byte)'U' << 8) | ((byte)'V' << 16) | ((byte)'4' << 24);

		public const int DF_IMAGE_U8 = ((byte)'U') | ((byte)'0' << 8) | ((byte)'0' << 16) | ((byte)'8' << 24);

		public const int DF_IMAGE_U16 = ((byte)'U') | ((byte)'0' << 8) | ((byte)'1' << 16) | ((byte)'6' << 24);

		public const int DF_IMAGE_S16 = ((byte)'S') | ((byte)'0' << 8) | ((byte)'1' << 16) | ((byte)'6' << 24);

		public const int DF_IMAGE_U32 = ((byte)'U') | ((byte)'0' << 8) | ((byte)'3' << 16) | ((byte)'2' << 24);

		public const int DF_IMAGE_S32 = ((byte)'S') | ((byte)'0' << 8) | ((byte)'3' << 16) | ((byte)'2' << 24);

		public const int TARGET_ANY = ((ID_KHRONOS << 20) | ( ENUM_TARGET << 12)) + 0x0000;

		public const int TARGET_STRING = ((ID_KHRONOS << 20) | ( ENUM_TARGET << 12)) + 0x0001;

		public const int TARGET_VENDOR_BEGIN = ((ID_KHRONOS << 20) | ( ENUM_TARGET << 12)) + 0x1000;

		public const int REFERENCE_COUNT = (((ID_KHRONOS) << 20) | ( TYPE_REFERENCE << 8)) + 0x0;

		public const int REFERENCE_TYPE = (((ID_KHRONOS) << 20) | ( TYPE_REFERENCE << 8)) + 0x1;

		public const int REFERENCE_NAME = (((ID_KHRONOS) << 20) | ( TYPE_REFERENCE << 8)) + 0x2;

		public const int CONTEXT_VENDOR_ID = (((ID_KHRONOS) << 20) | ( TYPE_CONTEXT << 8)) + 0x0;

		public const int CONTEXT_VERSION = (((ID_KHRONOS) << 20) | ( TYPE_CONTEXT << 8)) + 0x1;

		public const int CONTEXT_UNIQUE_KERNELS = (((ID_KHRONOS) << 20) | ( TYPE_CONTEXT << 8)) + 0x2;

		public const int CONTEXT_MODULES = (((ID_KHRONOS) << 20) | ( TYPE_CONTEXT << 8)) + 0x3;

		public const int CONTEXT_REFERENCES = (((ID_KHRONOS) << 20) | ( TYPE_CONTEXT << 8)) + 0x4;

		public const int CONTEXT_IMPLEMENTATION = (((ID_KHRONOS) << 20) | ( TYPE_CONTEXT << 8)) + 0x5;

		public const int CONTEXT_EXTENSIONS_SIZE = (((ID_KHRONOS) << 20) | ( TYPE_CONTEXT << 8)) + 0x6;

		public const int CONTEXT_EXTENSIONS = (((ID_KHRONOS) << 20) | ( TYPE_CONTEXT << 8)) + 0x7;

		public const int CONTEXT_CONVOLUTION_MAX_DIMENSION = (((ID_KHRONOS) << 20) | ( TYPE_CONTEXT << 8)) + 0x8;

		public const int CONTEXT_OPTICAL_FLOW_MAX_WINDOW_DIMENSION = (((ID_KHRONOS) << 20) | ( TYPE_CONTEXT << 8)) + 0x9;

		public const int CONTEXT_IMMEDIATE_BORDER = (((ID_KHRONOS) << 20) | ( TYPE_CONTEXT << 8)) + 0xA;

		public const int CONTEXT_UNIQUE_KERNEL_TABLE = (((ID_KHRONOS) << 20) | ( TYPE_CONTEXT << 8)) + 0xB;

		public const int CONTEXT_IMMEDIATE_BORDER_POLICY = (((ID_KHRONOS) << 20) | ( TYPE_CONTEXT << 8)) + 0xC;

		public const int CONTEXT_NONLINEAR_MAX_DIMENSION = (((ID_KHRONOS) << 20) | ( TYPE_CONTEXT << 8)) + 0xd;

		public const int KERNEL_PARAMETERS = (((ID_KHRONOS) << 20) | ( TYPE_KERNEL << 8)) + 0x0;

		public const int KERNEL_NAME = (((ID_KHRONOS) << 20) | ( TYPE_KERNEL << 8)) + 0x1;

		public const int KERNEL_ENUM = (((ID_KHRONOS) << 20) | ( TYPE_KERNEL << 8)) + 0x2;

		public const int KERNEL_LOCAL_DATA_SIZE = (((ID_KHRONOS) << 20) | ( TYPE_KERNEL << 8)) + 0x3;

		public const int NODE_STATUS = (((ID_KHRONOS) << 20) | ( TYPE_NODE << 8)) + 0x0;

		public const int NODE_PERFORMANCE = (((ID_KHRONOS) << 20) | ( TYPE_NODE << 8)) + 0x1;

		public const int NODE_BORDER = (((ID_KHRONOS) << 20) | ( TYPE_NODE << 8)) + 0x2;

		public const int NODE_LOCAL_DATA_SIZE = (((ID_KHRONOS) << 20) | ( TYPE_NODE << 8)) + 0x3;

		public const int NODE_LOCAL_DATA_PTR = (((ID_KHRONOS) << 20) | ( TYPE_NODE << 8)) + 0x4;

		public const int NODE_PARAMETERS = (((ID_KHRONOS) << 20) | ( TYPE_NODE << 8)) + 0x5;

		public const int NODE_IS_REPLICATED = (((ID_KHRONOS) << 20) | ( TYPE_NODE << 8)) + 0x6;

		public const int NODE_REPLICATE_FLAGS = (((ID_KHRONOS) << 20) | ( TYPE_NODE << 8)) + 0x7;

		public const int NODE_VALID_RECT_RESET = (((ID_KHRONOS) << 20) | ( TYPE_NODE << 8)) + 0x8;

		public const int PARAMETER_INDEX = (((ID_KHRONOS) << 20) | ( TYPE_PARAMETER << 8)) + 0x0;

		public const int PARAMETER_DIRECTION = (((ID_KHRONOS) << 20) | ( TYPE_PARAMETER << 8)) + 0x1;

		public const int PARAMETER_TYPE = (((ID_KHRONOS) << 20) | ( TYPE_PARAMETER << 8)) + 0x2;

		public const int PARAMETER_STATE = (((ID_KHRONOS) << 20) | ( TYPE_PARAMETER << 8)) + 0x3;

		public const int PARAMETER_REF = (((ID_KHRONOS) << 20) | ( TYPE_PARAMETER << 8)) + 0x4;

		public const int IMAGE_WIDTH = (((ID_KHRONOS) << 20) | ( TYPE_IMAGE << 8)) + 0x0;

		public const int IMAGE_HEIGHT = (((ID_KHRONOS) << 20) | ( TYPE_IMAGE << 8)) + 0x1;

		public const int IMAGE_FORMAT = (((ID_KHRONOS) << 20) | ( TYPE_IMAGE << 8)) + 0x2;

		public const int IMAGE_PLANES = (((ID_KHRONOS) << 20) | ( TYPE_IMAGE << 8)) + 0x3;

		public const int IMAGE_SPACE = (((ID_KHRONOS) << 20) | ( TYPE_IMAGE << 8)) + 0x4;

		public const int IMAGE_RANGE = (((ID_KHRONOS) << 20) | ( TYPE_IMAGE << 8)) + 0x5;

		public const int IMAGE_SIZE = (((ID_KHRONOS) << 20) | ( TYPE_IMAGE << 8)) + 0x6;

		public const int IMAGE_MEMORY_TYPE = (((ID_KHRONOS) << 20) | ( TYPE_IMAGE << 8)) + 0x7;

		public const int SCALAR_TYPE = (((ID_KHRONOS) << 20) | ( TYPE_SCALAR << 8)) + 0x0;

		public const int LUT_TYPE = (((ID_KHRONOS) << 20) | (TYPE_LUT << 8)) + 0x0;

		public const int LUT_COUNT = (((ID_KHRONOS) << 20) | (TYPE_LUT << 8)) + 0x1;

		public const int LUT_SIZE = (((ID_KHRONOS) << 20) | (TYPE_LUT << 8)) + 0x2;

		public const int LUT_OFFSET = (((ID_KHRONOS) << 20) | (TYPE_LUT << 8)) + 0x3;

		public const int DISTRIBUTION_DIMENSIONS = (((ID_KHRONOS) << 20) | ( TYPE_DISTRIBUTION << 8)) + 0x0;

		public const int DISTRIBUTION_OFFSET = (((ID_KHRONOS) << 20) | ( TYPE_DISTRIBUTION << 8)) + 0x1;

		public const int DISTRIBUTION_RANGE = (((ID_KHRONOS) << 20) | ( TYPE_DISTRIBUTION << 8)) + 0x2;

		public const int DISTRIBUTION_BINS = (((ID_KHRONOS) << 20) | ( TYPE_DISTRIBUTION << 8)) + 0x3;

		public const int DISTRIBUTION_WINDOW = (((ID_KHRONOS) << 20) | ( TYPE_DISTRIBUTION << 8)) + 0x4;

		public const int DISTRIBUTION_SIZE = (((ID_KHRONOS) << 20) | ( TYPE_DISTRIBUTION << 8)) + 0x5;

		public const int THRESHOLD_TYPE_BINARY = ((ID_KHRONOS << 20) | ( ENUM_THRESHOLD_TYPE << 12)) + 0x0;

		public const int THRESHOLD_TYPE_RANGE = ((ID_KHRONOS << 20) | ( ENUM_THRESHOLD_TYPE << 12)) + 0x1;

		public const int THRESHOLD_TYPE = (((ID_KHRONOS) << 20) | ( TYPE_THRESHOLD << 8)) + 0x0;

		public const int THRESHOLD_THRESHOLD_VALUE = (((ID_KHRONOS) << 20) | ( TYPE_THRESHOLD << 8)) + 0x1;

		public const int THRESHOLD_THRESHOLD_LOWER = (((ID_KHRONOS) << 20) | ( TYPE_THRESHOLD << 8)) + 0x2;

		public const int THRESHOLD_THRESHOLD_UPPER = (((ID_KHRONOS) << 20) | ( TYPE_THRESHOLD << 8)) + 0x3;

		public const int THRESHOLD_TRUE_VALUE = (((ID_KHRONOS) << 20) | ( TYPE_THRESHOLD << 8)) + 0x4;

		public const int THRESHOLD_FALSE_VALUE = (((ID_KHRONOS) << 20) | ( TYPE_THRESHOLD << 8)) + 0x5;

		public const int THRESHOLD_DATA_TYPE = (((ID_KHRONOS) << 20) | ( TYPE_THRESHOLD << 8)) + 0x6;

		public const int MATRIX_TYPE = (((ID_KHRONOS) << 20) | ( TYPE_MATRIX << 8)) + 0x0;

		public const int MATRIX_ROWS = (((ID_KHRONOS) << 20) | ( TYPE_MATRIX << 8)) + 0x1;

		public const int MATRIX_COLUMNS = (((ID_KHRONOS) << 20) | ( TYPE_MATRIX << 8)) + 0x2;

		public const int MATRIX_SIZE = (((ID_KHRONOS) << 20) | ( TYPE_MATRIX << 8)) + 0x3;

		public const int MATRIX_ORIGIN = (((ID_KHRONOS) << 20) | ( TYPE_MATRIX << 8)) + 0x4;

		public const int MATRIX_PATTERN = (((ID_KHRONOS) << 20) | ( TYPE_MATRIX << 8)) + 0x5;

		public const int CONVOLUTION_ROWS = (((ID_KHRONOS) << 20) | ( TYPE_CONVOLUTION << 8)) + 0x0;

		public const int CONVOLUTION_COLUMNS = (((ID_KHRONOS) << 20) | ( TYPE_CONVOLUTION << 8)) + 0x1;

		public const int CONVOLUTION_SCALE = (((ID_KHRONOS) << 20) | ( TYPE_CONVOLUTION << 8)) + 0x2;

		public const int CONVOLUTION_SIZE = (((ID_KHRONOS) << 20) | ( TYPE_CONVOLUTION << 8)) + 0x3;

		public const int PYRAMID_LEVELS = (((ID_KHRONOS) << 20) | ( TYPE_PYRAMID << 8)) + 0x0;

		public const int PYRAMID_SCALE = (((ID_KHRONOS) << 20) | ( TYPE_PYRAMID << 8)) + 0x1;

		public const int PYRAMID_WIDTH = (((ID_KHRONOS) << 20) | ( TYPE_PYRAMID << 8)) + 0x2;

		public const int PYRAMID_HEIGHT = (((ID_KHRONOS) << 20) | ( TYPE_PYRAMID << 8)) + 0x3;

		public const int PYRAMID_FORMAT = (((ID_KHRONOS) << 20) | ( TYPE_PYRAMID << 8)) + 0x4;

		public const int REMAP_SOURCE_WIDTH = (((ID_KHRONOS) << 20) | ( TYPE_REMAP << 8)) + 0x0;

		public const int REMAP_SOURCE_HEIGHT = (((ID_KHRONOS) << 20) | ( TYPE_REMAP << 8)) + 0x1;

		public const int REMAP_DESTINATION_WIDTH = (((ID_KHRONOS) << 20) | ( TYPE_REMAP << 8)) + 0x2;

		public const int REMAP_DESTINATION_HEIGHT = (((ID_KHRONOS) << 20) | ( TYPE_REMAP << 8)) + 0x3;

		public const int ARRAY_ITEMTYPE = (((ID_KHRONOS) << 20) | ( TYPE_ARRAY << 8)) + 0x0;

		public const int ARRAY_NUMITEMS = (((ID_KHRONOS) << 20) | ( TYPE_ARRAY << 8)) + 0x1;

		public const int ARRAY_CAPACITY = (((ID_KHRONOS) << 20) | ( TYPE_ARRAY << 8)) + 0x2;

		public const int ARRAY_ITEMSIZE = (((ID_KHRONOS) << 20) | ( TYPE_ARRAY << 8)) + 0x3;

		public const int OBJECT_ARRAY_ITEMTYPE = (((ID_KHRONOS) << 20) | ( TYPE_OBJECT_ARRAY << 8)) + 0x0;

		public const int OBJECT_ARRAY_NUMITEMS = (((ID_KHRONOS) << 20) | ( TYPE_OBJECT_ARRAY << 8)) + 0x1;

		public const int VALID_RECT_CALLBACK = (((ID_KHRONOS) << 20) | ( TYPE_META_FORMAT << 8)) + 0x1;

		public const int CHANNEL_0 = ((ID_KHRONOS << 20) | ( ENUM_CHANNEL << 12)) + 0x0;

		public const int CHANNEL_1 = ((ID_KHRONOS << 20) | ( ENUM_CHANNEL << 12)) + 0x1;

		public const int CHANNEL_2 = ((ID_KHRONOS << 20) | ( ENUM_CHANNEL << 12)) + 0x2;

		public const int CHANNEL_3 = ((ID_KHRONOS << 20) | ( ENUM_CHANNEL << 12)) + 0x3;

		public const int CHANNEL_R = ((ID_KHRONOS << 20) | ( ENUM_CHANNEL << 12)) + 0x10;

		public const int CHANNEL_G = ((ID_KHRONOS << 20) | ( ENUM_CHANNEL << 12)) + 0x11;

		public const int CHANNEL_B = ((ID_KHRONOS << 20) | ( ENUM_CHANNEL << 12)) + 0x12;

		public const int CHANNEL_A = ((ID_KHRONOS << 20) | ( ENUM_CHANNEL << 12)) + 0x13;

		public const int CHANNEL_Y = ((ID_KHRONOS << 20) | ( ENUM_CHANNEL << 12)) + 0x14;

		public const int CHANNEL_U = ((ID_KHRONOS << 20) | ( ENUM_CHANNEL << 12)) + 0x15;

		public const int CHANNEL_V = ((ID_KHRONOS << 20) | ( ENUM_CHANNEL << 12)) + 0x16;

		public const int MEMORY_TYPE_NONE = ((ID_KHRONOS << 20) | ( ENUM_MEMORY_TYPE << 12)) + 0x0;

		public const int MEMORY_TYPE_HOST = ((ID_KHRONOS << 20) | ( ENUM_MEMORY_TYPE << 12)) + 0x1;

		public const int INTERPOLATION_NEAREST_NEIGHBOR = ((ID_KHRONOS << 20) | ( ENUM_INTERPOLATION << 12)) + 0x0;

		public const int INTERPOLATION_BILINEAR = ((ID_KHRONOS << 20) | ( ENUM_INTERPOLATION << 12)) + 0x1;

		public const int INTERPOLATION_AREA = ((ID_KHRONOS << 20) | ( ENUM_INTERPOLATION << 12)) + 0x2;

		public const int NONLINEAR_FILTER_MEDIAN = ((ID_KHRONOS << 20) | ( ENUM_NONLINEAR << 12)) + 0x0;

		public const int NONLINEAR_FILTER_MIN = ((ID_KHRONOS << 20) | ( ENUM_NONLINEAR << 12)) + 0x1;

		public const int NONLINEAR_FILTER_MAX = ((ID_KHRONOS << 20) | ( ENUM_NONLINEAR << 12)) + 0x2;

		public const int PATTERN_BOX = ((ID_KHRONOS << 20) | ( ENUM_PATTERN << 12)) + 0x0;

		public const int PATTERN_CROSS = ((ID_KHRONOS << 20) | ( ENUM_PATTERN << 12)) + 0x1;

		public const int PATTERN_DISK = ((ID_KHRONOS << 20) | ( ENUM_PATTERN << 12)) + 0x2;

		public const int PATTERN_OTHER = ((ID_KHRONOS << 20) | ( ENUM_PATTERN << 12)) + 0x3;

		public const int COLOR_SPACE_NONE = ((ID_KHRONOS << 20) | ( ENUM_COLOR_SPACE << 12)) + 0x0;

		public const int COLOR_SPACE_BT601_525 = ((ID_KHRONOS << 20) | ( ENUM_COLOR_SPACE << 12)) + 0x1;

		public const int COLOR_SPACE_BT601_625 = ((ID_KHRONOS << 20) | ( ENUM_COLOR_SPACE << 12)) + 0x2;

		public const int COLOR_SPACE_BT709 = ((ID_KHRONOS << 20) | ( ENUM_COLOR_SPACE << 12)) + 0x3;

		public const int COLOR_SPACE_DEFAULT = COLOR_SPACE_BT709;

		public const int CHANNEL_RANGE_FULL = ((ID_KHRONOS << 20) | ( ENUM_COLOR_RANGE << 12)) + 0x0;

		public const int CHANNEL_RANGE_RESTRICTED = ((ID_KHRONOS << 20) | ( ENUM_COLOR_RANGE << 12)) + 0x1;

		public const int PARAMETER_STATE_REQUIRED = ((ID_KHRONOS << 20) | ( ENUM_PARAMETER_STATE << 12)) + 0x0;

		public const int PARAMETER_STATE_OPTIONAL = ((ID_KHRONOS << 20) | ( ENUM_PARAMETER_STATE << 12)) + 0x1;

		public const int BORDER_UNDEFINED = ((ID_KHRONOS << 20) | ( ENUM_BORDER << 12)) + 0x0;

		public const int BORDER_CONSTANT = ((ID_KHRONOS << 20) | ( ENUM_BORDER << 12)) + 0x1;

		public const int BORDER_REPLICATE = ((ID_KHRONOS << 20) | ( ENUM_BORDER << 12)) + 0x2;

		public const int BORDER_POLICY_DEFAULT_TO_UNDEFINED = ((ID_KHRONOS << 20) | ( ENUM_BORDER_POLICY << 12)) + 0x0;

		public const int BORDER_POLICY_RETURN_ERROR = ((ID_KHRONOS << 20) | ( ENUM_BORDER_POLICY << 12)) + 0x1;

		public const int TERM_CRITERIA_ITERATIONS = ((ID_KHRONOS << 20) | ( ENUM_TERM_CRITERIA << 12)) + 0x0;

		public const int TERM_CRITERIA_EPSILON = ((ID_KHRONOS << 20) | ( ENUM_TERM_CRITERIA << 12)) + 0x1;

		public const int TERM_CRITERIA_BOTH = ((ID_KHRONOS << 20) | ( ENUM_TERM_CRITERIA << 12)) + 0x2;

		public const int NORM_L1 = ((ID_KHRONOS << 20) | ( ENUM_NORM_TYPE << 12)) + 0x0;

		public const int NORM_L2 = ((ID_KHRONOS << 20) | ( ENUM_NORM_TYPE << 12)) + 0x1;

		public const int DELAY_TYPE = (((ID_KHRONOS) << 20) | ( TYPE_DELAY << 8)) + 0x0;

		public const int DELAY_SLOTS = (((ID_KHRONOS) << 20) | ( TYPE_DELAY << 8)) + 0x1;

		public const int READ_ONLY = ((ID_KHRONOS << 20) | ( ENUM_ACCESSOR << 12)) + 0x1;

		public const int WRITE_ONLY = ((ID_KHRONOS << 20) | ( ENUM_ACCESSOR << 12)) + 0x2;

		public const int READ_AND_WRITE = ((ID_KHRONOS << 20) | ( ENUM_ACCESSOR << 12)) + 0x3;

		public const int ROUND_POLICY_TO_ZERO = ((ID_KHRONOS << 20) | ( ENUM_ROUND_POLICY << 12)) + 0x1;

		public const int ROUND_POLICY_TO_NEAREST_EVEN = ((ID_KHRONOS << 20) | ( ENUM_ROUND_POLICY << 12)) + 0x2;

		public const int NOGAP_X = 1;

		public const int LIBRARY_KHR_BASE = 0x0;

		public const int KERNEL_COLOR_CONVERT = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x1;

		public const int KERNEL_CHANNEL_EXTRACT = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x2;

		public const int KERNEL_CHANNEL_COMBINE = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x3;

		public const int KERNEL_SOBEL_3x3 = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x4;

		public const int KERNEL_MAGNITUDE = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x5;

		public const int KERNEL_PHASE = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x6;

		public const int KERNEL_SCALE_IMAGE = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x7;

		public const int KERNEL_TABLE_LOOKUP = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x8;

		public const int KERNEL_HISTOGRAM = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x9;

		public const int KERNEL_EQUALIZE_HISTOGRAM = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0xA;

		public const int KERNEL_ABSDIFF = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0xB;

		public const int KERNEL_MEAN_STDDEV = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0xC;

		public const int KERNEL_THRESHOLD = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0xD;

		public const int KERNEL_INTEGRAL_IMAGE = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0xE;

		public const int KERNEL_DILATE_3x3 = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0xF;

		public const int KERNEL_ERODE_3x3 = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x10;

		public const int KERNEL_MEDIAN_3x3 = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x11;

		public const int KERNEL_BOX_3x3 = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x12;

		public const int KERNEL_GAUSSIAN_3x3 = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x13;

		public const int KERNEL_CUSTOM_CONVOLUTION = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x14;

		public const int KERNEL_GAUSSIAN_PYRAMID = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x15;

		public const int KERNEL_ACCUMULATE = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x16;

		public const int KERNEL_ACCUMULATE_WEIGHTED = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x17;

		public const int KERNEL_ACCUMULATE_SQUARE = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x18;

		public const int KERNEL_MINMAXLOC = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x19;

		public const int KERNEL_CONVERTDEPTH = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x1A;

		public const int KERNEL_CANNY_EDGE_DETECTOR = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x1B;

		public const int KERNEL_AND = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x1C;

		public const int KERNEL_OR = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x1D;

		public const int KERNEL_XOR = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x1E;

		public const int KERNEL_NOT = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x1F;

		public const int KERNEL_MULTIPLY = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x20;

		public const int KERNEL_ADD = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x21;

		public const int KERNEL_SUBTRACT = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x22;

		public const int KERNEL_WARP_AFFINE = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x23;

		public const int KERNEL_WARP_PERSPECTIVE = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x24;

		public const int KERNEL_HARRIS_CORNERS = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x25;

		public const int KERNEL_FAST_CORNERS = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x26;

		public const int KERNEL_OPTICAL_FLOW_PYR_LK = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x27;

		public const int KERNEL_REMAP = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x28;

		public const int KERNEL_HALFSCALE_GAUSSIAN = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x29;

		public const int KERNEL_LAPLACIAN_PYRAMID = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x2A;

		public const int KERNEL_LAPLACIAN_RECONSTRUCT = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x2B;

		public const int KERNEL_NON_LINEAR_FILTER = (((ID_KHRONOS) << 20) | ( LIBRARY_KHR_BASE << 12)) + 0x2C;

		public const int ID_KHRONOS = 0x000;

		public const int ID_TI = 0x001;

		public const int ID_QUALCOMM = 0x002;

		public const int ID_NVIDIA = 0x003;

		public const int ID_ARM = 0x004;

		public const int ID_BDTI = 0x005;

		public const int ID_RENESAS = 0x006;

		public const int ID_VIVANTE = 0x007;

		public const int ID_XILINX = 0x008;

		public const int ID_AXIS = 0x009;

		public const int ID_MOVIDIUS = 0x00A;

		public const int ID_SAMSUNG = 0x00B;

		public const int ID_FREESCALE = 0x00C;

		public const int ID_AMD = 0x00D;

		public const int ID_BROADCOM = 0x00E;

		public const int ID_INTEL = 0x00F;

		public const int ID_MARVELL = 0x010;

		public const int ID_MEDIATEK = 0x011;

		public const int ID_ST = 0x012;

		public const int ID_CEVA = 0x013;

		public const int ID_ITSEEZ = 0x014;

		public const int ID_NXP = 0x016;

		public const int ID_VIDEANTIS = 0x017;

		public const int ID_SYNOPSYS = 0x018;

		public const int ID_CADENCE = 0x019;

		public const int ID_HUAWEI = 0x01A;

		public const int ID_USER = 0xFFE;

		public const int ID_MAX = 0xFFF;

		public const int ID_DEFAULT = ID_MAX;

		public static Context CreateContext()
		{
			Context retValue;

			Debug.Assert(Delegates.pvxCreateContext != null, "pvxCreateContext not implemented");
			retValue = Delegates.pvxCreateContext();
			LogCommand("vxCreateContext", retValue			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status ReleaseContext(params Context[] context)
		{
			Status retValue;

			unsafe {
				fixed (Context* p_context = context)
				{
					Debug.Assert(Delegates.pvxReleaseContext != null, "pvxReleaseContext not implemented");
					retValue = Delegates.pvxReleaseContext(p_context);
					LogCommand("vxReleaseContext", retValue, context					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Context GetContext(Reference reference)
		{
			Context retValue;

			Debug.Assert(Delegates.pvxGetContext != null, "pvxGetContext not implemented");
			retValue = Delegates.pvxGetContext(reference);
			LogCommand("vxGetContext", retValue, reference			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status QueryContext(Context context, int attribute, IntPtr ptr, uint size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryContext != null, "pvxQueryContext not implemented");
					retValue = Delegates.pvxQueryContext(context, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryContext", retValue, context, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status SetContextAttribute(Context context, int attribute, IntPtr ptr, uint size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxSetContextAttribute != null, "pvxSetContextAttribute not implemented");
					retValue = Delegates.pvxSetContextAttribute(context, attribute, ptr.ToPointer(), size);
					LogCommand("vxSetContextAttribute", retValue, context, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Hint(Reference reference, int hint, IntPtr data, uint data_size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxHint != null, "pvxHint not implemented");
					retValue = Delegates.pvxHint(reference, hint, data.ToPointer(), data_size);
					LogCommand("vxHint", retValue, reference, hint, data, data_size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status Directive(Reference reference, int directive)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxDirective != null, "pvxDirective not implemented");
			retValue = Delegates.pvxDirective(reference, directive);
			LogCommand("vxDirective", retValue, reference, directive			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status GetStatus(Reference reference)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxGetStatus != null, "pvxGetStatus not implemented");
			retValue = Delegates.pvxGetStatus(reference);
			LogCommand("vxGetStatus", retValue, reference			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static int RegisterUserStruct(Context context, uint size)
		{
			int retValue;

			Debug.Assert(Delegates.pvxRegisterUserStruct != null, "pvxRegisterUserStruct not implemented");
			retValue = Delegates.pvxRegisterUserStruct(context, size);
			LogCommand("vxRegisterUserStruct", retValue, context, size			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status AllocateUserKernelId(Context context, int[] pKernelEnumId)
		{
			Status retValue;

			unsafe {
				fixed (int* p_pKernelEnumId = pKernelEnumId)
				{
					Debug.Assert(Delegates.pvxAllocateUserKernelId != null, "pvxAllocateUserKernelId not implemented");
					retValue = Delegates.pvxAllocateUserKernelId(context, p_pKernelEnumId);
					LogCommand("vxAllocateUserKernelId", retValue, context, pKernelEnumId					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status AllocateUserKernelLibraryId(Context context, int[] pLibraryId)
		{
			Status retValue;

			unsafe {
				fixed (int* p_pLibraryId = pLibraryId)
				{
					Debug.Assert(Delegates.pvxAllocateUserKernelLibraryId != null, "pvxAllocateUserKernelLibraryId not implemented");
					retValue = Delegates.pvxAllocateUserKernelLibraryId(context, p_pLibraryId);
					LogCommand("vxAllocateUserKernelLibraryId", retValue, context, pLibraryId					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status SetImmediateModeTarget(Context context, int target_enum, string target_string)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxSetImmediateModeTarget != null, "pvxSetImmediateModeTarget not implemented");
			retValue = Delegates.pvxSetImmediateModeTarget(context, target_enum, target_string);
			LogCommand("vxSetImmediateModeTarget", retValue, context, target_enum, target_string			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Image CreateImage(Context context, uint width, uint height, DfImage color)
		{
			Image retValue;

			Debug.Assert(Delegates.pvxCreateImage != null, "pvxCreateImage not implemented");
			retValue = Delegates.pvxCreateImage(context, width, height, color);
			LogCommand("vxCreateImage", retValue, context, width, height, color			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Image CreateImageFromROI(Image img, Rectangle[] rect)
		{
			Image retValue;

			unsafe {
				fixed (Rectangle* p_rect = rect)
				{
					Debug.Assert(Delegates.pvxCreateImageFromROI != null, "pvxCreateImageFromROI not implemented");
					retValue = Delegates.pvxCreateImageFromROI(img, p_rect);
					LogCommand("vxCreateImageFromROI", retValue, img, rect					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Image CreateUniformImage(Context context, uint width, uint height, DfImage color, PixelValue value)
		{
			Image retValue;

			Debug.Assert(Delegates.pvxCreateUniformImage != null, "pvxCreateUniformImage not implemented");
			retValue = Delegates.pvxCreateUniformImage(context, width, height, color, value);
			LogCommand("vxCreateUniformImage", retValue, context, width, height, color, value			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Image CreateVirtualImage(Graph graph, uint width, uint height, DfImage color)
		{
			Image retValue;

			Debug.Assert(Delegates.pvxCreateVirtualImage != null, "pvxCreateVirtualImage not implemented");
			retValue = Delegates.pvxCreateVirtualImage(graph, width, height, color);
			LogCommand("vxCreateVirtualImage", retValue, graph, width, height, color			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Image CreateImageFromHandle(Context context, DfImage color, ImagePatchAddressing[] addrs, IntPtr[] ptrs, int memory_type)
		{
			Image retValue;

			unsafe {
				fixed (ImagePatchAddressing* p_addrs = addrs)
				fixed (IntPtr* p_ptrs = ptrs)
				{
					Debug.Assert(Delegates.pvxCreateImageFromHandle != null, "pvxCreateImageFromHandle not implemented");
					retValue = Delegates.pvxCreateImageFromHandle(context, color, p_addrs, p_ptrs, memory_type);
					LogCommand("vxCreateImageFromHandle", retValue, context, color, addrs, ptrs, memory_type					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status SwapImageHandle(Image image, IntPtr[] new_ptrs, IntPtr[] prev_ptrs, uint num_planes)
		{
			Status retValue;

			unsafe {
				fixed (IntPtr* p_new_ptrs = new_ptrs)
				fixed (IntPtr* p_prev_ptrs = prev_ptrs)
				{
					Debug.Assert(Delegates.pvxSwapImageHandle != null, "pvxSwapImageHandle not implemented");
					retValue = Delegates.pvxSwapImageHandle(image, p_new_ptrs, p_prev_ptrs, num_planes);
					LogCommand("vxSwapImageHandle", retValue, image, new_ptrs, prev_ptrs, num_planes					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status QueryImage(Image image, int attribute, IntPtr ptr, uint size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryImage != null, "pvxQueryImage not implemented");
					retValue = Delegates.pvxQueryImage(image, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryImage", retValue, image, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status SetImageAttribute(Image image, int attribute, IntPtr ptr, uint size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxSetImageAttribute != null, "pvxSetImageAttribute not implemented");
					retValue = Delegates.pvxSetImageAttribute(image, attribute, ptr.ToPointer(), size);
					LogCommand("vxSetImageAttribute", retValue, image, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status ReleaseImage(params Image[] image)
		{
			Status retValue;

			unsafe {
				fixed (Image* p_image = image)
				{
					Debug.Assert(Delegates.pvxReleaseImage != null, "pvxReleaseImage not implemented");
					retValue = Delegates.pvxReleaseImage(p_image);
					LogCommand("vxReleaseImage", retValue, image					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static uint ComputeImagePatchSize(Image image, Rectangle[] rect, uint plane_index)
		{
			uint retValue;

			unsafe {
				fixed (Rectangle* p_rect = rect)
				{
					Debug.Assert(Delegates.pvxComputeImagePatchSize != null, "pvxComputeImagePatchSize not implemented");
					retValue = Delegates.pvxComputeImagePatchSize(image, p_rect, plane_index);
					LogCommand("vxComputeImagePatchSize", retValue, image, rect, plane_index					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr FormatImagePatchAddress1d(IntPtr ptr, uint index, ImagePatchAddressing[] addr)
		{
			IntPtr retValue;

			unsafe {
				fixed (ImagePatchAddressing* p_addr = addr)
				{
					Debug.Assert(Delegates.pvxFormatImagePatchAddress1d != null, "pvxFormatImagePatchAddress1d not implemented");
					retValue = Delegates.pvxFormatImagePatchAddress1d(ptr.ToPointer(), index, p_addr);
					LogCommand("vxFormatImagePatchAddress1d", retValue, ptr, index, addr					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static IntPtr FormatImagePatchAddress2d(IntPtr ptr, uint x, uint y, ImagePatchAddressing[] addr)
		{
			IntPtr retValue;

			unsafe {
				fixed (ImagePatchAddressing* p_addr = addr)
				{
					Debug.Assert(Delegates.pvxFormatImagePatchAddress2d != null, "pvxFormatImagePatchAddress2d not implemented");
					retValue = Delegates.pvxFormatImagePatchAddress2d(ptr.ToPointer(), x, y, p_addr);
					LogCommand("vxFormatImagePatchAddress2d", retValue, ptr, x, y, addr					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status GetValidRegionImage(Image image, [Out] Rectangle[] rect)
		{
			Status retValue;

			unsafe {
				fixed (Rectangle* p_rect = rect)
				{
					Debug.Assert(Delegates.pvxGetValidRegionImage != null, "pvxGetValidRegionImage not implemented");
					retValue = Delegates.pvxGetValidRegionImage(image, p_rect);
					LogCommand("vxGetValidRegionImage", retValue, image, rect					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status CopyImagePatch(Image image, Rectangle[] image_rect, uint image_plane_index, ImagePatchAddressing[] user_addr, IntPtr user_ptr, int usage, int user_mem_type)
		{
			Status retValue;

			unsafe {
				fixed (Rectangle* p_image_rect = image_rect)
				fixed (ImagePatchAddressing* p_user_addr = user_addr)
				{
					Debug.Assert(Delegates.pvxCopyImagePatch != null, "pvxCopyImagePatch not implemented");
					retValue = Delegates.pvxCopyImagePatch(image, p_image_rect, image_plane_index, p_user_addr, user_ptr.ToPointer(), usage, user_mem_type);
					LogCommand("vxCopyImagePatch", retValue, image, image_rect, image_plane_index, user_addr, user_ptr, usage, user_mem_type					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status MapImagePatch(Image image, Rectangle[] rect, uint plane_index, MapId[] map_id, ImagePatchAddressing[] addr, IntPtr[] ptr, int usage, int mem_type, uint flags)
		{
			Status retValue;

			unsafe {
				fixed (Rectangle* p_rect = rect)
				fixed (MapId* p_map_id = map_id)
				fixed (ImagePatchAddressing* p_addr = addr)
				fixed (IntPtr* p_ptr = ptr)
				{
					Debug.Assert(Delegates.pvxMapImagePatch != null, "pvxMapImagePatch not implemented");
					retValue = Delegates.pvxMapImagePatch(image, p_rect, plane_index, p_map_id, p_addr, p_ptr, usage, mem_type, flags);
					LogCommand("vxMapImagePatch", retValue, image, rect, plane_index, map_id, addr, ptr, usage, mem_type, flags					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status UnmapImagePatch(Image image, MapId map_id)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxUnmapImagePatch != null, "pvxUnmapImagePatch not implemented");
			retValue = Delegates.pvxUnmapImagePatch(image, map_id);
			LogCommand("vxUnmapImagePatch", retValue, image, map_id			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Image CreateImageFromChannel(Image img, int channel)
		{
			Image retValue;

			Debug.Assert(Delegates.pvxCreateImageFromChannel != null, "pvxCreateImageFromChannel not implemented");
			retValue = Delegates.pvxCreateImageFromChannel(img, channel);
			LogCommand("vxCreateImageFromChannel", retValue, img, channel			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status SetImageValidRectangle(Image image, Rectangle[] rect)
		{
			Status retValue;

			unsafe {
				fixed (Rectangle* p_rect = rect)
				{
					Debug.Assert(Delegates.pvxSetImageValidRectangle != null, "pvxSetImageValidRectangle not implemented");
					retValue = Delegates.pvxSetImageValidRectangle(image, p_rect);
					LogCommand("vxSetImageValidRectangle", retValue, image, rect					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status LoadKernels(Context context, string module)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxLoadKernels != null, "pvxLoadKernels not implemented");
			retValue = Delegates.pvxLoadKernels(context, module);
			LogCommand("vxLoadKernels", retValue, context, module			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status UnloadKernels(Context context, string module)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxUnloadKernels != null, "pvxUnloadKernels not implemented");
			retValue = Delegates.pvxUnloadKernels(context, module);
			LogCommand("vxUnloadKernels", retValue, context, module			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Kernel GetKernelByName(Context context, string name)
		{
			Kernel retValue;

			Debug.Assert(Delegates.pvxGetKernelByName != null, "pvxGetKernelByName not implemented");
			retValue = Delegates.pvxGetKernelByName(context, name);
			LogCommand("vxGetKernelByName", retValue, context, name			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Kernel GetKernelByEnum(Context context, int kernel)
		{
			Kernel retValue;

			Debug.Assert(Delegates.pvxGetKernelByEnum != null, "pvxGetKernelByEnum not implemented");
			retValue = Delegates.pvxGetKernelByEnum(context, kernel);
			LogCommand("vxGetKernelByEnum", retValue, context, kernel			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status QueryKernel(Kernel kernel, int attribute, IntPtr ptr, uint size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryKernel != null, "pvxQueryKernel not implemented");
					retValue = Delegates.pvxQueryKernel(kernel, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryKernel", retValue, kernel, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status ReleaseKernel(params Kernel[] kernel)
		{
			Status retValue;

			unsafe {
				fixed (Kernel* p_kernel = kernel)
				{
					Debug.Assert(Delegates.pvxReleaseKernel != null, "pvxReleaseKernel not implemented");
					retValue = Delegates.pvxReleaseKernel(p_kernel);
					LogCommand("vxReleaseKernel", retValue, kernel					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Kernel AddUserKernel(Context context, string name, int enumeration, KernelCallback func_ptr, uint numParams, KernelValidateCallbackCallback validate, KernelInitializeCallback init, KernelDeinitializeCallback deinit)
		{
			Kernel retValue;

			Debug.Assert(Delegates.pvxAddUserKernel != null, "pvxAddUserKernel not implemented");
			retValue = Delegates.pvxAddUserKernel(context, name, enumeration, func_ptr, numParams, validate, init, deinit);
			LogCommand("vxAddUserKernel", retValue, context, name, enumeration, func_ptr, numParams, validate, init, deinit			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status FinalizeKernel(Kernel kernel)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxFinalizeKernel != null, "pvxFinalizeKernel not implemented");
			retValue = Delegates.pvxFinalizeKernel(kernel);
			LogCommand("vxFinalizeKernel", retValue, kernel			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status AddParameterToKernel(Kernel kernel, uint index, int dir, int data_type, int state)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxAddParameterToKernel != null, "pvxAddParameterToKernel not implemented");
			retValue = Delegates.pvxAddParameterToKernel(kernel, index, dir, data_type, state);
			LogCommand("vxAddParameterToKernel", retValue, kernel, index, dir, data_type, state			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status RemoveKernel(Kernel kernel)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxRemoveKernel != null, "pvxRemoveKernel not implemented");
			retValue = Delegates.pvxRemoveKernel(kernel);
			LogCommand("vxRemoveKernel", retValue, kernel			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status SetKernelAttribute(Kernel kernel, int attribute, IntPtr ptr, uint size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxSetKernelAttribute != null, "pvxSetKernelAttribute not implemented");
					retValue = Delegates.pvxSetKernelAttribute(kernel, attribute, ptr.ToPointer(), size);
					LogCommand("vxSetKernelAttribute", retValue, kernel, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Parameter GetKernelParameterByIndex(Kernel kernel, uint index)
		{
			Parameter retValue;

			Debug.Assert(Delegates.pvxGetKernelParameterByIndex != null, "pvxGetKernelParameterByIndex not implemented");
			retValue = Delegates.pvxGetKernelParameterByIndex(kernel, index);
			LogCommand("vxGetKernelParameterByIndex", retValue, kernel, index			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Graph CreateGraph(Context context)
		{
			Graph retValue;

			Debug.Assert(Delegates.pvxCreateGraph != null, "pvxCreateGraph not implemented");
			retValue = Delegates.pvxCreateGraph(context);
			LogCommand("vxCreateGraph", retValue, context			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status ReleaseGraph(params Graph[] graph)
		{
			Status retValue;

			unsafe {
				fixed (Graph* p_graph = graph)
				{
					Debug.Assert(Delegates.pvxReleaseGraph != null, "pvxReleaseGraph not implemented");
					retValue = Delegates.pvxReleaseGraph(p_graph);
					LogCommand("vxReleaseGraph", retValue, graph					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status VerifyGraph(Graph graph)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxVerifyGraph != null, "pvxVerifyGraph not implemented");
			retValue = Delegates.pvxVerifyGraph(graph);
			LogCommand("vxVerifyGraph", retValue, graph			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status ProcessGraph(Graph graph)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxProcessGraph != null, "pvxProcessGraph not implemented");
			retValue = Delegates.pvxProcessGraph(graph);
			LogCommand("vxProcessGraph", retValue, graph			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status ScheduleGraph(Graph graph)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxScheduleGraph != null, "pvxScheduleGraph not implemented");
			retValue = Delegates.pvxScheduleGraph(graph);
			LogCommand("vxScheduleGraph", retValue, graph			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status WaitGraph(Graph graph)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxWaitGraph != null, "pvxWaitGraph not implemented");
			retValue = Delegates.pvxWaitGraph(graph);
			LogCommand("vxWaitGraph", retValue, graph			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status QueryGraph(Graph graph, int attribute, IntPtr ptr, uint size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryGraph != null, "pvxQueryGraph not implemented");
					retValue = Delegates.pvxQueryGraph(graph, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryGraph", retValue, graph, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status SetGraphAttribute(Graph graph, int attribute, IntPtr ptr, uint size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxSetGraphAttribute != null, "pvxSetGraphAttribute not implemented");
					retValue = Delegates.pvxSetGraphAttribute(graph, attribute, ptr.ToPointer(), size);
					LogCommand("vxSetGraphAttribute", retValue, graph, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status AddParameterToGraph(Graph graph, Parameter parameter)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxAddParameterToGraph != null, "pvxAddParameterToGraph not implemented");
			retValue = Delegates.pvxAddParameterToGraph(graph, parameter);
			LogCommand("vxAddParameterToGraph", retValue, graph, parameter			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status SetGraphParameterByIndex(Graph graph, uint index, Reference value)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxSetGraphParameterByIndex != null, "pvxSetGraphParameterByIndex not implemented");
			retValue = Delegates.pvxSetGraphParameterByIndex(graph, index, value);
			LogCommand("vxSetGraphParameterByIndex", retValue, graph, index, value			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Parameter GetGraphParameterByIndex(Graph graph, uint index)
		{
			Parameter retValue;

			Debug.Assert(Delegates.pvxGetGraphParameterByIndex != null, "pvxGetGraphParameterByIndex not implemented");
			retValue = Delegates.pvxGetGraphParameterByIndex(graph, index);
			LogCommand("vxGetGraphParameterByIndex", retValue, graph, index			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static bool IsGraph(Graph graph)
		{
			bool retValue;

			Debug.Assert(Delegates.pvxIsGraphVerified != null, "pvxIsGraphVerified not implemented");
			retValue = Delegates.pvxIsGraphVerified(graph);
			LogCommand("vxIsGraphVerified", retValue, graph			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node CreateGenericNode(Graph graph, Kernel kernel)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxCreateGenericNode != null, "pvxCreateGenericNode not implemented");
			retValue = Delegates.pvxCreateGenericNode(graph, kernel);
			LogCommand("vxCreateGenericNode", retValue, graph, kernel			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status QueryNode(Node node, int attribute, IntPtr ptr, uint size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryNode != null, "pvxQueryNode not implemented");
					retValue = Delegates.pvxQueryNode(node, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryNode", retValue, node, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status SetNodeAttribute(Node node, int attribute, IntPtr ptr, uint size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxSetNodeAttribute != null, "pvxSetNodeAttribute not implemented");
					retValue = Delegates.pvxSetNodeAttribute(node, attribute, ptr.ToPointer(), size);
					LogCommand("vxSetNodeAttribute", retValue, node, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status ReleaseNode(params Node[] node)
		{
			Status retValue;

			unsafe {
				fixed (Node* p_node = node)
				{
					Debug.Assert(Delegates.pvxReleaseNode != null, "pvxReleaseNode not implemented");
					retValue = Delegates.pvxReleaseNode(p_node);
					LogCommand("vxReleaseNode", retValue, node					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status RemoveNode(Node[] node)
		{
			Status retValue;

			unsafe {
				fixed (Node* p_node = node)
				{
					Debug.Assert(Delegates.pvxRemoveNode != null, "pvxRemoveNode not implemented");
					retValue = Delegates.pvxRemoveNode(p_node);
					LogCommand("vxRemoveNode", retValue, node					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status AssignNodeCallback(Node node, NodeCompleteCallback callback)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxAssignNodeCallback != null, "pvxAssignNodeCallback not implemented");
			retValue = Delegates.pvxAssignNodeCallback(node, callback);
			LogCommand("vxAssignNodeCallback", retValue, node, callback			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static NodeCompleteCallback RetrieveNodeCallback(Node node)
		{
			NodeCompleteCallback retValue;

			Debug.Assert(Delegates.pvxRetrieveNodeCallback != null, "pvxRetrieveNodeCallback not implemented");
			retValue = Delegates.pvxRetrieveNodeCallback(node);
			LogCommand("vxRetrieveNodeCallback", retValue, node			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status SetNodeTarget(Node node, int target_enum, string target_string)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxSetNodeTarget != null, "pvxSetNodeTarget not implemented");
			retValue = Delegates.pvxSetNodeTarget(node, target_enum, target_string);
			LogCommand("vxSetNodeTarget", retValue, node, target_enum, target_string			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status ReplicateNode(Graph graph, Node first_node, bool[] replicate, uint number_of_parameters)
		{
			Status retValue;

			unsafe {
				fixed (bool* p_replicate = replicate)
				{
					Debug.Assert(Delegates.pvxReplicateNode != null, "pvxReplicateNode not implemented");
					retValue = Delegates.pvxReplicateNode(graph, first_node, p_replicate, number_of_parameters);
					LogCommand("vxReplicateNode", retValue, graph, first_node, replicate, number_of_parameters					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Parameter GetParameterByIndex(Node node, uint index)
		{
			Parameter retValue;

			Debug.Assert(Delegates.pvxGetParameterByIndex != null, "pvxGetParameterByIndex not implemented");
			retValue = Delegates.pvxGetParameterByIndex(node, index);
			LogCommand("vxGetParameterByIndex", retValue, node, index			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status ReleaseParameter(params Parameter[] param)
		{
			Status retValue;

			unsafe {
				fixed (Parameter* p_param = param)
				{
					Debug.Assert(Delegates.pvxReleaseParameter != null, "pvxReleaseParameter not implemented");
					retValue = Delegates.pvxReleaseParameter(p_param);
					LogCommand("vxReleaseParameter", retValue, param					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status SetParameterByIndex(Node node, uint index, Reference value)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxSetParameterByIndex != null, "pvxSetParameterByIndex not implemented");
			retValue = Delegates.pvxSetParameterByIndex(node, index, value);
			LogCommand("vxSetParameterByIndex", retValue, node, index, value			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status SetParameterByReference(Parameter parameter, Reference value)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxSetParameterByReference != null, "pvxSetParameterByReference not implemented");
			retValue = Delegates.pvxSetParameterByReference(parameter, value);
			LogCommand("vxSetParameterByReference", retValue, parameter, value			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status QueryParameter(Parameter parameter, int attribute, IntPtr ptr, uint size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryParameter != null, "pvxQueryParameter not implemented");
					retValue = Delegates.pvxQueryParameter(parameter, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryParameter", retValue, parameter, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Scalar CreateScalar(Context context, int data_type, IntPtr ptr)
		{
			Scalar retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxCreateScalar != null, "pvxCreateScalar not implemented");
					retValue = Delegates.pvxCreateScalar(context, data_type, ptr.ToPointer());
					LogCommand("vxCreateScalar", retValue, context, data_type, ptr					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status ReleaseScalar(params Scalar[] scalar)
		{
			Status retValue;

			unsafe {
				fixed (Scalar* p_scalar = scalar)
				{
					Debug.Assert(Delegates.pvxReleaseScalar != null, "pvxReleaseScalar not implemented");
					retValue = Delegates.pvxReleaseScalar(p_scalar);
					LogCommand("vxReleaseScalar", retValue, scalar					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status QueryScalar(Scalar scalar, int attribute, IntPtr ptr, uint size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryScalar != null, "pvxQueryScalar not implemented");
					retValue = Delegates.pvxQueryScalar(scalar, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryScalar", retValue, scalar, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status CopyScalar(Scalar scalar, IntPtr user_ptr, int usage, int user_mem_type)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxCopyScalar != null, "pvxCopyScalar not implemented");
					retValue = Delegates.pvxCopyScalar(scalar, user_ptr.ToPointer(), usage, user_mem_type);
					LogCommand("vxCopyScalar", retValue, scalar, user_ptr, usage, user_mem_type					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status QueryReference(Reference @ref, int attribute, IntPtr ptr, uint size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryReference != null, "pvxQueryReference not implemented");
					retValue = Delegates.pvxQueryReference(@ref, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryReference", retValue, @ref, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status ReleaseReference(params Reference[] ref_ptr)
		{
			Status retValue;

			unsafe {
				fixed (Reference* p_ref_ptr = ref_ptr)
				{
					Debug.Assert(Delegates.pvxReleaseReference != null, "pvxReleaseReference not implemented");
					retValue = Delegates.pvxReleaseReference(p_ref_ptr);
					LogCommand("vxReleaseReference", retValue, ref_ptr					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status RetainReference(Reference @ref)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxRetainReference != null, "pvxRetainReference not implemented");
			retValue = Delegates.pvxRetainReference(@ref);
			LogCommand("vxRetainReference", retValue, @ref			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status SetReferenceName(Reference @ref, string name)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxSetReferenceName != null, "pvxSetReferenceName not implemented");
			retValue = Delegates.pvxSetReferenceName(@ref, name);
			LogCommand("vxSetReferenceName", retValue, @ref, name			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status QueryDelay(Delay delay, int attribute, IntPtr ptr, uint size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryDelay != null, "pvxQueryDelay not implemented");
					retValue = Delegates.pvxQueryDelay(delay, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryDelay", retValue, delay, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status ReleaseDelay(params Delay[] delay)
		{
			Status retValue;

			unsafe {
				fixed (Delay* p_delay = delay)
				{
					Debug.Assert(Delegates.pvxReleaseDelay != null, "pvxReleaseDelay not implemented");
					retValue = Delegates.pvxReleaseDelay(p_delay);
					LogCommand("vxReleaseDelay", retValue, delay					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Delay CreateDelay(Context context, Reference exemplar, uint num_slots)
		{
			Delay retValue;

			Debug.Assert(Delegates.pvxCreateDelay != null, "pvxCreateDelay not implemented");
			retValue = Delegates.pvxCreateDelay(context, exemplar, num_slots);
			LogCommand("vxCreateDelay", retValue, context, exemplar, num_slots			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Reference GetReferenceFromDelay(Delay delay, int index)
		{
			Reference retValue;

			Debug.Assert(Delegates.pvxGetReferenceFromDelay != null, "pvxGetReferenceFromDelay not implemented");
			retValue = Delegates.pvxGetReferenceFromDelay(delay, index);
			LogCommand("vxGetReferenceFromDelay", retValue, delay, index			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status AgeDelay(Delay delay)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxAgeDelay != null, "pvxAgeDelay not implemented");
			retValue = Delegates.pvxAgeDelay(delay);
			LogCommand("vxAgeDelay", retValue, delay			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status RegisterAutoAging(Graph graph, Delay delay)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxRegisterAutoAging != null, "pvxRegisterAutoAging not implemented");
			retValue = Delegates.pvxRegisterAutoAging(graph, delay);
			LogCommand("vxRegisterAutoAging", retValue, graph, delay			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static void AddLogEntry(Reference @ref, Status status, string message, Int32 vaArgs)
		{
			Debug.Assert(Delegates.pvxAddLogEntry != null, "pvxAddLogEntry not implemented");
			Delegates.pvxAddLogEntry(@ref, status, message, vaArgs);
			LogCommand("vxAddLogEntry", null, @ref, status, message, vaArgs			);
			DebugCheckErrors(null);
		}

		public static void RegisterLogCallback(Context context, LogCallback callback, bool reentrant)
		{
			Debug.Assert(Delegates.pvxRegisterLogCallback != null, "pvxRegisterLogCallback not implemented");
			Delegates.pvxRegisterLogCallback(context, callback, reentrant);
			LogCommand("vxRegisterLogCallback", null, context, callback, reentrant			);
			DebugCheckErrors(null);
		}

		public static Lut CreateLUT(Context context, int data_type, uint count)
		{
			Lut retValue;

			Debug.Assert(Delegates.pvxCreateLUT != null, "pvxCreateLUT not implemented");
			retValue = Delegates.pvxCreateLUT(context, data_type, count);
			LogCommand("vxCreateLUT", retValue, context, data_type, count			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status ReleaseLUT(params Lut[] lut)
		{
			Status retValue;

			unsafe {
				fixed (Lut* p_lut = lut)
				{
					Debug.Assert(Delegates.pvxReleaseLUT != null, "pvxReleaseLUT not implemented");
					retValue = Delegates.pvxReleaseLUT(p_lut);
					LogCommand("vxReleaseLUT", retValue, lut					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status QueryLUT(Lut lut, int attribute, IntPtr ptr, uint size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryLUT != null, "pvxQueryLUT not implemented");
					retValue = Delegates.pvxQueryLUT(lut, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryLUT", retValue, lut, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status CopyLUT(Lut lut, IntPtr user_ptr, int usage, int user_mem_type)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxCopyLUT != null, "pvxCopyLUT not implemented");
					retValue = Delegates.pvxCopyLUT(lut, user_ptr.ToPointer(), usage, user_mem_type);
					LogCommand("vxCopyLUT", retValue, lut, user_ptr, usage, user_mem_type					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status MapLUT(Lut lut, MapId[] map_id, IntPtr[] ptr, int usage, int mem_type, uint flags)
		{
			Status retValue;

			unsafe {
				fixed (MapId* p_map_id = map_id)
				fixed (IntPtr* p_ptr = ptr)
				{
					Debug.Assert(Delegates.pvxMapLUT != null, "pvxMapLUT not implemented");
					retValue = Delegates.pvxMapLUT(lut, p_map_id, p_ptr, usage, mem_type, flags);
					LogCommand("vxMapLUT", retValue, lut, map_id, ptr, usage, mem_type, flags					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status UnmapLUT(Lut lut, MapId map_id)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxUnmapLUT != null, "pvxUnmapLUT not implemented");
			retValue = Delegates.pvxUnmapLUT(lut, map_id);
			LogCommand("vxUnmapLUT", retValue, lut, map_id			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Distribution CreateDistribution(Context context, uint numBins, int offset, uint range)
		{
			Distribution retValue;

			Debug.Assert(Delegates.pvxCreateDistribution != null, "pvxCreateDistribution not implemented");
			retValue = Delegates.pvxCreateDistribution(context, numBins, offset, range);
			LogCommand("vxCreateDistribution", retValue, context, numBins, offset, range			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status ReleaseDistribution(params Distribution[] distribution)
		{
			Status retValue;

			unsafe {
				fixed (Distribution* p_distribution = distribution)
				{
					Debug.Assert(Delegates.pvxReleaseDistribution != null, "pvxReleaseDistribution not implemented");
					retValue = Delegates.pvxReleaseDistribution(p_distribution);
					LogCommand("vxReleaseDistribution", retValue, distribution					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status QueryDistribution(Distribution distribution, int attribute, IntPtr ptr, uint size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryDistribution != null, "pvxQueryDistribution not implemented");
					retValue = Delegates.pvxQueryDistribution(distribution, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryDistribution", retValue, distribution, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status CopyDistribution(Distribution distribution, IntPtr user_ptr, int usage, int user_mem_type)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxCopyDistribution != null, "pvxCopyDistribution not implemented");
					retValue = Delegates.pvxCopyDistribution(distribution, user_ptr.ToPointer(), usage, user_mem_type);
					LogCommand("vxCopyDistribution", retValue, distribution, user_ptr, usage, user_mem_type					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status MapDistribution(Distribution distribution, MapId[] map_id, IntPtr[] ptr, int usage, int mem_type, uint flags)
		{
			Status retValue;

			unsafe {
				fixed (MapId* p_map_id = map_id)
				fixed (IntPtr* p_ptr = ptr)
				{
					Debug.Assert(Delegates.pvxMapDistribution != null, "pvxMapDistribution not implemented");
					retValue = Delegates.pvxMapDistribution(distribution, p_map_id, p_ptr, usage, mem_type, flags);
					LogCommand("vxMapDistribution", retValue, distribution, map_id, ptr, usage, mem_type, flags					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status UnmapDistribution(Distribution distribution, MapId map_id)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxUnmapDistribution != null, "pvxUnmapDistribution not implemented");
			retValue = Delegates.pvxUnmapDistribution(distribution, map_id);
			LogCommand("vxUnmapDistribution", retValue, distribution, map_id			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Threshold CreateThreshold(Context c, int thresh_type, int data_type)
		{
			Threshold retValue;

			Debug.Assert(Delegates.pvxCreateThreshold != null, "pvxCreateThreshold not implemented");
			retValue = Delegates.pvxCreateThreshold(c, thresh_type, data_type);
			LogCommand("vxCreateThreshold", retValue, c, thresh_type, data_type			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status ReleaseThreshold(params Threshold[] thresh)
		{
			Status retValue;

			unsafe {
				fixed (Threshold* p_thresh = thresh)
				{
					Debug.Assert(Delegates.pvxReleaseThreshold != null, "pvxReleaseThreshold not implemented");
					retValue = Delegates.pvxReleaseThreshold(p_thresh);
					LogCommand("vxReleaseThreshold", retValue, thresh					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status SetThresholdAttribute(Threshold thresh, int attribute, IntPtr ptr, uint size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxSetThresholdAttribute != null, "pvxSetThresholdAttribute not implemented");
					retValue = Delegates.pvxSetThresholdAttribute(thresh, attribute, ptr.ToPointer(), size);
					LogCommand("vxSetThresholdAttribute", retValue, thresh, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status QueryThreshold(Threshold thresh, int attribute, IntPtr ptr, uint size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryThreshold != null, "pvxQueryThreshold not implemented");
					retValue = Delegates.pvxQueryThreshold(thresh, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryThreshold", retValue, thresh, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Matrix CreateMatrix(Context c, int data_type, uint columns, uint rows)
		{
			Matrix retValue;

			Debug.Assert(Delegates.pvxCreateMatrix != null, "pvxCreateMatrix not implemented");
			retValue = Delegates.pvxCreateMatrix(c, data_type, columns, rows);
			LogCommand("vxCreateMatrix", retValue, c, data_type, columns, rows			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status ReleaseMatrix(params Matrix[] mat)
		{
			Status retValue;

			unsafe {
				fixed (Matrix* p_mat = mat)
				{
					Debug.Assert(Delegates.pvxReleaseMatrix != null, "pvxReleaseMatrix not implemented");
					retValue = Delegates.pvxReleaseMatrix(p_mat);
					LogCommand("vxReleaseMatrix", retValue, mat					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status QueryMatrix(Matrix mat, int attribute, IntPtr ptr, uint size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryMatrix != null, "pvxQueryMatrix not implemented");
					retValue = Delegates.pvxQueryMatrix(mat, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryMatrix", retValue, mat, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status CopyMatrix(Matrix matrix, IntPtr user_ptr, int usage, int user_mem_type)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxCopyMatrix != null, "pvxCopyMatrix not implemented");
					retValue = Delegates.pvxCopyMatrix(matrix, user_ptr.ToPointer(), usage, user_mem_type);
					LogCommand("vxCopyMatrix", retValue, matrix, user_ptr, usage, user_mem_type					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Matrix CreateMatrixFromPattern(Context context, int pattern, uint columns, uint rows)
		{
			Matrix retValue;

			Debug.Assert(Delegates.pvxCreateMatrixFromPattern != null, "pvxCreateMatrixFromPattern not implemented");
			retValue = Delegates.pvxCreateMatrixFromPattern(context, pattern, columns, rows);
			LogCommand("vxCreateMatrixFromPattern", retValue, context, pattern, columns, rows			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Convolution CreateConvolution(Context context, uint columns, uint rows)
		{
			Convolution retValue;

			Debug.Assert(Delegates.pvxCreateConvolution != null, "pvxCreateConvolution not implemented");
			retValue = Delegates.pvxCreateConvolution(context, columns, rows);
			LogCommand("vxCreateConvolution", retValue, context, columns, rows			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status ReleaseConvolution(params Convolution[] conv)
		{
			Status retValue;

			unsafe {
				fixed (Convolution* p_conv = conv)
				{
					Debug.Assert(Delegates.pvxReleaseConvolution != null, "pvxReleaseConvolution not implemented");
					retValue = Delegates.pvxReleaseConvolution(p_conv);
					LogCommand("vxReleaseConvolution", retValue, conv					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status QueryConvolution(Convolution conv, int attribute, IntPtr ptr, uint size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryConvolution != null, "pvxQueryConvolution not implemented");
					retValue = Delegates.pvxQueryConvolution(conv, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryConvolution", retValue, conv, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status SetConvolutionAttribute(Convolution conv, int attribute, IntPtr ptr, uint size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxSetConvolutionAttribute != null, "pvxSetConvolutionAttribute not implemented");
					retValue = Delegates.pvxSetConvolutionAttribute(conv, attribute, ptr.ToPointer(), size);
					LogCommand("vxSetConvolutionAttribute", retValue, conv, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status CopyConvolutionCoefficients(Convolution conv, IntPtr user_ptr, int usage, int user_mem_type)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxCopyConvolutionCoefficients != null, "pvxCopyConvolutionCoefficients not implemented");
					retValue = Delegates.pvxCopyConvolutionCoefficients(conv, user_ptr.ToPointer(), usage, user_mem_type);
					LogCommand("vxCopyConvolutionCoefficients", retValue, conv, user_ptr, usage, user_mem_type					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Pyramid CreatePyramid(Context context, uint levels, float scale, uint width, uint height, DfImage format)
		{
			Pyramid retValue;

			Debug.Assert(Delegates.pvxCreatePyramid != null, "pvxCreatePyramid not implemented");
			retValue = Delegates.pvxCreatePyramid(context, levels, scale, width, height, format);
			LogCommand("vxCreatePyramid", retValue, context, levels, scale, width, height, format			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Pyramid CreateVirtualPyramid(Graph graph, uint levels, float scale, uint width, uint height, DfImage format)
		{
			Pyramid retValue;

			Debug.Assert(Delegates.pvxCreateVirtualPyramid != null, "pvxCreateVirtualPyramid not implemented");
			retValue = Delegates.pvxCreateVirtualPyramid(graph, levels, scale, width, height, format);
			LogCommand("vxCreateVirtualPyramid", retValue, graph, levels, scale, width, height, format			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status ReleasePyramid(params Pyramid[] pyr)
		{
			Status retValue;

			unsafe {
				fixed (Pyramid* p_pyr = pyr)
				{
					Debug.Assert(Delegates.pvxReleasePyramid != null, "pvxReleasePyramid not implemented");
					retValue = Delegates.pvxReleasePyramid(p_pyr);
					LogCommand("vxReleasePyramid", retValue, pyr					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status QueryPyramid(Pyramid pyr, int attribute, IntPtr ptr, uint size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryPyramid != null, "pvxQueryPyramid not implemented");
					retValue = Delegates.pvxQueryPyramid(pyr, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryPyramid", retValue, pyr, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Image GetPyramidLevel(Pyramid pyr, uint index)
		{
			Image retValue;

			Debug.Assert(Delegates.pvxGetPyramidLevel != null, "pvxGetPyramidLevel not implemented");
			retValue = Delegates.pvxGetPyramidLevel(pyr, index);
			LogCommand("vxGetPyramidLevel", retValue, pyr, index			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Remap CreateRemap(Context context, uint src_width, uint src_height, uint dst_width, uint dst_height)
		{
			Remap retValue;

			Debug.Assert(Delegates.pvxCreateRemap != null, "pvxCreateRemap not implemented");
			retValue = Delegates.pvxCreateRemap(context, src_width, src_height, dst_width, dst_height);
			LogCommand("vxCreateRemap", retValue, context, src_width, src_height, dst_width, dst_height			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status ReleaseRemap(params Remap[] table)
		{
			Status retValue;

			unsafe {
				fixed (Remap* p_table = table)
				{
					Debug.Assert(Delegates.pvxReleaseRemap != null, "pvxReleaseRemap not implemented");
					retValue = Delegates.pvxReleaseRemap(p_table);
					LogCommand("vxReleaseRemap", retValue, table					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status SetRemapPoint(Remap table, uint dst_x, uint dst_y, float src_x, float src_y)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxSetRemapPoint != null, "pvxSetRemapPoint not implemented");
			retValue = Delegates.pvxSetRemapPoint(table, dst_x, dst_y, src_x, src_y);
			LogCommand("vxSetRemapPoint", retValue, table, dst_x, dst_y, src_x, src_y			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status GetRemapPoint(Remap table, uint dst_x, uint dst_y, [Out] float[] src_x, [Out] float[] src_y)
		{
			Status retValue;

			unsafe {
				fixed (float* p_src_x = src_x)
				fixed (float* p_src_y = src_y)
				{
					Debug.Assert(Delegates.pvxGetRemapPoint != null, "pvxGetRemapPoint not implemented");
					retValue = Delegates.pvxGetRemapPoint(table, dst_x, dst_y, p_src_x, p_src_y);
					LogCommand("vxGetRemapPoint", retValue, table, dst_x, dst_y, src_x, src_y					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status QueryRemap(Remap table, int attribute, IntPtr ptr, uint size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryRemap != null, "pvxQueryRemap not implemented");
					retValue = Delegates.pvxQueryRemap(table, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryRemap", retValue, table, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Array CreateArray(Context context, int item_type, uint capacity)
		{
			Array retValue;

			Debug.Assert(Delegates.pvxCreateArray != null, "pvxCreateArray not implemented");
			retValue = Delegates.pvxCreateArray(context, item_type, capacity);
			LogCommand("vxCreateArray", retValue, context, item_type, capacity			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Array CreateVirtualArray(Graph graph, int item_type, uint capacity)
		{
			Array retValue;

			Debug.Assert(Delegates.pvxCreateVirtualArray != null, "pvxCreateVirtualArray not implemented");
			retValue = Delegates.pvxCreateVirtualArray(graph, item_type, capacity);
			LogCommand("vxCreateVirtualArray", retValue, graph, item_type, capacity			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status ReleaseArray(params Array[] arr)
		{
			Status retValue;

			unsafe {
				fixed (Array* p_arr = arr)
				{
					Debug.Assert(Delegates.pvxReleaseArray != null, "pvxReleaseArray not implemented");
					retValue = Delegates.pvxReleaseArray(p_arr);
					LogCommand("vxReleaseArray", retValue, arr					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status QueryArray(Array arr, int attribute, IntPtr ptr, uint size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryArray != null, "pvxQueryArray not implemented");
					retValue = Delegates.pvxQueryArray(arr, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryArray", retValue, arr, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status AddArrayItems(Array arr, uint count, IntPtr ptr, uint stride)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxAddArrayItems != null, "pvxAddArrayItems not implemented");
					retValue = Delegates.pvxAddArrayItems(arr, count, ptr.ToPointer(), stride);
					LogCommand("vxAddArrayItems", retValue, arr, count, ptr, stride					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status TruncateArray(Array arr, uint new_num_items)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxTruncateArray != null, "pvxTruncateArray not implemented");
			retValue = Delegates.pvxTruncateArray(arr, new_num_items);
			LogCommand("vxTruncateArray", retValue, arr, new_num_items			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status CopyArrayRange(Array array, uint range_start, uint range_end, uint user_stride, IntPtr user_ptr, int usage, int user_mem_type)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxCopyArrayRange != null, "pvxCopyArrayRange not implemented");
					retValue = Delegates.pvxCopyArrayRange(array, range_start, range_end, user_stride, user_ptr.ToPointer(), usage, user_mem_type);
					LogCommand("vxCopyArrayRange", retValue, array, range_start, range_end, user_stride, user_ptr, usage, user_mem_type					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status MapArrayRange(Array array, uint range_start, uint range_end, MapId[] map_id, uint[] stride, IntPtr[] ptr, int usage, int mem_type, uint flags)
		{
			Status retValue;

			unsafe {
				fixed (MapId* p_map_id = map_id)
				fixed (uint* p_stride = stride)
				fixed (IntPtr* p_ptr = ptr)
				{
					Debug.Assert(Delegates.pvxMapArrayRange != null, "pvxMapArrayRange not implemented");
					retValue = Delegates.pvxMapArrayRange(array, range_start, range_end, p_map_id, p_stride, p_ptr, usage, mem_type, flags);
					LogCommand("vxMapArrayRange", retValue, array, range_start, range_end, map_id, stride, ptr, usage, mem_type, flags					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status UnmapArrayRange(Array array, MapId map_id)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxUnmapArrayRange != null, "pvxUnmapArrayRange not implemented");
			retValue = Delegates.pvxUnmapArrayRange(array, map_id);
			LogCommand("vxUnmapArrayRange", retValue, array, map_id			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static ObjectArray CreateObjectArray(Context context, Reference exemplar, uint count)
		{
			ObjectArray retValue;

			Debug.Assert(Delegates.pvxCreateObjectArray != null, "pvxCreateObjectArray not implemented");
			retValue = Delegates.pvxCreateObjectArray(context, exemplar, count);
			LogCommand("vxCreateObjectArray", retValue, context, exemplar, count			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static ObjectArray CreateVirtualObjectArray(Graph graph, Reference exemplar, uint count)
		{
			ObjectArray retValue;

			Debug.Assert(Delegates.pvxCreateVirtualObjectArray != null, "pvxCreateVirtualObjectArray not implemented");
			retValue = Delegates.pvxCreateVirtualObjectArray(graph, exemplar, count);
			LogCommand("vxCreateVirtualObjectArray", retValue, graph, exemplar, count			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Reference GetObjectArrayItem(ObjectArray arr, uint index)
		{
			Reference retValue;

			Debug.Assert(Delegates.pvxGetObjectArrayItem != null, "pvxGetObjectArrayItem not implemented");
			retValue = Delegates.pvxGetObjectArrayItem(arr, index);
			LogCommand("vxGetObjectArrayItem", retValue, arr, index			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status ReleaseObjectArray(params ObjectArray[] arr)
		{
			Status retValue;

			unsafe {
				fixed (ObjectArray* p_arr = arr)
				{
					Debug.Assert(Delegates.pvxReleaseObjectArray != null, "pvxReleaseObjectArray not implemented");
					retValue = Delegates.pvxReleaseObjectArray(p_arr);
					LogCommand("vxReleaseObjectArray", retValue, arr					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status QueryObjectArray(ObjectArray arr, int attribute, IntPtr ptr, uint size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxQueryObjectArray != null, "pvxQueryObjectArray not implemented");
					retValue = Delegates.pvxQueryObjectArray(arr, attribute, ptr.ToPointer(), size);
					LogCommand("vxQueryObjectArray", retValue, arr, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status SetMetaFormatAttribute(MetaFormat meta, int attribute, IntPtr ptr, uint size)
		{
			Status retValue;

			unsafe {
				{
					Debug.Assert(Delegates.pvxSetMetaFormatAttribute != null, "pvxSetMetaFormatAttribute not implemented");
					retValue = Delegates.pvxSetMetaFormatAttribute(meta, attribute, ptr.ToPointer(), size);
					LogCommand("vxSetMetaFormatAttribute", retValue, meta, attribute, ptr, size					);
				}
			}
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Status SetMetaFormatFromReference(MetaFormat meta, Reference exemplar)
		{
			Status retValue;

			Debug.Assert(Delegates.pvxSetMetaFormatFromReference != null, "pvxSetMetaFormatFromReference not implemented");
			retValue = Delegates.pvxSetMetaFormatFromReference(meta, exemplar);
			LogCommand("vxSetMetaFormatFromReference", retValue, meta, exemplar			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node ColorConvertNode(Graph graph, Image input, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxColorConvertNode != null, "pvxColorConvertNode not implemented");
			retValue = Delegates.pvxColorConvertNode(graph, input, output);
			LogCommand("vxColorConvertNode", retValue, graph, input, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node ChannelExtractNode(Graph graph, Image input, int channel, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxChannelExtractNode != null, "pvxChannelExtractNode not implemented");
			retValue = Delegates.pvxChannelExtractNode(graph, input, channel, output);
			LogCommand("vxChannelExtractNode", retValue, graph, input, channel, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node ChannelCombineNode(Graph graph, Image plane0, Image plane1, Image plane2, Image plane3, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxChannelCombineNode != null, "pvxChannelCombineNode not implemented");
			retValue = Delegates.pvxChannelCombineNode(graph, plane0, plane1, plane2, plane3, output);
			LogCommand("vxChannelCombineNode", retValue, graph, plane0, plane1, plane2, plane3, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node PhaseNode(Graph graph, Image grad_x, Image grad_y, Image orientation)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxPhaseNode != null, "pvxPhaseNode not implemented");
			retValue = Delegates.pvxPhaseNode(graph, grad_x, grad_y, orientation);
			LogCommand("vxPhaseNode", retValue, graph, grad_x, grad_y, orientation			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node Sobel3x3Node(Graph graph, Image input, Image output_x, Image output_y)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxSobel3x3Node != null, "pvxSobel3x3Node not implemented");
			retValue = Delegates.pvxSobel3x3Node(graph, input, output_x, output_y);
			LogCommand("vxSobel3x3Node", retValue, graph, input, output_x, output_y			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node MagnitudeNode(Graph graph, Image grad_x, Image grad_y, Image mag)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxMagnitudeNode != null, "pvxMagnitudeNode not implemented");
			retValue = Delegates.pvxMagnitudeNode(graph, grad_x, grad_y, mag);
			LogCommand("vxMagnitudeNode", retValue, graph, grad_x, grad_y, mag			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node ScaleImageNode(Graph graph, Image src, Image dst, int type)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxScaleImageNode != null, "pvxScaleImageNode not implemented");
			retValue = Delegates.pvxScaleImageNode(graph, src, dst, type);
			LogCommand("vxScaleImageNode", retValue, graph, src, dst, type			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node TableLookupNode(Graph graph, Image input, Lut lut, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxTableLookupNode != null, "pvxTableLookupNode not implemented");
			retValue = Delegates.pvxTableLookupNode(graph, input, lut, output);
			LogCommand("vxTableLookupNode", retValue, graph, input, lut, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node HistogramNode(Graph graph, Image input, Distribution distribution)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxHistogramNode != null, "pvxHistogramNode not implemented");
			retValue = Delegates.pvxHistogramNode(graph, input, distribution);
			LogCommand("vxHistogramNode", retValue, graph, input, distribution			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node EqualizeHistNode(Graph graph, Image input, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxEqualizeHistNode != null, "pvxEqualizeHistNode not implemented");
			retValue = Delegates.pvxEqualizeHistNode(graph, input, output);
			LogCommand("vxEqualizeHistNode", retValue, graph, input, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node AbsDiffNode(Graph graph, Image in1, Image in2, Image @out)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxAbsDiffNode != null, "pvxAbsDiffNode not implemented");
			retValue = Delegates.pvxAbsDiffNode(graph, in1, in2, @out);
			LogCommand("vxAbsDiffNode", retValue, graph, in1, in2, @out			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node MeanStdDevNode(Graph graph, Image input, Scalar mean, Scalar stddev)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxMeanStdDevNode != null, "pvxMeanStdDevNode not implemented");
			retValue = Delegates.pvxMeanStdDevNode(graph, input, mean, stddev);
			LogCommand("vxMeanStdDevNode", retValue, graph, input, mean, stddev			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node ThresholdNode(Graph graph, Image input, Threshold thresh, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxThresholdNode != null, "pvxThresholdNode not implemented");
			retValue = Delegates.pvxThresholdNode(graph, input, thresh, output);
			LogCommand("vxThresholdNode", retValue, graph, input, thresh, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node IntegralImageNode(Graph graph, Image input, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxIntegralImageNode != null, "pvxIntegralImageNode not implemented");
			retValue = Delegates.pvxIntegralImageNode(graph, input, output);
			LogCommand("vxIntegralImageNode", retValue, graph, input, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node Erode3x3Node(Graph graph, Image input, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxErode3x3Node != null, "pvxErode3x3Node not implemented");
			retValue = Delegates.pvxErode3x3Node(graph, input, output);
			LogCommand("vxErode3x3Node", retValue, graph, input, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node Dilate3x3Node(Graph graph, Image input, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxDilate3x3Node != null, "pvxDilate3x3Node not implemented");
			retValue = Delegates.pvxDilate3x3Node(graph, input, output);
			LogCommand("vxDilate3x3Node", retValue, graph, input, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node Median3x3Node(Graph graph, Image input, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxMedian3x3Node != null, "pvxMedian3x3Node not implemented");
			retValue = Delegates.pvxMedian3x3Node(graph, input, output);
			LogCommand("vxMedian3x3Node", retValue, graph, input, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node Box3x3Node(Graph graph, Image input, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxBox3x3Node != null, "pvxBox3x3Node not implemented");
			retValue = Delegates.pvxBox3x3Node(graph, input, output);
			LogCommand("vxBox3x3Node", retValue, graph, input, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node Gaussian3x3Node(Graph graph, Image input, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxGaussian3x3Node != null, "pvxGaussian3x3Node not implemented");
			retValue = Delegates.pvxGaussian3x3Node(graph, input, output);
			LogCommand("vxGaussian3x3Node", retValue, graph, input, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node NonLinearFilterNode(Graph graph, int function, Image input, Matrix mask, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxNonLinearFilterNode != null, "pvxNonLinearFilterNode not implemented");
			retValue = Delegates.pvxNonLinearFilterNode(graph, function, input, mask, output);
			LogCommand("vxNonLinearFilterNode", retValue, graph, function, input, mask, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node ConvolveNode(Graph graph, Image input, Convolution conv, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxConvolveNode != null, "pvxConvolveNode not implemented");
			retValue = Delegates.pvxConvolveNode(graph, input, conv, output);
			LogCommand("vxConvolveNode", retValue, graph, input, conv, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node GaussianPyramidNode(Graph graph, Image input, Pyramid gaussian)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxGaussianPyramidNode != null, "pvxGaussianPyramidNode not implemented");
			retValue = Delegates.pvxGaussianPyramidNode(graph, input, gaussian);
			LogCommand("vxGaussianPyramidNode", retValue, graph, input, gaussian			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node LaplacianPyramidNode(Graph graph, Image input, Pyramid laplacian, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxLaplacianPyramidNode != null, "pvxLaplacianPyramidNode not implemented");
			retValue = Delegates.pvxLaplacianPyramidNode(graph, input, laplacian, output);
			LogCommand("vxLaplacianPyramidNode", retValue, graph, input, laplacian, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node LaplacianReconstructNode(Graph graph, Pyramid laplacian, Image input, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxLaplacianReconstructNode != null, "pvxLaplacianReconstructNode not implemented");
			retValue = Delegates.pvxLaplacianReconstructNode(graph, laplacian, input, output);
			LogCommand("vxLaplacianReconstructNode", retValue, graph, laplacian, input, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node AccumulateImageNode(Graph graph, Image input, Image accum)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxAccumulateImageNode != null, "pvxAccumulateImageNode not implemented");
			retValue = Delegates.pvxAccumulateImageNode(graph, input, accum);
			LogCommand("vxAccumulateImageNode", retValue, graph, input, accum			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node AccumulateWeightedImageNode(Graph graph, Image input, Scalar alpha, Image accum)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxAccumulateWeightedImageNode != null, "pvxAccumulateWeightedImageNode not implemented");
			retValue = Delegates.pvxAccumulateWeightedImageNode(graph, input, alpha, accum);
			LogCommand("vxAccumulateWeightedImageNode", retValue, graph, input, alpha, accum			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node AccumulateSquareImageNode(Graph graph, Image input, Scalar shift, Image accum)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxAccumulateSquareImageNode != null, "pvxAccumulateSquareImageNode not implemented");
			retValue = Delegates.pvxAccumulateSquareImageNode(graph, input, shift, accum);
			LogCommand("vxAccumulateSquareImageNode", retValue, graph, input, shift, accum			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node MinMaxLocNode(Graph graph, Image input, Scalar minVal, Scalar maxVal, Array minLoc, Array maxLoc, Scalar minCount, Scalar maxCount)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxMinMaxLocNode != null, "pvxMinMaxLocNode not implemented");
			retValue = Delegates.pvxMinMaxLocNode(graph, input, minVal, maxVal, minLoc, maxLoc, minCount, maxCount);
			LogCommand("vxMinMaxLocNode", retValue, graph, input, minVal, maxVal, minLoc, maxLoc, minCount, maxCount			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node AndNode(Graph graph, Image in1, Image in2, Image @out)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxAndNode != null, "pvxAndNode not implemented");
			retValue = Delegates.pvxAndNode(graph, in1, in2, @out);
			LogCommand("vxAndNode", retValue, graph, in1, in2, @out			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node OrNode(Graph graph, Image in1, Image in2, Image @out)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxOrNode != null, "pvxOrNode not implemented");
			retValue = Delegates.pvxOrNode(graph, in1, in2, @out);
			LogCommand("vxOrNode", retValue, graph, in1, in2, @out			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node XorNode(Graph graph, Image in1, Image in2, Image @out)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxXorNode != null, "pvxXorNode not implemented");
			retValue = Delegates.pvxXorNode(graph, in1, in2, @out);
			LogCommand("vxXorNode", retValue, graph, in1, in2, @out			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node NotNode(Graph graph, Image input, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxNotNode != null, "pvxNotNode not implemented");
			retValue = Delegates.pvxNotNode(graph, input, output);
			LogCommand("vxNotNode", retValue, graph, input, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node MultiplyNode(Graph graph, Image in1, Image in2, Scalar scale, int overflow_policy, int rounding_policy, Image @out)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxMultiplyNode != null, "pvxMultiplyNode not implemented");
			retValue = Delegates.pvxMultiplyNode(graph, in1, in2, scale, overflow_policy, rounding_policy, @out);
			LogCommand("vxMultiplyNode", retValue, graph, in1, in2, scale, overflow_policy, rounding_policy, @out			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node AddNode(Graph graph, Image in1, Image in2, int policy, Image @out)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxAddNode != null, "pvxAddNode not implemented");
			retValue = Delegates.pvxAddNode(graph, in1, in2, policy, @out);
			LogCommand("vxAddNode", retValue, graph, in1, in2, policy, @out			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node SubtractNode(Graph graph, Image in1, Image in2, int policy, Image @out)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxSubtractNode != null, "pvxSubtractNode not implemented");
			retValue = Delegates.pvxSubtractNode(graph, in1, in2, policy, @out);
			LogCommand("vxSubtractNode", retValue, graph, in1, in2, policy, @out			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node ConvertDepthNode(Graph graph, Image input, Image output, int policy, Scalar shift)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxConvertDepthNode != null, "pvxConvertDepthNode not implemented");
			retValue = Delegates.pvxConvertDepthNode(graph, input, output, policy, shift);
			LogCommand("vxConvertDepthNode", retValue, graph, input, output, policy, shift			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node CannyEdgeDetectorNode(Graph graph, Image input, Threshold hyst, int gradient_size, int norm_type, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxCannyEdgeDetectorNode != null, "pvxCannyEdgeDetectorNode not implemented");
			retValue = Delegates.pvxCannyEdgeDetectorNode(graph, input, hyst, gradient_size, norm_type, output);
			LogCommand("vxCannyEdgeDetectorNode", retValue, graph, input, hyst, gradient_size, norm_type, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node WarpAffineNode(Graph graph, Image input, Matrix matrix, int type, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxWarpAffineNode != null, "pvxWarpAffineNode not implemented");
			retValue = Delegates.pvxWarpAffineNode(graph, input, matrix, type, output);
			LogCommand("vxWarpAffineNode", retValue, graph, input, matrix, type, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node WarpPerspectiveNode(Graph graph, Image input, Matrix matrix, int type, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxWarpPerspectiveNode != null, "pvxWarpPerspectiveNode not implemented");
			retValue = Delegates.pvxWarpPerspectiveNode(graph, input, matrix, type, output);
			LogCommand("vxWarpPerspectiveNode", retValue, graph, input, matrix, type, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node HarrisCornersNode(Graph graph, Image input, Scalar strength_thresh, Scalar min_distance, Scalar sensitivity, int gradient_size, int block_size, Array corners, Scalar num_corners)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxHarrisCornersNode != null, "pvxHarrisCornersNode not implemented");
			retValue = Delegates.pvxHarrisCornersNode(graph, input, strength_thresh, min_distance, sensitivity, gradient_size, block_size, corners, num_corners);
			LogCommand("vxHarrisCornersNode", retValue, graph, input, strength_thresh, min_distance, sensitivity, gradient_size, block_size, corners, num_corners			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node FastCornersNode(Graph graph, Image input, Scalar strength_thresh, bool nonmax_suppression, Array corners, Scalar num_corners)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxFastCornersNode != null, "pvxFastCornersNode not implemented");
			retValue = Delegates.pvxFastCornersNode(graph, input, strength_thresh, nonmax_suppression, corners, num_corners);
			LogCommand("vxFastCornersNode", retValue, graph, input, strength_thresh, nonmax_suppression, corners, num_corners			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node OpticalFlowPyrLKNode(Graph graph, Pyramid old_images, Pyramid new_images, Array old_points, Array new_points_estimates, Array new_points, int termination, Scalar epsilon, Scalar num_iterations, Scalar use_initial_estimate, uint window_dimension)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxOpticalFlowPyrLKNode != null, "pvxOpticalFlowPyrLKNode not implemented");
			retValue = Delegates.pvxOpticalFlowPyrLKNode(graph, old_images, new_images, old_points, new_points_estimates, new_points, termination, epsilon, num_iterations, use_initial_estimate, window_dimension);
			LogCommand("vxOpticalFlowPyrLKNode", retValue, graph, old_images, new_images, old_points, new_points_estimates, new_points, termination, epsilon, num_iterations, use_initial_estimate, window_dimension			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node RemapNode(Graph graph, Image input, Remap table, int policy, Image output)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxRemapNode != null, "pvxRemapNode not implemented");
			retValue = Delegates.pvxRemapNode(graph, input, table, policy, output);
			LogCommand("vxRemapNode", retValue, graph, input, table, policy, output			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		public static Node HalfScaleGaussianNode(Graph graph, Image input, Image output, int kernel_size)
		{
			Node retValue;

			Debug.Assert(Delegates.pvxHalfScaleGaussianNode != null, "pvxHalfScaleGaussianNode not implemented");
			retValue = Delegates.pvxHalfScaleGaussianNode(graph, input, output, kernel_size);
			LogCommand("vxHalfScaleGaussianNode", retValue, graph, input, output, kernel_size			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		internal unsafe static partial class Delegates
		{
			[SuppressUnmanagedCodeSecurity()]
			internal delegate Context vxCreateContext();

			internal static vxCreateContext pvxCreateContext;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxReleaseContext(Context* context);

			internal static vxReleaseContext pvxReleaseContext;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Context vxGetContext(Reference reference);

			internal static vxGetContext pvxGetContext;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxQueryContext(Context context, int attribute, void* ptr, uint size);

			internal static vxQueryContext pvxQueryContext;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxSetContextAttribute(Context context, int attribute, void* ptr, uint size);

			internal static vxSetContextAttribute pvxSetContextAttribute;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxHint(Reference reference, int hint, void* data, uint data_size);

			internal static vxHint pvxHint;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Status vxDirective(Reference reference, int directive);

			internal static vxDirective pvxDirective;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Status vxGetStatus(Reference reference);

			internal static vxGetStatus pvxGetStatus;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate int vxRegisterUserStruct(Context context, uint size);

			internal static vxRegisterUserStruct pvxRegisterUserStruct;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxAllocateUserKernelId(Context context, int* pKernelEnumId);

			internal static vxAllocateUserKernelId pvxAllocateUserKernelId;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxAllocateUserKernelLibraryId(Context context, int* pLibraryId);

			internal static vxAllocateUserKernelLibraryId pvxAllocateUserKernelLibraryId;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Status vxSetImmediateModeTarget(Context context, int target_enum, string target_string);

			internal static vxSetImmediateModeTarget pvxSetImmediateModeTarget;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Image vxCreateImage(Context context, uint width, uint height, DfImage color);

			internal static vxCreateImage pvxCreateImage;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Image vxCreateImageFromROI(Image img, Rectangle* rect);

			internal static vxCreateImageFromROI pvxCreateImageFromROI;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Image vxCreateUniformImage(Context context, uint width, uint height, DfImage color, PixelValue value);

			internal static vxCreateUniformImage pvxCreateUniformImage;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Image vxCreateVirtualImage(Graph graph, uint width, uint height, DfImage color);

			internal static vxCreateVirtualImage pvxCreateVirtualImage;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Image vxCreateImageFromHandle(Context context, DfImage color, ImagePatchAddressing* addrs, IntPtr* ptrs, int memory_type);

			internal static vxCreateImageFromHandle pvxCreateImageFromHandle;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxSwapImageHandle(Image image, IntPtr* new_ptrs, IntPtr* prev_ptrs, uint num_planes);

			internal static vxSwapImageHandle pvxSwapImageHandle;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxQueryImage(Image image, int attribute, void* ptr, uint size);

			internal static vxQueryImage pvxQueryImage;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxSetImageAttribute(Image image, int attribute, void* ptr, uint size);

			internal static vxSetImageAttribute pvxSetImageAttribute;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxReleaseImage(Image* image);

			internal static vxReleaseImage pvxReleaseImage;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate uint vxComputeImagePatchSize(Image image, Rectangle* rect, uint plane_index);

			internal static vxComputeImagePatchSize pvxComputeImagePatchSize;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxFormatImagePatchAddress1d(void* ptr, uint index, ImagePatchAddressing* addr);

			internal static vxFormatImagePatchAddress1d pvxFormatImagePatchAddress1d;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate IntPtr vxFormatImagePatchAddress2d(void* ptr, uint x, uint y, ImagePatchAddressing* addr);

			internal static vxFormatImagePatchAddress2d pvxFormatImagePatchAddress2d;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxGetValidRegionImage(Image image, Rectangle* rect);

			internal static vxGetValidRegionImage pvxGetValidRegionImage;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxCopyImagePatch(Image image, Rectangle* image_rect, uint image_plane_index, ImagePatchAddressing* user_addr, void* user_ptr, int usage, int user_mem_type);

			internal static vxCopyImagePatch pvxCopyImagePatch;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxMapImagePatch(Image image, Rectangle* rect, uint plane_index, MapId* map_id, ImagePatchAddressing* addr, IntPtr* ptr, int usage, int mem_type, uint flags);

			internal static vxMapImagePatch pvxMapImagePatch;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Status vxUnmapImagePatch(Image image, MapId map_id);

			internal static vxUnmapImagePatch pvxUnmapImagePatch;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Image vxCreateImageFromChannel(Image img, int channel);

			internal static vxCreateImageFromChannel pvxCreateImageFromChannel;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxSetImageValidRectangle(Image image, Rectangle* rect);

			internal static vxSetImageValidRectangle pvxSetImageValidRectangle;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Status vxLoadKernels(Context context, string module);

			internal static vxLoadKernels pvxLoadKernels;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Status vxUnloadKernels(Context context, string module);

			internal static vxUnloadKernels pvxUnloadKernels;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Kernel vxGetKernelByName(Context context, string name);

			internal static vxGetKernelByName pvxGetKernelByName;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Kernel vxGetKernelByEnum(Context context, int kernel);

			internal static vxGetKernelByEnum pvxGetKernelByEnum;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxQueryKernel(Kernel kernel, int attribute, void* ptr, uint size);

			internal static vxQueryKernel pvxQueryKernel;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxReleaseKernel(Kernel* kernel);

			internal static vxReleaseKernel pvxReleaseKernel;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Kernel vxAddUserKernel(Context context, string name, int enumeration, KernelCallback func_ptr, uint numParams, KernelValidateCallbackCallback validate, KernelInitializeCallback init, KernelDeinitializeCallback deinit);

			internal static vxAddUserKernel pvxAddUserKernel;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Status vxFinalizeKernel(Kernel kernel);

			internal static vxFinalizeKernel pvxFinalizeKernel;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Status vxAddParameterToKernel(Kernel kernel, uint index, int dir, int data_type, int state);

			internal static vxAddParameterToKernel pvxAddParameterToKernel;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Status vxRemoveKernel(Kernel kernel);

			internal static vxRemoveKernel pvxRemoveKernel;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxSetKernelAttribute(Kernel kernel, int attribute, void* ptr, uint size);

			internal static vxSetKernelAttribute pvxSetKernelAttribute;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Parameter vxGetKernelParameterByIndex(Kernel kernel, uint index);

			internal static vxGetKernelParameterByIndex pvxGetKernelParameterByIndex;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Graph vxCreateGraph(Context context);

			internal static vxCreateGraph pvxCreateGraph;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxReleaseGraph(Graph* graph);

			internal static vxReleaseGraph pvxReleaseGraph;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Status vxVerifyGraph(Graph graph);

			internal static vxVerifyGraph pvxVerifyGraph;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Status vxProcessGraph(Graph graph);

			internal static vxProcessGraph pvxProcessGraph;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Status vxScheduleGraph(Graph graph);

			internal static vxScheduleGraph pvxScheduleGraph;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Status vxWaitGraph(Graph graph);

			internal static vxWaitGraph pvxWaitGraph;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxQueryGraph(Graph graph, int attribute, void* ptr, uint size);

			internal static vxQueryGraph pvxQueryGraph;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxSetGraphAttribute(Graph graph, int attribute, void* ptr, uint size);

			internal static vxSetGraphAttribute pvxSetGraphAttribute;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Status vxAddParameterToGraph(Graph graph, Parameter parameter);

			internal static vxAddParameterToGraph pvxAddParameterToGraph;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Status vxSetGraphParameterByIndex(Graph graph, uint index, Reference value);

			internal static vxSetGraphParameterByIndex pvxSetGraphParameterByIndex;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Parameter vxGetGraphParameterByIndex(Graph graph, uint index);

			internal static vxGetGraphParameterByIndex pvxGetGraphParameterByIndex;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate bool vxIsGraphVerified(Graph graph);

			internal static vxIsGraphVerified pvxIsGraphVerified;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxCreateGenericNode(Graph graph, Kernel kernel);

			internal static vxCreateGenericNode pvxCreateGenericNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxQueryNode(Node node, int attribute, void* ptr, uint size);

			internal static vxQueryNode pvxQueryNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxSetNodeAttribute(Node node, int attribute, void* ptr, uint size);

			internal static vxSetNodeAttribute pvxSetNodeAttribute;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxReleaseNode(Node* node);

			internal static vxReleaseNode pvxReleaseNode;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxRemoveNode(Node* node);

			internal static vxRemoveNode pvxRemoveNode;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Status vxAssignNodeCallback(Node node, NodeCompleteCallback callback);

			internal static vxAssignNodeCallback pvxAssignNodeCallback;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate NodeCompleteCallback vxRetrieveNodeCallback(Node node);

			internal static vxRetrieveNodeCallback pvxRetrieveNodeCallback;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Status vxSetNodeTarget(Node node, int target_enum, string target_string);

			internal static vxSetNodeTarget pvxSetNodeTarget;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxReplicateNode(Graph graph, Node first_node, bool* replicate, uint number_of_parameters);

			internal static vxReplicateNode pvxReplicateNode;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Parameter vxGetParameterByIndex(Node node, uint index);

			internal static vxGetParameterByIndex pvxGetParameterByIndex;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxReleaseParameter(Parameter* param);

			internal static vxReleaseParameter pvxReleaseParameter;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Status vxSetParameterByIndex(Node node, uint index, Reference value);

			internal static vxSetParameterByIndex pvxSetParameterByIndex;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Status vxSetParameterByReference(Parameter parameter, Reference value);

			internal static vxSetParameterByReference pvxSetParameterByReference;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxQueryParameter(Parameter parameter, int attribute, void* ptr, uint size);

			internal static vxQueryParameter pvxQueryParameter;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Scalar vxCreateScalar(Context context, int data_type, void* ptr);

			internal static vxCreateScalar pvxCreateScalar;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxReleaseScalar(Scalar* scalar);

			internal static vxReleaseScalar pvxReleaseScalar;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxQueryScalar(Scalar scalar, int attribute, void* ptr, uint size);

			internal static vxQueryScalar pvxQueryScalar;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxCopyScalar(Scalar scalar, void* user_ptr, int usage, int user_mem_type);

			internal static vxCopyScalar pvxCopyScalar;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxQueryReference(Reference @ref, int attribute, void* ptr, uint size);

			internal static vxQueryReference pvxQueryReference;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxReleaseReference(Reference* ref_ptr);

			internal static vxReleaseReference pvxReleaseReference;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Status vxRetainReference(Reference @ref);

			internal static vxRetainReference pvxRetainReference;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Status vxSetReferenceName(Reference @ref, string name);

			internal static vxSetReferenceName pvxSetReferenceName;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxQueryDelay(Delay delay, int attribute, void* ptr, uint size);

			internal static vxQueryDelay pvxQueryDelay;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxReleaseDelay(Delay* delay);

			internal static vxReleaseDelay pvxReleaseDelay;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Delay vxCreateDelay(Context context, Reference exemplar, uint num_slots);

			internal static vxCreateDelay pvxCreateDelay;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Reference vxGetReferenceFromDelay(Delay delay, int index);

			internal static vxGetReferenceFromDelay pvxGetReferenceFromDelay;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Status vxAgeDelay(Delay delay);

			internal static vxAgeDelay pvxAgeDelay;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Status vxRegisterAutoAging(Graph graph, Delay delay);

			internal static vxRegisterAutoAging pvxRegisterAutoAging;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate void vxAddLogEntry(Reference @ref, Status status, string message, Int32 vaArgs);

			internal static vxAddLogEntry pvxAddLogEntry;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate void vxRegisterLogCallback(Context context, LogCallback callback, bool reentrant);

			internal static vxRegisterLogCallback pvxRegisterLogCallback;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Lut vxCreateLUT(Context context, int data_type, uint count);

			internal static vxCreateLUT pvxCreateLUT;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxReleaseLUT(Lut* lut);

			internal static vxReleaseLUT pvxReleaseLUT;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxQueryLUT(Lut lut, int attribute, void* ptr, uint size);

			internal static vxQueryLUT pvxQueryLUT;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxCopyLUT(Lut lut, void* user_ptr, int usage, int user_mem_type);

			internal static vxCopyLUT pvxCopyLUT;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxMapLUT(Lut lut, MapId* map_id, IntPtr* ptr, int usage, int mem_type, uint flags);

			internal static vxMapLUT pvxMapLUT;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Status vxUnmapLUT(Lut lut, MapId map_id);

			internal static vxUnmapLUT pvxUnmapLUT;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Distribution vxCreateDistribution(Context context, uint numBins, int offset, uint range);

			internal static vxCreateDistribution pvxCreateDistribution;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxReleaseDistribution(Distribution* distribution);

			internal static vxReleaseDistribution pvxReleaseDistribution;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxQueryDistribution(Distribution distribution, int attribute, void* ptr, uint size);

			internal static vxQueryDistribution pvxQueryDistribution;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxCopyDistribution(Distribution distribution, void* user_ptr, int usage, int user_mem_type);

			internal static vxCopyDistribution pvxCopyDistribution;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxMapDistribution(Distribution distribution, MapId* map_id, IntPtr* ptr, int usage, int mem_type, uint flags);

			internal static vxMapDistribution pvxMapDistribution;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Status vxUnmapDistribution(Distribution distribution, MapId map_id);

			internal static vxUnmapDistribution pvxUnmapDistribution;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Threshold vxCreateThreshold(Context c, int thresh_type, int data_type);

			internal static vxCreateThreshold pvxCreateThreshold;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxReleaseThreshold(Threshold* thresh);

			internal static vxReleaseThreshold pvxReleaseThreshold;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxSetThresholdAttribute(Threshold thresh, int attribute, void* ptr, uint size);

			internal static vxSetThresholdAttribute pvxSetThresholdAttribute;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxQueryThreshold(Threshold thresh, int attribute, void* ptr, uint size);

			internal static vxQueryThreshold pvxQueryThreshold;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Matrix vxCreateMatrix(Context c, int data_type, uint columns, uint rows);

			internal static vxCreateMatrix pvxCreateMatrix;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxReleaseMatrix(Matrix* mat);

			internal static vxReleaseMatrix pvxReleaseMatrix;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxQueryMatrix(Matrix mat, int attribute, void* ptr, uint size);

			internal static vxQueryMatrix pvxQueryMatrix;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxCopyMatrix(Matrix matrix, void* user_ptr, int usage, int user_mem_type);

			internal static vxCopyMatrix pvxCopyMatrix;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Matrix vxCreateMatrixFromPattern(Context context, int pattern, uint columns, uint rows);

			internal static vxCreateMatrixFromPattern pvxCreateMatrixFromPattern;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Convolution vxCreateConvolution(Context context, uint columns, uint rows);

			internal static vxCreateConvolution pvxCreateConvolution;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxReleaseConvolution(Convolution* conv);

			internal static vxReleaseConvolution pvxReleaseConvolution;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxQueryConvolution(Convolution conv, int attribute, void* ptr, uint size);

			internal static vxQueryConvolution pvxQueryConvolution;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxSetConvolutionAttribute(Convolution conv, int attribute, void* ptr, uint size);

			internal static vxSetConvolutionAttribute pvxSetConvolutionAttribute;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxCopyConvolutionCoefficients(Convolution conv, void* user_ptr, int usage, int user_mem_type);

			internal static vxCopyConvolutionCoefficients pvxCopyConvolutionCoefficients;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Pyramid vxCreatePyramid(Context context, uint levels, float scale, uint width, uint height, DfImage format);

			internal static vxCreatePyramid pvxCreatePyramid;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Pyramid vxCreateVirtualPyramid(Graph graph, uint levels, float scale, uint width, uint height, DfImage format);

			internal static vxCreateVirtualPyramid pvxCreateVirtualPyramid;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxReleasePyramid(Pyramid* pyr);

			internal static vxReleasePyramid pvxReleasePyramid;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxQueryPyramid(Pyramid pyr, int attribute, void* ptr, uint size);

			internal static vxQueryPyramid pvxQueryPyramid;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Image vxGetPyramidLevel(Pyramid pyr, uint index);

			internal static vxGetPyramidLevel pvxGetPyramidLevel;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Remap vxCreateRemap(Context context, uint src_width, uint src_height, uint dst_width, uint dst_height);

			internal static vxCreateRemap pvxCreateRemap;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxReleaseRemap(Remap* table);

			internal static vxReleaseRemap pvxReleaseRemap;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Status vxSetRemapPoint(Remap table, uint dst_x, uint dst_y, float src_x, float src_y);

			internal static vxSetRemapPoint pvxSetRemapPoint;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxGetRemapPoint(Remap table, uint dst_x, uint dst_y, float* src_x, float* src_y);

			internal static vxGetRemapPoint pvxGetRemapPoint;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxQueryRemap(Remap table, int attribute, void* ptr, uint size);

			internal static vxQueryRemap pvxQueryRemap;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Array vxCreateArray(Context context, int item_type, uint capacity);

			internal static vxCreateArray pvxCreateArray;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Array vxCreateVirtualArray(Graph graph, int item_type, uint capacity);

			internal static vxCreateVirtualArray pvxCreateVirtualArray;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxReleaseArray(Array* arr);

			internal static vxReleaseArray pvxReleaseArray;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxQueryArray(Array arr, int attribute, void* ptr, uint size);

			internal static vxQueryArray pvxQueryArray;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxAddArrayItems(Array arr, uint count, void* ptr, uint stride);

			internal static vxAddArrayItems pvxAddArrayItems;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Status vxTruncateArray(Array arr, uint new_num_items);

			internal static vxTruncateArray pvxTruncateArray;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxCopyArrayRange(Array array, uint range_start, uint range_end, uint user_stride, void* user_ptr, int usage, int user_mem_type);

			internal static vxCopyArrayRange pvxCopyArrayRange;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxMapArrayRange(Array array, uint range_start, uint range_end, MapId* map_id, uint* stride, IntPtr* ptr, int usage, int mem_type, uint flags);

			internal static vxMapArrayRange pvxMapArrayRange;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Status vxUnmapArrayRange(Array array, MapId map_id);

			internal static vxUnmapArrayRange pvxUnmapArrayRange;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate ObjectArray vxCreateObjectArray(Context context, Reference exemplar, uint count);

			internal static vxCreateObjectArray pvxCreateObjectArray;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate ObjectArray vxCreateVirtualObjectArray(Graph graph, Reference exemplar, uint count);

			internal static vxCreateVirtualObjectArray pvxCreateVirtualObjectArray;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Reference vxGetObjectArrayItem(ObjectArray arr, uint index);

			internal static vxGetObjectArrayItem pvxGetObjectArrayItem;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxReleaseObjectArray(ObjectArray* arr);

			internal static vxReleaseObjectArray pvxReleaseObjectArray;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxQueryObjectArray(ObjectArray arr, int attribute, void* ptr, uint size);

			internal static vxQueryObjectArray pvxQueryObjectArray;

			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate Status vxSetMetaFormatAttribute(MetaFormat meta, int attribute, void* ptr, uint size);

			internal static vxSetMetaFormatAttribute pvxSetMetaFormatAttribute;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Status vxSetMetaFormatFromReference(MetaFormat meta, Reference exemplar);

			internal static vxSetMetaFormatFromReference pvxSetMetaFormatFromReference;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxColorConvertNode(Graph graph, Image input, Image output);

			internal static vxColorConvertNode pvxColorConvertNode;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxChannelExtractNode(Graph graph, Image input, int channel, Image output);

			internal static vxChannelExtractNode pvxChannelExtractNode;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxChannelCombineNode(Graph graph, Image plane0, Image plane1, Image plane2, Image plane3, Image output);

			internal static vxChannelCombineNode pvxChannelCombineNode;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxPhaseNode(Graph graph, Image grad_x, Image grad_y, Image orientation);

			internal static vxPhaseNode pvxPhaseNode;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxSobel3x3Node(Graph graph, Image input, Image output_x, Image output_y);

			internal static vxSobel3x3Node pvxSobel3x3Node;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxMagnitudeNode(Graph graph, Image grad_x, Image grad_y, Image mag);

			internal static vxMagnitudeNode pvxMagnitudeNode;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxScaleImageNode(Graph graph, Image src, Image dst, int type);

			internal static vxScaleImageNode pvxScaleImageNode;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxTableLookupNode(Graph graph, Image input, Lut lut, Image output);

			internal static vxTableLookupNode pvxTableLookupNode;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxHistogramNode(Graph graph, Image input, Distribution distribution);

			internal static vxHistogramNode pvxHistogramNode;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxEqualizeHistNode(Graph graph, Image input, Image output);

			internal static vxEqualizeHistNode pvxEqualizeHistNode;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxAbsDiffNode(Graph graph, Image in1, Image in2, Image @out);

			internal static vxAbsDiffNode pvxAbsDiffNode;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxMeanStdDevNode(Graph graph, Image input, Scalar mean, Scalar stddev);

			internal static vxMeanStdDevNode pvxMeanStdDevNode;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxThresholdNode(Graph graph, Image input, Threshold thresh, Image output);

			internal static vxThresholdNode pvxThresholdNode;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxIntegralImageNode(Graph graph, Image input, Image output);

			internal static vxIntegralImageNode pvxIntegralImageNode;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxErode3x3Node(Graph graph, Image input, Image output);

			internal static vxErode3x3Node pvxErode3x3Node;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxDilate3x3Node(Graph graph, Image input, Image output);

			internal static vxDilate3x3Node pvxDilate3x3Node;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxMedian3x3Node(Graph graph, Image input, Image output);

			internal static vxMedian3x3Node pvxMedian3x3Node;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxBox3x3Node(Graph graph, Image input, Image output);

			internal static vxBox3x3Node pvxBox3x3Node;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxGaussian3x3Node(Graph graph, Image input, Image output);

			internal static vxGaussian3x3Node pvxGaussian3x3Node;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxNonLinearFilterNode(Graph graph, int function, Image input, Matrix mask, Image output);

			internal static vxNonLinearFilterNode pvxNonLinearFilterNode;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxConvolveNode(Graph graph, Image input, Convolution conv, Image output);

			internal static vxConvolveNode pvxConvolveNode;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxGaussianPyramidNode(Graph graph, Image input, Pyramid gaussian);

			internal static vxGaussianPyramidNode pvxGaussianPyramidNode;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxLaplacianPyramidNode(Graph graph, Image input, Pyramid laplacian, Image output);

			internal static vxLaplacianPyramidNode pvxLaplacianPyramidNode;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxLaplacianReconstructNode(Graph graph, Pyramid laplacian, Image input, Image output);

			internal static vxLaplacianReconstructNode pvxLaplacianReconstructNode;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxAccumulateImageNode(Graph graph, Image input, Image accum);

			internal static vxAccumulateImageNode pvxAccumulateImageNode;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxAccumulateWeightedImageNode(Graph graph, Image input, Scalar alpha, Image accum);

			internal static vxAccumulateWeightedImageNode pvxAccumulateWeightedImageNode;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxAccumulateSquareImageNode(Graph graph, Image input, Scalar shift, Image accum);

			internal static vxAccumulateSquareImageNode pvxAccumulateSquareImageNode;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxMinMaxLocNode(Graph graph, Image input, Scalar minVal, Scalar maxVal, Array minLoc, Array maxLoc, Scalar minCount, Scalar maxCount);

			internal static vxMinMaxLocNode pvxMinMaxLocNode;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxAndNode(Graph graph, Image in1, Image in2, Image @out);

			internal static vxAndNode pvxAndNode;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxOrNode(Graph graph, Image in1, Image in2, Image @out);

			internal static vxOrNode pvxOrNode;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxXorNode(Graph graph, Image in1, Image in2, Image @out);

			internal static vxXorNode pvxXorNode;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxNotNode(Graph graph, Image input, Image output);

			internal static vxNotNode pvxNotNode;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxMultiplyNode(Graph graph, Image in1, Image in2, Scalar scale, int overflow_policy, int rounding_policy, Image @out);

			internal static vxMultiplyNode pvxMultiplyNode;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxAddNode(Graph graph, Image in1, Image in2, int policy, Image @out);

			internal static vxAddNode pvxAddNode;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxSubtractNode(Graph graph, Image in1, Image in2, int policy, Image @out);

			internal static vxSubtractNode pvxSubtractNode;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxConvertDepthNode(Graph graph, Image input, Image output, int policy, Scalar shift);

			internal static vxConvertDepthNode pvxConvertDepthNode;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxCannyEdgeDetectorNode(Graph graph, Image input, Threshold hyst, int gradient_size, int norm_type, Image output);

			internal static vxCannyEdgeDetectorNode pvxCannyEdgeDetectorNode;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxWarpAffineNode(Graph graph, Image input, Matrix matrix, int type, Image output);

			internal static vxWarpAffineNode pvxWarpAffineNode;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxWarpPerspectiveNode(Graph graph, Image input, Matrix matrix, int type, Image output);

			internal static vxWarpPerspectiveNode pvxWarpPerspectiveNode;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxHarrisCornersNode(Graph graph, Image input, Scalar strength_thresh, Scalar min_distance, Scalar sensitivity, int gradient_size, int block_size, Array corners, Scalar num_corners);

			internal static vxHarrisCornersNode pvxHarrisCornersNode;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxFastCornersNode(Graph graph, Image input, Scalar strength_thresh, bool nonmax_suppression, Array corners, Scalar num_corners);

			internal static vxFastCornersNode pvxFastCornersNode;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxOpticalFlowPyrLKNode(Graph graph, Pyramid old_images, Pyramid new_images, Array old_points, Array new_points_estimates, Array new_points, int termination, Scalar epsilon, Scalar num_iterations, Scalar use_initial_estimate, uint window_dimension);

			internal static vxOpticalFlowPyrLKNode pvxOpticalFlowPyrLKNode;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxRemapNode(Graph graph, Image input, Remap table, int policy, Image output);

			internal static vxRemapNode pvxRemapNode;

			[SuppressUnmanagedCodeSecurity()]
			internal delegate Node vxHalfScaleGaussianNode(Graph graph, Image input, Image output, int kernel_size);

			internal static vxHalfScaleGaussianNode pvxHalfScaleGaussianNode;

		}
	}

}
