
// MIT License
// 
// Copyright (c) 2017 Luca Piccioni
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// 
// This file is automatically generated

using System;
using System.Windows.Forms;

using Khronos;
using OpenVX;

namespace HelloVX
{
	/// <summary>
	/// OpenVX sample application.
	/// </summary>
	/// <remarks>
	/// The sample follows https://github.com/rgiduthuri/openvx_tutorial/blob/master/tutorial_exercises/solution_exercise1/solution_exercise1.cpp.
	/// </remarks>
	public partial class SampleForm : Form
	{
		public SampleForm()
		{
			InitializeComponent();
		}

		private void SampleForm_Load(object sender, EventArgs e)
		{
			uint width = 1014, height = 1014;
			uint    max_keypoint_count      = 10000;                 // maximum number of keypoints to track
			float harris_strength_thresh  = 0.0005f;               // minimum corner strength to keep a corner
			float harris_min_distance     = 5.0f;                  // radial L2 distance for non-max suppression
			float harris_sensitivity      = 0.04f;                 // multiplier k in det(A) - k * trace(A)^2
			int   harris_gradient_size    = 3;                     // window size for gradient computation
			int   harris_block_size       = 3;                     // block window size for Harris corner score
			uint  lk_pyramid_levels       = 6;                     // number of pyramid levels for optical flow
			float lk_pyramid_scale        = VX.SCALE_PYRAMID_HALF; // pyramid levels scale by factor of two
			TerminationCriteria lk_termination = TerminationCriteria.Both; // iteration termination criteria (eps & iterations)
			float lk_epsilon              = 0.01f;                 // convergence criterion
			uint  lk_num_iterations       = 5;                     // maximum number of iterations
			bool    lk_use_initial_estimate = false;            // don't use initial estimate
			uint  lk_window_dimension     = 6;                     // window size for evaluation
			float trackable_kp_ratio_thr  = 0.8f;                  // threshold for the ration of tracked keypoints to all

			// Create the OpenVX context and make sure the returned context is valid.
			_Context = VX.CreateContext();

			// Create OpenVX image object for input RGB image.
			_ImageInput = VX.CreateImage(_Context, 256, 256, DfImage.Rgb);

			// OpenVX optical flow functionality requires image pyramids for the current
			// and the previous image. It also requires keypoints that correspond
			// to the previous pyramid and will output updated keypoints into
			// another keypoint array. To be able to toggle between the current and
			// the previous buffers, you need to use OpenVX delay objects and vxAgeDelay().
			// Create OpenVX pyramid and array object exemplars and create OpenVX delay
			// objects for both to hold two of each. Note that the exemplar objects are not
			// needed once the delay objects are created.
			Pyramid _Pyramid;
			OpenVX.Array _KeypointsExemplar;

			_Pyramid = VX.CreatePyramid(_Context, lk_pyramid_levels, lk_pyramid_scale, 256, 256, DfImage.U8);
			_PyramidDelay = VX.CreateDelay(_Context, _Pyramid, 2);
			VX.Release(_Pyramid);
			_KeypointsExemplar = VX.CreateArray(_Context, OpenVX.Type.Keypoint, max_keypoint_count);
			_KeypointsDelay = VX.CreateDelay(_Context, _KeypointsExemplar, 2);
			VX.Release(_KeypointsExemplar);

			// An object from a delay slot can be accessed using vxGetReferenceFromDelay API.
			// You need to use index = 0 for the current object and index = -1 for the previous object.

			_PyramidCurrent = VX.GetReferenceFromDelay(_PyramidDelay, 0);
			_PyramidPrevious = VX.GetReferenceFromDelay(_PyramidDelay, -1);
			_KeypointsCurrent = VX.GetReferenceFromDelay(_KeypointsDelay, 0);
			_KeypointsPrevious = VX.GetReferenceFromDelay(_KeypointsDelay, -1);

			// Harris and optical flow algorithms require their own graph objects.
			// The Harris graph needs to extract gray scale image out of input RGB,
			// compute an initial set of keypoints, and compute an initial pyramid for use
			// by the optical flow graph.
			Graph graphHarris = VX.CreateGraph(_Context);
			Graph graphTrack  = VX.CreateGraph(_Context);

			// Harris and pyramid computation expect input to be an 8-bit image.
			// Given that input is an RGB image, it is best to extract a gray image
			// from RGB image, which requires two steps:
			//   - perform RGB to IYUV color conversion
			//   - extract Y channel from IYUV image
			// This requires two intermediate OpenVX image objects. Since you don't
			// need to access these objects from the application, they can be virtual
			// objects that can be created using the vxCreateVirtualImage API.
			Image harris_yuv_image       = VX.CreateVirtualImage(graphHarris, width, height, DfImage.Iyuv);
			Image harris_gray_image      = VX.CreateVirtualImage(graphHarris, width, height, DfImage.U8);
			Image opticalflow_yuv_image  = VX.CreateVirtualImage(graphTrack,  width, height, DfImage.Iyuv);
			Image opticalflow_gray_image = VX.CreateVirtualImage(graphTrack,  width, height, DfImage.U8);

			// The Harris corner detector and optical flow nodes (see "VX/vx_nodes.h")
			// need several scalar objects as parameters.
			Scalar strength_thresh      = VX.CreateScalar(_Context, harris_strength_thresh);
			Scalar min_distance         = VX.CreateScalar(_Context, harris_min_distance);
			Scalar sensitivity          = VX.CreateScalar(_Context, harris_sensitivity);
			Scalar epsilon              = VX.CreateScalar(_Context, lk_epsilon);
			Scalar num_iterations       = VX.CreateScalar(_Context, lk_num_iterations);
			Scalar use_initial_estimate = VX.CreateScalar(_Context, lk_use_initial_estimate);

			// Now all the objects have been created for building the graphs.
			// First, build a graph that performs Harris corner detection and initial pyramid computation.
			// See "VX/vx_nodes.h" for APIs how to add nodes into a graph.
			Node[] nodesHarris = new Node[] {
				VX.ColorConvertNode(graphHarris, _ImageInput, harris_yuv_image),
				VX.ChannelExtractNode(graphHarris, harris_yuv_image, Channel.ChannelY, harris_gray_image ),
				VX.GaussianPyramidNode(graphHarris, harris_gray_image, _PyramidCurrent),
				VX.HarrisCornersNode(graphHarris, harris_gray_image, strength_thresh, min_distance, sensitivity, harris_gradient_size, harris_block_size, _KeypointsCurrent, Reference.Null)
			};
			// VX.Release(nodesHarris);

			VX.VerifyGraph(graphHarris);

			// Now, build a graph that computes image pyramid for the next frame,
			// and tracks features using optical flow.
			Node[] nodesTrack = new Node[] {
				VX.ColorConvertNode(graphTrack, _ImageInput, opticalflow_yuv_image ),
				VX.ChannelExtractNode(graphTrack, opticalflow_yuv_image, Channel.ChannelY, opticalflow_gray_image),
				VX.GaussianPyramidNode(graphTrack, opticalflow_gray_image, _PyramidCurrent),
				VX.OpticalFlowPyrLKNode(graphTrack, _PyramidPrevious, _PyramidCurrent, _KeypointsPrevious, _KeypointsPrevious, _KeypointsCurrent,
													lk_termination, epsilon, num_iterations,
													use_initial_estimate, lk_window_dimension
													)
			};

			VX.VerifyGraph(graphTrack);

			_GraphHarris = graphHarris;
			_GraphTrack = graphTrack;
		}

		OpenVX.Image _ImageInput;

		Delay _PyramidDelay, _KeypointsDelay;

		Pyramid _PyramidCurrent, _PyramidPrevious;

		OpenVX.Array _KeypointsCurrent, _KeypointsPrevious;

		Graph _GraphHarris, _GraphTrack;

		private void VisionControl_Render(object sender, OpenGL.GlControlEventArgs e)
		{
			// Copy the input RGB frame from OpenGL to OpenVX
			Rectangle cv_rgb_image_region = new Rectangle();
			cv_rgb_image_region.StartX = 0;
			cv_rgb_image_region.StartY = 0;
			cv_rgb_image_region.EndX = (uint)VisionControl.Width;
			cv_rgb_image_region.EndY = (uint)VisionControl.Height;

			ImagePatchAddressing cv_rgb_image_layout = new ImagePatchAddressing();
			cv_rgb_image_layout.StrideX   = 3;
			cv_rgb_image_layout.StrideY   = VisionControl.Width * cv_rgb_image_layout.StrideX; //gui.GetStride();

			byte[] cv_rgb_image_buffer = null;

			using (MemoryLock rgbImageBuffer = new MemoryLock(cv_rgb_image_buffer)) {
				VX.CopyImagePatch(_ImageInput, ref cv_rgb_image_region, 0, ref cv_rgb_image_layout, rgbImageBuffer.Address, Accessor.WriteOnly, MemoryType.Host);
			}

			// Now that input RGB image is ready, just run a graph.
			// Run Harris at the beginning to initialize the previous keypoints,
			// on other frames run the tracking graph.
			VX.ProcessGraph( frame_index == 0 ? _GraphHarris : _GraphTrack);

			// To mark the keypoints in display, you need to access the output
			// keypoint array and draw each item on the output window using gui.DrawArrow().
			uint num_corners = 0, num_tracking = 0;

			_KeypointsPrevious = VX.GetReferenceFromDelay(_KeypointsDelay, -1);
			_KeypointsCurrent  = VX.GetReferenceFromDelay(_KeypointsDelay,  0);

			VX.Query(_KeypointsPrevious, ArrayAttribute.Numitems, out num_corners);
			if (num_corners > 0) {
				uint kp_old_stride = 0, kp_new_stride = 0;
				MapId kp_old_map = new MapId(), kp_new_map = new MapId();
				IntPtr kp_old_buf, kp_new_buf;
			//	byte * kp_old_buf, * kp_new_buf;

				VX.MapArrayRange(_KeypointsPrevious, 0, num_corners, ref kp_old_map, ref kp_old_stride, out kp_old_buf, Accessor.ReadOnly, MemoryType.Host, 0);
				VX.MapArrayRange(_KeypointsCurrent, 0, num_corners, ref kp_new_map, ref kp_new_stride, out kp_new_buf, Accessor.ReadOnly, MemoryType.Host, 0);
				for (uint i = 0; i < num_corners; i++ ) {
			//		vx_keypoint_t * kp_old = (vx_keypoint_t *) ( kp_old_buf + i * kp_old_stride );
			//		vx_keypoint_t * kp_new = (vx_keypoint_t *) ( kp_new_buf + i * kp_new_stride );

			//		if (kp_new->tracking_status ) {
			//			num_tracking++;

			//			// gui.DrawArrow( kp_old->x, kp_old->y, kp_new->x, kp_new->y );
			//		}
				}
				VX.UnmapArrayRange(_KeypointsPrevious, kp_old_map);
				VX.UnmapArrayRange(_KeypointsCurrent, kp_new_map);
			}
		}

		static int frame_index = 0;

		private void SampleForm_FormClosing(object sender, FormClosingEventArgs e)
		{
			VX.Release(_Context);
		}

		private Context _Context;
	}
}
