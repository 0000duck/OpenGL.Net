
// MIT License
// 
// Copyright (c) 2009-2017 Luca Piccioni
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// 
// This file is automatically generated

#pragma warning disable 649, 1572, 1573

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Security;
using System.Text;

namespace OpenGL
{
	public partial class Gl
	{
		/// <summary>
		/// [GL4|GLES3.2] Gl.GetVertexAttrib: params returns a single value that is the frequency divisor used for instanced 
		/// rendering. See Gl.VertexAttribDivisor. The initial value is 0.
		/// </summary>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ES_VERSION_3_0", Api = "gles2")]
		[RequiredByFeature("GL_ANGLE_instanced_arrays", Api = "gles2")]
		[RequiredByFeature("GL_ARB_instanced_arrays", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_instanced_arrays", Api = "gles2")]
		[RequiredByFeature("GL_NV_instanced_arrays", Api = "gles2")]
		public const int VERTEX_ATTRIB_ARRAY_DIVISOR = 0x88FE;

		/// <summary>
		/// [GL] Value of GL_SRC1_COLOR symbol.
		/// </summary>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ARB_blend_func_extended", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_blend_func_extended", Api = "gles2")]
		public const int SRC1_COLOR = 0x88F9;

		/// <summary>
		/// [GL] Value of GL_ONE_MINUS_SRC1_COLOR symbol.
		/// </summary>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ARB_blend_func_extended", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_blend_func_extended", Api = "gles2")]
		public const int ONE_MINUS_SRC1_COLOR = 0x88FA;

		/// <summary>
		/// [GL] Value of GL_ONE_MINUS_SRC1_ALPHA symbol.
		/// </summary>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ARB_blend_func_extended", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_blend_func_extended", Api = "gles2")]
		public const int ONE_MINUS_SRC1_ALPHA = 0x88FB;

		/// <summary>
		/// [GL4] Gl.Get: data returns one value, the maximum number of active draw buffers when using dual-source blending. The 
		/// value must be at least 1. See Gl.BlendFunc and Gl.BlendFuncSeparate.
		/// </summary>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ARB_blend_func_extended", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_blend_func_extended", Api = "gles2")]
		public const int MAX_DUAL_SOURCE_DRAW_BUFFERS = 0x88FC;

		/// <summary>
		/// [GL] Value of GL_ANY_SAMPLES_PASSED symbol.
		/// </summary>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ES_VERSION_3_0", Api = "gles2")]
		[RequiredByFeature("GL_ARB_occlusion_query2", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_occlusion_query_boolean", Api = "gles2")]
		public const int ANY_SAMPLES_PASSED = 0x8C2F;

		/// <summary>
		/// [GL4|GLES3.2] Gl.Get: data returns a single value, the name of the sampler object currently bound to the active texture 
		/// unit. The initial value is 0. See Gl.BindSampler.
		/// </summary>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ES_VERSION_3_0", Api = "gles2")]
		[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
		public const int SAMPLER_BINDING = 0x8919;

		/// <summary>
		/// [GL] Value of GL_RGB10_A2UI symbol.
		/// </summary>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ES_VERSION_3_0", Api = "gles2")]
		[RequiredByFeature("GL_ARB_texture_rgb10_a2ui", Api = "gl|glcore")]
		public const int RGB10_A2UI = 0x906F;

		/// <summary>
		/// [GL4|GLES3.2] Gl.GetTexParameter: Returns the red component swizzle. The initial value is Gl.RED.
		/// </summary>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ES_VERSION_3_0", Api = "gles2")]
		[RequiredByFeature("GL_ARB_texture_swizzle", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_texture_swizzle")]
		public const int TEXTURE_SWIZZLE_R = 0x8E42;

		/// <summary>
		/// [GL4|GLES3.2] Gl.GetTexParameter: Returns the green component swizzle. The initial value is Gl.GREEN.
		/// </summary>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ES_VERSION_3_0", Api = "gles2")]
		[RequiredByFeature("GL_ARB_texture_swizzle", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_texture_swizzle")]
		public const int TEXTURE_SWIZZLE_G = 0x8E43;

		/// <summary>
		/// [GL4|GLES3.2] Gl.GetTexParameter: Returns the blue component swizzle. The initial value is Gl.BLUE.
		/// </summary>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ES_VERSION_3_0", Api = "gles2")]
		[RequiredByFeature("GL_ARB_texture_swizzle", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_texture_swizzle")]
		public const int TEXTURE_SWIZZLE_B = 0x8E44;

		/// <summary>
		/// [GL4|GLES3.2] Gl.GetTexParameter: Returns the alpha component swizzle. The initial value is Gl.ALPHA.
		/// </summary>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ES_VERSION_3_0", Api = "gles2")]
		[RequiredByFeature("GL_ARB_texture_swizzle", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_texture_swizzle")]
		public const int TEXTURE_SWIZZLE_A = 0x8E45;

		/// <summary>
		/// [GL4] Gl.GetTexParameter: Returns the component swizzle for all channels in a single query.
		/// </summary>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ARB_texture_swizzle", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_texture_swizzle")]
		public const int TEXTURE_SWIZZLE_RGBA = 0x8E46;

		/// <summary>
		/// [GL] Value of GL_TIME_ELAPSED symbol.
		/// </summary>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ARB_timer_query", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_disjoint_timer_query", Api = "gles2")]
		[RequiredByFeature("GL_EXT_timer_query")]
		public const int TIME_ELAPSED = 0x88BF;

		/// <summary>
		/// [GL4] Gl.Get: data returns a single value, the 64-bit value of the current GL time. See Gl.QueryCounter.
		/// </summary>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ARB_timer_query", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_disjoint_timer_query", Api = "gles2")]
		public const int TIMESTAMP = 0x8E28;

		/// <summary>
		/// [GL] Value of GL_INT_2_10_10_10_REV symbol.
		/// </summary>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ES_VERSION_3_0", Api = "gles2")]
		[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Api = "gl|glcore")]
		public const int INT_2_10_10_10_REV = 0x8D9F;

		/// <summary>
		/// [GL4] glBindFragDataLocationIndexed: bind a user-defined varying out variable to a fragment shader color number and 
		/// index
		/// </summary>
		/// <param name="program">
		/// The name of the program containing varying out variable whose binding to modify
		/// </param>
		/// <param name="colorNumber">
		/// The color number to bind the user-defined varying out variable to
		/// </param>
		/// <param name="index">
		/// The index of the color input to bind the user-defined varying out variable to
		/// </param>
		/// <param name="name">
		/// The name of the user-defined varying out variable whose binding to modify
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ARB_blend_func_extended", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_blend_func_extended", Api = "gles2")]
		public static void BindFragDataLocationIndexed(UInt32 program, UInt32 colorNumber, UInt32 index, String name)
		{
			Debug.Assert(Delegates.pglBindFragDataLocationIndexed != null, "pglBindFragDataLocationIndexed not implemented");
			Delegates.pglBindFragDataLocationIndexed(program, colorNumber, index, name);
			LogCommand("glBindFragDataLocationIndexed", null, program, colorNumber, index, name			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL4] glGetFragDataIndex: query the bindings of color indices to user-defined varying out variables
		/// </summary>
		/// <param name="program">
		/// The name of the program containing varying out variable whose binding to query
		/// </param>
		/// <param name="name">
		/// The name of the user-defined varying out variable whose index to query
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ARB_blend_func_extended", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_blend_func_extended", Api = "gles2")]
		public static Int32 GetFragDataIndex(UInt32 program, String name)
		{
			Int32 retValue;

			Debug.Assert(Delegates.pglGetFragDataIndex != null, "pglGetFragDataIndex not implemented");
			retValue = Delegates.pglGetFragDataIndex(program, name);
			LogCommand("glGetFragDataIndex", retValue, program, name			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		/// <summary>
		/// <para>
		/// [GL4|GLES3.2] glGenSamplers: generate sampler object names
		/// </para>
		/// </summary>
		/// <param name="samplers">
		/// Specifies an array in which the generated sampler object names are stored.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ES_VERSION_3_0", Api = "gles2")]
		[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
		public static void GenSamplers(UInt32[] samplers)
		{
			unsafe {
				fixed (UInt32* p_samplers = samplers)
				{
					Debug.Assert(Delegates.pglGenSamplers != null, "pglGenSamplers not implemented");
					Delegates.pglGenSamplers((Int32)samplers.Length, p_samplers);
					LogCommand("glGenSamplers", null, samplers.Length, samplers					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// <para>
		/// [GL4|GLES3.2] glGenSamplers: generate sampler object names
		/// </para>
		/// </summary>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ES_VERSION_3_0", Api = "gles2")]
		[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
		public static UInt32 GenSampler()
		{
			UInt32[] retValue = new UInt32[1];
			GenSamplers(retValue);
			return (retValue[0]);
		}

		/// <summary>
		/// <para>
		/// [GL4|GLES3.2] glDeleteSamplers: delete named sampler objects
		/// </para>
		/// </summary>
		/// <param name="samplers">
		/// Specifies an array of sampler objects to be deleted.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ES_VERSION_3_0", Api = "gles2")]
		[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
		public static void DeleteSamplers(params UInt32[] samplers)
		{
			unsafe {
				fixed (UInt32* p_samplers = samplers)
				{
					Debug.Assert(Delegates.pglDeleteSamplers != null, "pglDeleteSamplers not implemented");
					Delegates.pglDeleteSamplers((Int32)samplers.Length, p_samplers);
					LogCommand("glDeleteSamplers", null, samplers.Length, samplers					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// <para>
		/// [GL4|GLES3.2] glIsSampler: determine if a name corresponds to a sampler object
		/// </para>
		/// </summary>
		/// <param name="sampler">
		/// A <see cref="T:UInt32"/>.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ES_VERSION_3_0", Api = "gles2")]
		[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
		public static bool IsSampler(UInt32 sampler)
		{
			bool retValue;

			Debug.Assert(Delegates.pglIsSampler != null, "pglIsSampler not implemented");
			retValue = Delegates.pglIsSampler(sampler);
			LogCommand("glIsSampler", retValue, sampler			);
			DebugCheckErrors(retValue);

			return (retValue);
		}

		/// <summary>
		/// <para>
		/// [GL4|GLES3.2] glBindSampler: bind a named sampler to a texturing target
		/// </para>
		/// </summary>
		/// <param name="unit">
		/// Specifies the index of the texture unit to which the sampler is bound.
		/// </param>
		/// <param name="sampler">
		/// Specifies the name of a sampler.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ES_VERSION_3_0", Api = "gles2")]
		[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
		public static void BindSampler(UInt32 unit, UInt32 sampler)
		{
			Debug.Assert(Delegates.pglBindSampler != null, "pglBindSampler not implemented");
			Delegates.pglBindSampler(unit, sampler);
			LogCommand("glBindSampler", null, unit, sampler			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glSamplerParameteri: Binding for glSamplerParameteri.
		/// </summary>
		/// <param name="sampler">
		/// A <see cref="T:UInt32"/>.
		/// </param>
		/// <param name="pname">
		/// A <see cref="T:SamplerParameterName"/>.
		/// </param>
		/// <param name="param">
		/// A <see cref="T:Int32"/>.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ES_VERSION_3_0", Api = "gles2")]
		[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
		public static void SamplerParameter(UInt32 sampler, SamplerParameterName pname, Int32 param)
		{
			Debug.Assert(Delegates.pglSamplerParameteri != null, "pglSamplerParameteri not implemented");
			Delegates.pglSamplerParameteri(sampler, (Int32)pname, param);
			LogCommand("glSamplerParameteri", null, sampler, pname, param			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glSamplerParameteriv: Binding for glSamplerParameteriv.
		/// </summary>
		/// <param name="sampler">
		/// A <see cref="T:UInt32"/>.
		/// </param>
		/// <param name="pname">
		/// A <see cref="T:SamplerParameterName"/>.
		/// </param>
		/// <param name="param">
		/// A <see cref="T:Int32[]"/>.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ES_VERSION_3_0", Api = "gles2")]
		[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
		public static void SamplerParameter(UInt32 sampler, SamplerParameterName pname, Int32[] param)
		{
			unsafe {
				fixed (Int32* p_param = param)
				{
					Debug.Assert(Delegates.pglSamplerParameteriv != null, "pglSamplerParameteriv not implemented");
					Delegates.pglSamplerParameteriv(sampler, (Int32)pname, p_param);
					LogCommand("glSamplerParameteriv", null, sampler, pname, param					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glSamplerParameterf: Binding for glSamplerParameterf.
		/// </summary>
		/// <param name="sampler">
		/// A <see cref="T:UInt32"/>.
		/// </param>
		/// <param name="pname">
		/// A <see cref="T:SamplerParameterName"/>.
		/// </param>
		/// <param name="param">
		/// A <see cref="T:float"/>.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ES_VERSION_3_0", Api = "gles2")]
		[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
		public static void SamplerParameter(UInt32 sampler, SamplerParameterName pname, float param)
		{
			Debug.Assert(Delegates.pglSamplerParameterf != null, "pglSamplerParameterf not implemented");
			Delegates.pglSamplerParameterf(sampler, (Int32)pname, param);
			LogCommand("glSamplerParameterf", null, sampler, pname, param			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glSamplerParameterfv: Binding for glSamplerParameterfv.
		/// </summary>
		/// <param name="sampler">
		/// A <see cref="T:UInt32"/>.
		/// </param>
		/// <param name="pname">
		/// A <see cref="T:SamplerParameterName"/>.
		/// </param>
		/// <param name="param">
		/// A <see cref="T:float[]"/>.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ES_VERSION_3_0", Api = "gles2")]
		[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
		public static void SamplerParameter(UInt32 sampler, SamplerParameterName pname, float[] param)
		{
			unsafe {
				fixed (float* p_param = param)
				{
					Debug.Assert(Delegates.pglSamplerParameterfv != null, "pglSamplerParameterfv not implemented");
					Delegates.pglSamplerParameterfv(sampler, (Int32)pname, p_param);
					LogCommand("glSamplerParameterfv", null, sampler, pname, param					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glSamplerParameterIiv: Binding for glSamplerParameterIiv.
		/// </summary>
		/// <param name="sampler">
		/// A <see cref="T:UInt32"/>.
		/// </param>
		/// <param name="pname">
		/// A <see cref="T:SamplerParameterName"/>.
		/// </param>
		/// <param name="param">
		/// A <see cref="T:Int32[]"/>.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ES_VERSION_3_2", Api = "gles2")]
		[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_texture_border_clamp", Api = "gles2")]
		[RequiredByFeature("GL_OES_texture_border_clamp", Api = "gles2")]
		public static void SamplerParameterI(UInt32 sampler, SamplerParameterName pname, Int32[] param)
		{
			unsafe {
				fixed (Int32* p_param = param)
				{
					Debug.Assert(Delegates.pglSamplerParameterIiv != null, "pglSamplerParameterIiv not implemented");
					Delegates.pglSamplerParameterIiv(sampler, (Int32)pname, p_param);
					LogCommand("glSamplerParameterIiv", null, sampler, pname, param					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glSamplerParameterIuiv: Binding for glSamplerParameterIuiv.
		/// </summary>
		/// <param name="sampler">
		/// A <see cref="T:UInt32"/>.
		/// </param>
		/// <param name="pname">
		/// A <see cref="T:SamplerParameterName"/>.
		/// </param>
		/// <param name="param">
		/// A <see cref="T:UInt32[]"/>.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ES_VERSION_3_2", Api = "gles2")]
		[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_texture_border_clamp", Api = "gles2")]
		[RequiredByFeature("GL_OES_texture_border_clamp", Api = "gles2")]
		public static void SamplerParameterI(UInt32 sampler, SamplerParameterName pname, UInt32[] param)
		{
			unsafe {
				fixed (UInt32* p_param = param)
				{
					Debug.Assert(Delegates.pglSamplerParameterIuiv != null, "pglSamplerParameterIuiv not implemented");
					Delegates.pglSamplerParameterIuiv(sampler, (Int32)pname, p_param);
					LogCommand("glSamplerParameterIuiv", null, sampler, pname, param					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// <para>
		/// [GL4|GLES3.2] glGetSamplerParameteriv: return sampler parameter values
		/// </para>
		/// </summary>
		/// <param name="sampler">
		/// Specifies name of the sampler object from which to retrieve parameters.
		/// </param>
		/// <param name="pname">
		/// Specifies the symbolic name of a sampler parameter. Gl.TEXTURE_MAG_FILTER, Gl.TEXTURE_MIN_FILTER, Gl.TEXTURE_MIN_LOD, 
		/// Gl.TEXTURE_MAX_LOD, Gl.TEXTURE_LOD_BIAS, Gl.TEXTURE_WRAP_S, Gl.TEXTURE_WRAP_T, Gl.TEXTURE_WRAP_R, 
		/// Gl.TEXTURE_BORDER_COLOR, Gl.TEXTURE_COMPARE_MODE, and Gl.TEXTURE_COMPARE_FUNC are accepted.
		/// </param>
		/// <param name="params">
		/// Returns the sampler parameters.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ES_VERSION_3_0", Api = "gles2")]
		[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
		public static void GetSamplerParameter(UInt32 sampler, SamplerParameterName pname, [Out] Int32[] @params)
		{
			unsafe {
				fixed (Int32* p_params = @params)
				{
					Debug.Assert(Delegates.pglGetSamplerParameteriv != null, "pglGetSamplerParameteriv not implemented");
					Delegates.pglGetSamplerParameteriv(sampler, (Int32)pname, p_params);
					LogCommand("glGetSamplerParameteriv", null, sampler, pname, @params					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// <para>
		/// [GL4|GLES3.2] glGetSamplerParameterIiv: return sampler parameter values
		/// </para>
		/// </summary>
		/// <param name="sampler">
		/// Specifies name of the sampler object from which to retrieve parameters.
		/// </param>
		/// <param name="pname">
		/// Specifies the symbolic name of a sampler parameter. Gl.TEXTURE_MAG_FILTER, Gl.TEXTURE_MIN_FILTER, Gl.TEXTURE_MIN_LOD, 
		/// Gl.TEXTURE_MAX_LOD, Gl.TEXTURE_LOD_BIAS, Gl.TEXTURE_WRAP_S, Gl.TEXTURE_WRAP_T, Gl.TEXTURE_WRAP_R, 
		/// Gl.TEXTURE_BORDER_COLOR, Gl.TEXTURE_COMPARE_MODE, and Gl.TEXTURE_COMPARE_FUNC are accepted.
		/// </param>
		/// <param name="params">
		/// Returns the sampler parameters.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ES_VERSION_3_2", Api = "gles2")]
		[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_texture_border_clamp", Api = "gles2")]
		[RequiredByFeature("GL_OES_texture_border_clamp", Api = "gles2")]
		public static void GetSamplerParameterI(UInt32 sampler, SamplerParameterName pname, [Out] Int32[] @params)
		{
			unsafe {
				fixed (Int32* p_params = @params)
				{
					Debug.Assert(Delegates.pglGetSamplerParameterIiv != null, "pglGetSamplerParameterIiv not implemented");
					Delegates.pglGetSamplerParameterIiv(sampler, (Int32)pname, p_params);
					LogCommand("glGetSamplerParameterIiv", null, sampler, pname, @params					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// <para>
		/// [GL4|GLES3.2] glGetSamplerParameterfv: return sampler parameter values
		/// </para>
		/// </summary>
		/// <param name="sampler">
		/// Specifies name of the sampler object from which to retrieve parameters.
		/// </param>
		/// <param name="pname">
		/// Specifies the symbolic name of a sampler parameter. Gl.TEXTURE_MAG_FILTER, Gl.TEXTURE_MIN_FILTER, Gl.TEXTURE_MIN_LOD, 
		/// Gl.TEXTURE_MAX_LOD, Gl.TEXTURE_LOD_BIAS, Gl.TEXTURE_WRAP_S, Gl.TEXTURE_WRAP_T, Gl.TEXTURE_WRAP_R, 
		/// Gl.TEXTURE_BORDER_COLOR, Gl.TEXTURE_COMPARE_MODE, and Gl.TEXTURE_COMPARE_FUNC are accepted.
		/// </param>
		/// <param name="params">
		/// Returns the sampler parameters.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ES_VERSION_3_0", Api = "gles2")]
		[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
		public static void GetSamplerParameter(UInt32 sampler, SamplerParameterName pname, [Out] float[] @params)
		{
			unsafe {
				fixed (float* p_params = @params)
				{
					Debug.Assert(Delegates.pglGetSamplerParameterfv != null, "pglGetSamplerParameterfv not implemented");
					Delegates.pglGetSamplerParameterfv(sampler, (Int32)pname, p_params);
					LogCommand("glGetSamplerParameterfv", null, sampler, pname, @params					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// <para>
		/// [GL4|GLES3.2] glGetSamplerParameterIuiv: return sampler parameter values
		/// </para>
		/// </summary>
		/// <param name="sampler">
		/// Specifies name of the sampler object from which to retrieve parameters.
		/// </param>
		/// <param name="pname">
		/// Specifies the symbolic name of a sampler parameter. Gl.TEXTURE_MAG_FILTER, Gl.TEXTURE_MIN_FILTER, Gl.TEXTURE_MIN_LOD, 
		/// Gl.TEXTURE_MAX_LOD, Gl.TEXTURE_LOD_BIAS, Gl.TEXTURE_WRAP_S, Gl.TEXTURE_WRAP_T, Gl.TEXTURE_WRAP_R, 
		/// Gl.TEXTURE_BORDER_COLOR, Gl.TEXTURE_COMPARE_MODE, and Gl.TEXTURE_COMPARE_FUNC are accepted.
		/// </param>
		/// <param name="params">
		/// Returns the sampler parameters.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ES_VERSION_3_2", Api = "gles2")]
		[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_texture_border_clamp", Api = "gles2")]
		[RequiredByFeature("GL_OES_texture_border_clamp", Api = "gles2")]
		public static void GetSamplerParameterI(UInt32 sampler, SamplerParameterName pname, [Out] UInt32[] @params)
		{
			unsafe {
				fixed (UInt32* p_params = @params)
				{
					Debug.Assert(Delegates.pglGetSamplerParameterIuiv != null, "pglGetSamplerParameterIuiv not implemented");
					Delegates.pglGetSamplerParameterIuiv(sampler, (Int32)pname, p_params);
					LogCommand("glGetSamplerParameterIuiv", null, sampler, pname, @params					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL4] glQueryCounter: record the GL time into a query object after all previous commands have reached the GL server but 
		/// have not yet necessarily executed.
		/// </summary>
		/// <param name="id">
		/// Specify the name of a query object into which to record the GL time.
		/// </param>
		/// <param name="target">
		/// Specify the counter to query. <paramref name="target"/> must be Gl.TIMESTAMP.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ARB_timer_query", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_disjoint_timer_query", Api = "gles2")]
		public static void QueryCounter(UInt32 id, QueryTarget target)
		{
			Debug.Assert(Delegates.pglQueryCounter != null, "pglQueryCounter not implemented");
			Delegates.pglQueryCounter(id, (Int32)target);
			LogCommand("glQueryCounter", null, id, target			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL4] glGetQueryObjecti64v: return parameters of a query object
		/// </summary>
		/// <param name="id">
		/// Specifies the name of a query object.
		/// </param>
		/// <param name="pname">
		/// Specifies the symbolic name of a query object parameter. Accepted values are Gl.QUERY_RESULT or 
		/// Gl.QUERY_RESULT_AVAILABLE.
		/// </param>
		/// <param name="params">
		/// If a buffer is bound to the Gl.QUERY_RESULT_BUFFER target, then <paramref name="params"/> is treated as an offset to a 
		/// location within that buffer's data store to receive the result of the query. If no buffer is bound to 
		/// Gl.QUERY_RESULT_BUFFER, then <paramref name="params"/> is treated as an address in client memory of a variable to 
		/// receive the resulting data.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ARB_timer_query", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_disjoint_timer_query", Api = "gles2")]
		[RequiredByFeature("GL_EXT_timer_query")]
		public static void GetQueryObject(UInt32 id, QueryObjectParameterName pname, [Out] Int64[] @params)
		{
			unsafe {
				fixed (Int64* p_params = @params)
				{
					Debug.Assert(Delegates.pglGetQueryObjecti64v != null, "pglGetQueryObjecti64v not implemented");
					Delegates.pglGetQueryObjecti64v(id, (Int32)pname, p_params);
					LogCommand("glGetQueryObjecti64v", null, id, pname, @params					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL4] glGetQueryObjecti64v: return parameters of a query object
		/// </summary>
		/// <param name="id">
		/// Specifies the name of a query object.
		/// </param>
		/// <param name="pname">
		/// Specifies the symbolic name of a query object parameter. Accepted values are Gl.QUERY_RESULT or 
		/// Gl.QUERY_RESULT_AVAILABLE.
		/// </param>
		/// <param name="params">
		/// If a buffer is bound to the Gl.QUERY_RESULT_BUFFER target, then <paramref name="params"/> is treated as an offset to a 
		/// location within that buffer's data store to receive the result of the query. If no buffer is bound to 
		/// Gl.QUERY_RESULT_BUFFER, then <paramref name="params"/> is treated as an address in client memory of a variable to 
		/// receive the resulting data.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ARB_timer_query", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_disjoint_timer_query", Api = "gles2")]
		[RequiredByFeature("GL_EXT_timer_query")]
		public static void GetQueryObject(UInt32 id, QueryObjectParameterName pname, out Int64 @params)
		{
			unsafe {
				fixed (Int64* p_params = &@params)
				{
					Debug.Assert(Delegates.pglGetQueryObjecti64v != null, "pglGetQueryObjecti64v not implemented");
					Delegates.pglGetQueryObjecti64v(id, (Int32)pname, p_params);
					LogCommand("glGetQueryObjecti64v", null, id, pname, @params					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL4] glGetQueryObjectui64v: return parameters of a query object
		/// </summary>
		/// <param name="id">
		/// Specifies the name of a query object.
		/// </param>
		/// <param name="pname">
		/// Specifies the symbolic name of a query object parameter. Accepted values are Gl.QUERY_RESULT or 
		/// Gl.QUERY_RESULT_AVAILABLE.
		/// </param>
		/// <param name="params">
		/// If a buffer is bound to the Gl.QUERY_RESULT_BUFFER target, then <paramref name="params"/> is treated as an offset to a 
		/// location within that buffer's data store to receive the result of the query. If no buffer is bound to 
		/// Gl.QUERY_RESULT_BUFFER, then <paramref name="params"/> is treated as an address in client memory of a variable to 
		/// receive the resulting data.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ARB_timer_query", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_disjoint_timer_query", Api = "gles2")]
		[RequiredByFeature("GL_EXT_timer_query")]
		public static void GetQueryObject(UInt32 id, QueryObjectParameterName pname, [Out] UInt64[] @params)
		{
			unsafe {
				fixed (UInt64* p_params = @params)
				{
					Debug.Assert(Delegates.pglGetQueryObjectui64v != null, "pglGetQueryObjectui64v not implemented");
					Delegates.pglGetQueryObjectui64v(id, (Int32)pname, p_params);
					LogCommand("glGetQueryObjectui64v", null, id, pname, @params					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL4] glGetQueryObjectui64v: return parameters of a query object
		/// </summary>
		/// <param name="id">
		/// Specifies the name of a query object.
		/// </param>
		/// <param name="pname">
		/// Specifies the symbolic name of a query object parameter. Accepted values are Gl.QUERY_RESULT or 
		/// Gl.QUERY_RESULT_AVAILABLE.
		/// </param>
		/// <param name="params">
		/// If a buffer is bound to the Gl.QUERY_RESULT_BUFFER target, then <paramref name="params"/> is treated as an offset to a 
		/// location within that buffer's data store to receive the result of the query. If no buffer is bound to 
		/// Gl.QUERY_RESULT_BUFFER, then <paramref name="params"/> is treated as an address in client memory of a variable to 
		/// receive the resulting data.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ARB_timer_query", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_disjoint_timer_query", Api = "gles2")]
		[RequiredByFeature("GL_EXT_timer_query")]
		public static void GetQueryObject(UInt32 id, QueryObjectParameterName pname, out UInt64 @params)
		{
			unsafe {
				fixed (UInt64* p_params = &@params)
				{
					Debug.Assert(Delegates.pglGetQueryObjectui64v != null, "pglGetQueryObjectui64v not implemented");
					Delegates.pglGetQueryObjectui64v(id, (Int32)pname, p_params);
					LogCommand("glGetQueryObjectui64v", null, id, pname, @params					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// <para>
		/// [GL4|GLES3.2] glVertexAttribDivisor: modify the rate at which generic vertex attributes advance during instanced 
		/// rendering
		/// </para>
		/// </summary>
		/// <param name="index">
		/// Specify the index of the generic vertex attribute.
		/// </param>
		/// <param name="divisor">
		/// Specify the number of instances that will pass between updates of the generic attribute at slot <paramref 
		/// name="index"/>.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ES_VERSION_3_0", Api = "gles2")]
		[RequiredByFeature("GL_ANGLE_instanced_arrays", Api = "gles2")]
		[RequiredByFeature("GL_ARB_instanced_arrays", Api = "gl|glcore")]
		[RequiredByFeature("GL_EXT_instanced_arrays", Api = "gles2")]
		[RequiredByFeature("GL_NV_instanced_arrays", Api = "gles2")]
		public static void VertexAttribDivisor(UInt32 index, UInt32 divisor)
		{
			Debug.Assert(Delegates.pglVertexAttribDivisor != null, "pglVertexAttribDivisor not implemented");
			Delegates.pglVertexAttribDivisor(index, divisor);
			LogCommand("glVertexAttribDivisor", null, index, divisor			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL4] glVertexAttribP1ui: Specifies the value of a generic vertex attribute
		/// </summary>
		/// <param name="index">
		/// Specifies the index of the generic vertex attribute to be modified.
		/// </param>
		/// <param name="type">
		/// For the packed commands (Gl.VertexAttribP*), specified the type of packing used on the data. This parameter must be 
		/// Gl.INT_2_10_10_10_REV or Gl.UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or 
		/// Gl.UNSIGNED_INT_10F_11F_11F_REV to specify floating point data.
		/// </param>
		/// <param name="normalized">
		/// For the packed commands, if Gl.TRUE, then the values are to be converted to floating point values by normalizing. 
		/// Otherwise, they are converted directly to floating-point values. If <paramref name="type"/> indicates a floating-pont 
		/// format, then <paramref name="normalized"/> value must be Gl.FALSE.
		/// </param>
		/// <param name="value">
		/// For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Api = "gl|glcore")]
		public static void VertexAttribP1(UInt32 index, PackedVertexType type, bool normalized, UInt32 value)
		{
			Debug.Assert(Delegates.pglVertexAttribP1ui != null, "pglVertexAttribP1ui not implemented");
			Delegates.pglVertexAttribP1ui(index, (Int32)type, normalized, value);
			LogCommand("glVertexAttribP1ui", null, index, type, normalized, value			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glVertexAttribP1uiv: Binding for glVertexAttribP1uiv.
		/// </summary>
		/// <param name="index">
		/// A <see cref="T:UInt32"/>.
		/// </param>
		/// <param name="type">
		/// A <see cref="T:PackedVertexType"/>.
		/// </param>
		/// <param name="normalized">
		/// A <see cref="T:bool"/>.
		/// </param>
		/// <param name="value">
		/// A <see cref="T:UInt32[]"/>.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Api = "gl|glcore")]
		public static void VertexAttribP1(UInt32 index, PackedVertexType type, bool normalized, UInt32[] value)
		{
			unsafe {
				fixed (UInt32* p_value = value)
				{
					Debug.Assert(Delegates.pglVertexAttribP1uiv != null, "pglVertexAttribP1uiv not implemented");
					Delegates.pglVertexAttribP1uiv(index, (Int32)type, normalized, p_value);
					LogCommand("glVertexAttribP1uiv", null, index, type, normalized, value					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL4] glVertexAttribP2ui: Specifies the value of a generic vertex attribute
		/// </summary>
		/// <param name="index">
		/// Specifies the index of the generic vertex attribute to be modified.
		/// </param>
		/// <param name="type">
		/// For the packed commands (Gl.VertexAttribP*), specified the type of packing used on the data. This parameter must be 
		/// Gl.INT_2_10_10_10_REV or Gl.UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or 
		/// Gl.UNSIGNED_INT_10F_11F_11F_REV to specify floating point data.
		/// </param>
		/// <param name="normalized">
		/// For the packed commands, if Gl.TRUE, then the values are to be converted to floating point values by normalizing. 
		/// Otherwise, they are converted directly to floating-point values. If <paramref name="type"/> indicates a floating-pont 
		/// format, then <paramref name="normalized"/> value must be Gl.FALSE.
		/// </param>
		/// <param name="value">
		/// For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Api = "gl|glcore")]
		public static void VertexAttribP2(UInt32 index, PackedVertexType type, bool normalized, UInt32 value)
		{
			Debug.Assert(Delegates.pglVertexAttribP2ui != null, "pglVertexAttribP2ui not implemented");
			Delegates.pglVertexAttribP2ui(index, (Int32)type, normalized, value);
			LogCommand("glVertexAttribP2ui", null, index, type, normalized, value			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glVertexAttribP2uiv: Binding for glVertexAttribP2uiv.
		/// </summary>
		/// <param name="index">
		/// A <see cref="T:UInt32"/>.
		/// </param>
		/// <param name="type">
		/// A <see cref="T:PackedVertexType"/>.
		/// </param>
		/// <param name="normalized">
		/// A <see cref="T:bool"/>.
		/// </param>
		/// <param name="value">
		/// A <see cref="T:UInt32[]"/>.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Api = "gl|glcore")]
		public static void VertexAttribP2(UInt32 index, PackedVertexType type, bool normalized, UInt32[] value)
		{
			unsafe {
				fixed (UInt32* p_value = value)
				{
					Debug.Assert(Delegates.pglVertexAttribP2uiv != null, "pglVertexAttribP2uiv not implemented");
					Delegates.pglVertexAttribP2uiv(index, (Int32)type, normalized, p_value);
					LogCommand("glVertexAttribP2uiv", null, index, type, normalized, value					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL4] glVertexAttribP3ui: Specifies the value of a generic vertex attribute
		/// </summary>
		/// <param name="index">
		/// Specifies the index of the generic vertex attribute to be modified.
		/// </param>
		/// <param name="type">
		/// For the packed commands (Gl.VertexAttribP*), specified the type of packing used on the data. This parameter must be 
		/// Gl.INT_2_10_10_10_REV or Gl.UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or 
		/// Gl.UNSIGNED_INT_10F_11F_11F_REV to specify floating point data.
		/// </param>
		/// <param name="normalized">
		/// For the packed commands, if Gl.TRUE, then the values are to be converted to floating point values by normalizing. 
		/// Otherwise, they are converted directly to floating-point values. If <paramref name="type"/> indicates a floating-pont 
		/// format, then <paramref name="normalized"/> value must be Gl.FALSE.
		/// </param>
		/// <param name="value">
		/// For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Api = "gl|glcore")]
		public static void VertexAttribP3(UInt32 index, PackedVertexType type, bool normalized, UInt32 value)
		{
			Debug.Assert(Delegates.pglVertexAttribP3ui != null, "pglVertexAttribP3ui not implemented");
			Delegates.pglVertexAttribP3ui(index, (Int32)type, normalized, value);
			LogCommand("glVertexAttribP3ui", null, index, type, normalized, value			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glVertexAttribP3uiv: Binding for glVertexAttribP3uiv.
		/// </summary>
		/// <param name="index">
		/// A <see cref="T:UInt32"/>.
		/// </param>
		/// <param name="type">
		/// A <see cref="T:PackedVertexType"/>.
		/// </param>
		/// <param name="normalized">
		/// A <see cref="T:bool"/>.
		/// </param>
		/// <param name="value">
		/// A <see cref="T:UInt32[]"/>.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Api = "gl|glcore")]
		public static void VertexAttribP3(UInt32 index, PackedVertexType type, bool normalized, UInt32[] value)
		{
			unsafe {
				fixed (UInt32* p_value = value)
				{
					Debug.Assert(Delegates.pglVertexAttribP3uiv != null, "pglVertexAttribP3uiv not implemented");
					Delegates.pglVertexAttribP3uiv(index, (Int32)type, normalized, p_value);
					LogCommand("glVertexAttribP3uiv", null, index, type, normalized, value					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL4] glVertexAttribP4ui: Specifies the value of a generic vertex attribute
		/// </summary>
		/// <param name="index">
		/// Specifies the index of the generic vertex attribute to be modified.
		/// </param>
		/// <param name="type">
		/// For the packed commands (Gl.VertexAttribP*), specified the type of packing used on the data. This parameter must be 
		/// Gl.INT_2_10_10_10_REV or Gl.UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or 
		/// Gl.UNSIGNED_INT_10F_11F_11F_REV to specify floating point data.
		/// </param>
		/// <param name="normalized">
		/// For the packed commands, if Gl.TRUE, then the values are to be converted to floating point values by normalizing. 
		/// Otherwise, they are converted directly to floating-point values. If <paramref name="type"/> indicates a floating-pont 
		/// format, then <paramref name="normalized"/> value must be Gl.FALSE.
		/// </param>
		/// <param name="value">
		/// For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Api = "gl|glcore")]
		public static void VertexAttribP4(UInt32 index, PackedVertexType type, bool normalized, UInt32 value)
		{
			Debug.Assert(Delegates.pglVertexAttribP4ui != null, "pglVertexAttribP4ui not implemented");
			Delegates.pglVertexAttribP4ui(index, (Int32)type, normalized, value);
			LogCommand("glVertexAttribP4ui", null, index, type, normalized, value			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glVertexAttribP4uiv: Binding for glVertexAttribP4uiv.
		/// </summary>
		/// <param name="index">
		/// A <see cref="T:UInt32"/>.
		/// </param>
		/// <param name="type">
		/// A <see cref="T:PackedVertexType"/>.
		/// </param>
		/// <param name="normalized">
		/// A <see cref="T:bool"/>.
		/// </param>
		/// <param name="value">
		/// A <see cref="T:UInt32[]"/>.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3")]
		[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Api = "gl|glcore")]
		public static void VertexAttribP4(UInt32 index, PackedVertexType type, bool normalized, UInt32[] value)
		{
			unsafe {
				fixed (UInt32* p_value = value)
				{
					Debug.Assert(Delegates.pglVertexAttribP4uiv != null, "pglVertexAttribP4uiv not implemented");
					Delegates.pglVertexAttribP4uiv(index, (Int32)type, normalized, p_value);
					LogCommand("glVertexAttribP4uiv", null, index, type, normalized, value					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glVertexP2ui: Binding for glVertexP2ui.
		/// </summary>
		/// <param name="type">
		/// A <see cref="T:PackedVertexType"/>.
		/// </param>
		/// <param name="value">
		/// A <see cref="T:UInt32"/>.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
		[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
		public static void VertexP2(PackedVertexType type, UInt32 value)
		{
			Debug.Assert(Delegates.pglVertexP2ui != null, "pglVertexP2ui not implemented");
			Delegates.pglVertexP2ui((Int32)type, value);
			LogCommand("glVertexP2ui", null, type, value			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glVertexP2uiv: Binding for glVertexP2uiv.
		/// </summary>
		/// <param name="type">
		/// A <see cref="T:PackedVertexType"/>.
		/// </param>
		/// <param name="value">
		/// A <see cref="T:UInt32[]"/>.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
		[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
		public static void VertexP2(PackedVertexType type, UInt32[] value)
		{
			unsafe {
				fixed (UInt32* p_value = value)
				{
					Debug.Assert(Delegates.pglVertexP2uiv != null, "pglVertexP2uiv not implemented");
					Delegates.pglVertexP2uiv((Int32)type, p_value);
					LogCommand("glVertexP2uiv", null, type, value					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glVertexP3ui: Binding for glVertexP3ui.
		/// </summary>
		/// <param name="type">
		/// A <see cref="T:PackedVertexType"/>.
		/// </param>
		/// <param name="value">
		/// A <see cref="T:UInt32"/>.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
		[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
		public static void VertexP3(PackedVertexType type, UInt32 value)
		{
			Debug.Assert(Delegates.pglVertexP3ui != null, "pglVertexP3ui not implemented");
			Delegates.pglVertexP3ui((Int32)type, value);
			LogCommand("glVertexP3ui", null, type, value			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glVertexP3uiv: Binding for glVertexP3uiv.
		/// </summary>
		/// <param name="type">
		/// A <see cref="T:PackedVertexType"/>.
		/// </param>
		/// <param name="value">
		/// A <see cref="T:UInt32[]"/>.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
		[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
		public static void VertexP3(PackedVertexType type, UInt32[] value)
		{
			unsafe {
				fixed (UInt32* p_value = value)
				{
					Debug.Assert(Delegates.pglVertexP3uiv != null, "pglVertexP3uiv not implemented");
					Delegates.pglVertexP3uiv((Int32)type, p_value);
					LogCommand("glVertexP3uiv", null, type, value					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glVertexP4ui: Binding for glVertexP4ui.
		/// </summary>
		/// <param name="type">
		/// A <see cref="T:PackedVertexType"/>.
		/// </param>
		/// <param name="value">
		/// A <see cref="T:UInt32"/>.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
		[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
		public static void VertexP4(PackedVertexType type, UInt32 value)
		{
			Debug.Assert(Delegates.pglVertexP4ui != null, "pglVertexP4ui not implemented");
			Delegates.pglVertexP4ui((Int32)type, value);
			LogCommand("glVertexP4ui", null, type, value			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glVertexP4uiv: Binding for glVertexP4uiv.
		/// </summary>
		/// <param name="type">
		/// A <see cref="T:PackedVertexType"/>.
		/// </param>
		/// <param name="value">
		/// A <see cref="T:UInt32[]"/>.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
		[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
		public static void VertexP4(PackedVertexType type, UInt32[] value)
		{
			unsafe {
				fixed (UInt32* p_value = value)
				{
					Debug.Assert(Delegates.pglVertexP4uiv != null, "pglVertexP4uiv not implemented");
					Delegates.pglVertexP4uiv((Int32)type, p_value);
					LogCommand("glVertexP4uiv", null, type, value					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glTexCoordP1ui: Binding for glTexCoordP1ui.
		/// </summary>
		/// <param name="type">
		/// A <see cref="T:PackedVertexType"/>.
		/// </param>
		/// <param name="coords">
		/// A <see cref="T:UInt32"/>.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
		[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
		public static void TexCoordP1(PackedVertexType type, UInt32 coords)
		{
			Debug.Assert(Delegates.pglTexCoordP1ui != null, "pglTexCoordP1ui not implemented");
			Delegates.pglTexCoordP1ui((Int32)type, coords);
			LogCommand("glTexCoordP1ui", null, type, coords			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glTexCoordP1uiv: Binding for glTexCoordP1uiv.
		/// </summary>
		/// <param name="type">
		/// A <see cref="T:PackedVertexType"/>.
		/// </param>
		/// <param name="coords">
		/// A <see cref="T:UInt32[]"/>.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
		[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
		public static void TexCoordP1(PackedVertexType type, UInt32[] coords)
		{
			unsafe {
				fixed (UInt32* p_coords = coords)
				{
					Debug.Assert(Delegates.pglTexCoordP1uiv != null, "pglTexCoordP1uiv not implemented");
					Delegates.pglTexCoordP1uiv((Int32)type, p_coords);
					LogCommand("glTexCoordP1uiv", null, type, coords					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glTexCoordP2ui: Binding for glTexCoordP2ui.
		/// </summary>
		/// <param name="type">
		/// A <see cref="T:PackedVertexType"/>.
		/// </param>
		/// <param name="coords">
		/// A <see cref="T:UInt32"/>.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
		[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
		public static void TexCoordP2(PackedVertexType type, UInt32 coords)
		{
			Debug.Assert(Delegates.pglTexCoordP2ui != null, "pglTexCoordP2ui not implemented");
			Delegates.pglTexCoordP2ui((Int32)type, coords);
			LogCommand("glTexCoordP2ui", null, type, coords			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glTexCoordP2uiv: Binding for glTexCoordP2uiv.
		/// </summary>
		/// <param name="type">
		/// A <see cref="T:PackedVertexType"/>.
		/// </param>
		/// <param name="coords">
		/// A <see cref="T:UInt32[]"/>.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
		[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
		public static void TexCoordP2(PackedVertexType type, UInt32[] coords)
		{
			unsafe {
				fixed (UInt32* p_coords = coords)
				{
					Debug.Assert(Delegates.pglTexCoordP2uiv != null, "pglTexCoordP2uiv not implemented");
					Delegates.pglTexCoordP2uiv((Int32)type, p_coords);
					LogCommand("glTexCoordP2uiv", null, type, coords					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glTexCoordP3ui: Binding for glTexCoordP3ui.
		/// </summary>
		/// <param name="type">
		/// A <see cref="T:PackedVertexType"/>.
		/// </param>
		/// <param name="coords">
		/// A <see cref="T:UInt32"/>.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
		[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
		public static void TexCoordP3(PackedVertexType type, UInt32 coords)
		{
			Debug.Assert(Delegates.pglTexCoordP3ui != null, "pglTexCoordP3ui not implemented");
			Delegates.pglTexCoordP3ui((Int32)type, coords);
			LogCommand("glTexCoordP3ui", null, type, coords			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glTexCoordP3uiv: Binding for glTexCoordP3uiv.
		/// </summary>
		/// <param name="type">
		/// A <see cref="T:PackedVertexType"/>.
		/// </param>
		/// <param name="coords">
		/// A <see cref="T:UInt32[]"/>.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
		[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
		public static void TexCoordP3(PackedVertexType type, UInt32[] coords)
		{
			unsafe {
				fixed (UInt32* p_coords = coords)
				{
					Debug.Assert(Delegates.pglTexCoordP3uiv != null, "pglTexCoordP3uiv not implemented");
					Delegates.pglTexCoordP3uiv((Int32)type, p_coords);
					LogCommand("glTexCoordP3uiv", null, type, coords					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glTexCoordP4ui: Binding for glTexCoordP4ui.
		/// </summary>
		/// <param name="type">
		/// A <see cref="T:PackedVertexType"/>.
		/// </param>
		/// <param name="coords">
		/// A <see cref="T:UInt32"/>.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
		[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
		public static void TexCoordP4(PackedVertexType type, UInt32 coords)
		{
			Debug.Assert(Delegates.pglTexCoordP4ui != null, "pglTexCoordP4ui not implemented");
			Delegates.pglTexCoordP4ui((Int32)type, coords);
			LogCommand("glTexCoordP4ui", null, type, coords			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glTexCoordP4uiv: Binding for glTexCoordP4uiv.
		/// </summary>
		/// <param name="type">
		/// A <see cref="T:PackedVertexType"/>.
		/// </param>
		/// <param name="coords">
		/// A <see cref="T:UInt32[]"/>.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
		[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
		public static void TexCoordP4(PackedVertexType type, UInt32[] coords)
		{
			unsafe {
				fixed (UInt32* p_coords = coords)
				{
					Debug.Assert(Delegates.pglTexCoordP4uiv != null, "pglTexCoordP4uiv not implemented");
					Delegates.pglTexCoordP4uiv((Int32)type, p_coords);
					LogCommand("glTexCoordP4uiv", null, type, coords					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glMultiTexCoordP1ui: Binding for glMultiTexCoordP1ui.
		/// </summary>
		/// <param name="texture">
		/// A <see cref="T:TextureUnit"/>.
		/// </param>
		/// <param name="type">
		/// A <see cref="T:PackedVertexType"/>.
		/// </param>
		/// <param name="coords">
		/// A <see cref="T:UInt32"/>.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
		[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
		public static void MultiTexCoordP1(TextureUnit texture, PackedVertexType type, UInt32 coords)
		{
			Debug.Assert(Delegates.pglMultiTexCoordP1ui != null, "pglMultiTexCoordP1ui not implemented");
			Delegates.pglMultiTexCoordP1ui((Int32)texture, (Int32)type, coords);
			LogCommand("glMultiTexCoordP1ui", null, texture, type, coords			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glMultiTexCoordP1uiv: Binding for glMultiTexCoordP1uiv.
		/// </summary>
		/// <param name="texture">
		/// A <see cref="T:TextureUnit"/>.
		/// </param>
		/// <param name="type">
		/// A <see cref="T:PackedVertexType"/>.
		/// </param>
		/// <param name="coords">
		/// A <see cref="T:UInt32[]"/>.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
		[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
		public static void MultiTexCoordP1(TextureUnit texture, PackedVertexType type, UInt32[] coords)
		{
			unsafe {
				fixed (UInt32* p_coords = coords)
				{
					Debug.Assert(Delegates.pglMultiTexCoordP1uiv != null, "pglMultiTexCoordP1uiv not implemented");
					Delegates.pglMultiTexCoordP1uiv((Int32)texture, (Int32)type, p_coords);
					LogCommand("glMultiTexCoordP1uiv", null, texture, type, coords					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glMultiTexCoordP2ui: Binding for glMultiTexCoordP2ui.
		/// </summary>
		/// <param name="texture">
		/// A <see cref="T:TextureUnit"/>.
		/// </param>
		/// <param name="type">
		/// A <see cref="T:PackedVertexType"/>.
		/// </param>
		/// <param name="coords">
		/// A <see cref="T:UInt32"/>.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
		[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
		public static void MultiTexCoordP2(TextureUnit texture, PackedVertexType type, UInt32 coords)
		{
			Debug.Assert(Delegates.pglMultiTexCoordP2ui != null, "pglMultiTexCoordP2ui not implemented");
			Delegates.pglMultiTexCoordP2ui((Int32)texture, (Int32)type, coords);
			LogCommand("glMultiTexCoordP2ui", null, texture, type, coords			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glMultiTexCoordP2uiv: Binding for glMultiTexCoordP2uiv.
		/// </summary>
		/// <param name="texture">
		/// A <see cref="T:TextureUnit"/>.
		/// </param>
		/// <param name="type">
		/// A <see cref="T:TexCoordPointerType"/>.
		/// </param>
		/// <param name="coords">
		/// A <see cref="T:UInt32[]"/>.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
		[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
		public static void MultiTexCoordP2(TextureUnit texture, TexCoordPointerType type, UInt32[] coords)
		{
			unsafe {
				fixed (UInt32* p_coords = coords)
				{
					Debug.Assert(Delegates.pglMultiTexCoordP2uiv != null, "pglMultiTexCoordP2uiv not implemented");
					Delegates.pglMultiTexCoordP2uiv((Int32)texture, (Int32)type, p_coords);
					LogCommand("glMultiTexCoordP2uiv", null, texture, type, coords					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glMultiTexCoordP3ui: Binding for glMultiTexCoordP3ui.
		/// </summary>
		/// <param name="texture">
		/// A <see cref="T:TextureUnit"/>.
		/// </param>
		/// <param name="type">
		/// A <see cref="T:PackedVertexType"/>.
		/// </param>
		/// <param name="coords">
		/// A <see cref="T:UInt32"/>.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
		[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
		public static void MultiTexCoordP3(TextureUnit texture, PackedVertexType type, UInt32 coords)
		{
			Debug.Assert(Delegates.pglMultiTexCoordP3ui != null, "pglMultiTexCoordP3ui not implemented");
			Delegates.pglMultiTexCoordP3ui((Int32)texture, (Int32)type, coords);
			LogCommand("glMultiTexCoordP3ui", null, texture, type, coords			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glMultiTexCoordP3uiv: Binding for glMultiTexCoordP3uiv.
		/// </summary>
		/// <param name="texture">
		/// A <see cref="T:TextureUnit"/>.
		/// </param>
		/// <param name="type">
		/// A <see cref="T:PackedVertexType"/>.
		/// </param>
		/// <param name="coords">
		/// A <see cref="T:UInt32[]"/>.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
		[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
		public static void MultiTexCoordP3(TextureUnit texture, PackedVertexType type, UInt32[] coords)
		{
			unsafe {
				fixed (UInt32* p_coords = coords)
				{
					Debug.Assert(Delegates.pglMultiTexCoordP3uiv != null, "pglMultiTexCoordP3uiv not implemented");
					Delegates.pglMultiTexCoordP3uiv((Int32)texture, (Int32)type, p_coords);
					LogCommand("glMultiTexCoordP3uiv", null, texture, type, coords					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glMultiTexCoordP4ui: Binding for glMultiTexCoordP4ui.
		/// </summary>
		/// <param name="texture">
		/// A <see cref="T:TextureUnit"/>.
		/// </param>
		/// <param name="type">
		/// A <see cref="T:PackedVertexType"/>.
		/// </param>
		/// <param name="coords">
		/// A <see cref="T:UInt32"/>.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
		[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
		public static void MultiTexCoordP4(TextureUnit texture, PackedVertexType type, UInt32 coords)
		{
			Debug.Assert(Delegates.pglMultiTexCoordP4ui != null, "pglMultiTexCoordP4ui not implemented");
			Delegates.pglMultiTexCoordP4ui((Int32)texture, (Int32)type, coords);
			LogCommand("glMultiTexCoordP4ui", null, texture, type, coords			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glMultiTexCoordP4uiv: Binding for glMultiTexCoordP4uiv.
		/// </summary>
		/// <param name="texture">
		/// A <see cref="T:TextureUnit"/>.
		/// </param>
		/// <param name="type">
		/// A <see cref="T:PackedVertexType"/>.
		/// </param>
		/// <param name="coords">
		/// A <see cref="T:UInt32[]"/>.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
		[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
		public static void MultiTexCoordP4(TextureUnit texture, PackedVertexType type, UInt32[] coords)
		{
			unsafe {
				fixed (UInt32* p_coords = coords)
				{
					Debug.Assert(Delegates.pglMultiTexCoordP4uiv != null, "pglMultiTexCoordP4uiv not implemented");
					Delegates.pglMultiTexCoordP4uiv((Int32)texture, (Int32)type, p_coords);
					LogCommand("glMultiTexCoordP4uiv", null, texture, type, coords					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glNormalP3ui: Binding for glNormalP3ui.
		/// </summary>
		/// <param name="type">
		/// A <see cref="T:PackedVertexType"/>.
		/// </param>
		/// <param name="coords">
		/// A <see cref="T:UInt32"/>.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
		[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
		public static void NormalP3(PackedVertexType type, UInt32 coords)
		{
			Debug.Assert(Delegates.pglNormalP3ui != null, "pglNormalP3ui not implemented");
			Delegates.pglNormalP3ui((Int32)type, coords);
			LogCommand("glNormalP3ui", null, type, coords			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glNormalP3uiv: Binding for glNormalP3uiv.
		/// </summary>
		/// <param name="type">
		/// A <see cref="T:PackedVertexType"/>.
		/// </param>
		/// <param name="coords">
		/// A <see cref="T:UInt32[]"/>.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
		[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
		public static void NormalP3(PackedVertexType type, UInt32[] coords)
		{
			unsafe {
				fixed (UInt32* p_coords = coords)
				{
					Debug.Assert(Delegates.pglNormalP3uiv != null, "pglNormalP3uiv not implemented");
					Delegates.pglNormalP3uiv((Int32)type, p_coords);
					LogCommand("glNormalP3uiv", null, type, coords					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glColorP3ui: Binding for glColorP3ui.
		/// </summary>
		/// <param name="type">
		/// A <see cref="T:PackedVertexType"/>.
		/// </param>
		/// <param name="color">
		/// A <see cref="T:UInt32"/>.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
		[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
		public static void ColorP3(PackedVertexType type, UInt32 color)
		{
			Debug.Assert(Delegates.pglColorP3ui != null, "pglColorP3ui not implemented");
			Delegates.pglColorP3ui((Int32)type, color);
			LogCommand("glColorP3ui", null, type, color			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glColorP3uiv: Binding for glColorP3uiv.
		/// </summary>
		/// <param name="type">
		/// A <see cref="T:PackedVertexType"/>.
		/// </param>
		/// <param name="color">
		/// A <see cref="T:UInt32[]"/>.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
		[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
		public static void ColorP3(PackedVertexType type, UInt32[] color)
		{
			unsafe {
				fixed (UInt32* p_color = color)
				{
					Debug.Assert(Delegates.pglColorP3uiv != null, "pglColorP3uiv not implemented");
					Delegates.pglColorP3uiv((Int32)type, p_color);
					LogCommand("glColorP3uiv", null, type, color					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glColorP4ui: Binding for glColorP4ui.
		/// </summary>
		/// <param name="type">
		/// A <see cref="T:PackedVertexType"/>.
		/// </param>
		/// <param name="color">
		/// A <see cref="T:UInt32"/>.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
		[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
		public static void ColorP4(PackedVertexType type, UInt32 color)
		{
			Debug.Assert(Delegates.pglColorP4ui != null, "pglColorP4ui not implemented");
			Delegates.pglColorP4ui((Int32)type, color);
			LogCommand("glColorP4ui", null, type, color			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glColorP4uiv: Binding for glColorP4uiv.
		/// </summary>
		/// <param name="type">
		/// A <see cref="T:PackedVertexType"/>.
		/// </param>
		/// <param name="color">
		/// A <see cref="T:UInt32[]"/>.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
		[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
		public static void ColorP4(PackedVertexType type, UInt32[] color)
		{
			unsafe {
				fixed (UInt32* p_color = color)
				{
					Debug.Assert(Delegates.pglColorP4uiv != null, "pglColorP4uiv not implemented");
					Delegates.pglColorP4uiv((Int32)type, p_color);
					LogCommand("glColorP4uiv", null, type, color					);
				}
			}
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glSecondaryColorP3ui: Binding for glSecondaryColorP3ui.
		/// </summary>
		/// <param name="type">
		/// A <see cref="T:PackedVertexType"/>.
		/// </param>
		/// <param name="color">
		/// A <see cref="T:UInt32"/>.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
		[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
		public static void SecondaryColorP3(PackedVertexType type, UInt32 color)
		{
			Debug.Assert(Delegates.pglSecondaryColorP3ui != null, "pglSecondaryColorP3ui not implemented");
			Delegates.pglSecondaryColorP3ui((Int32)type, color);
			LogCommand("glSecondaryColorP3ui", null, type, color			);
			DebugCheckErrors(null);
		}

		/// <summary>
		/// [GL] glSecondaryColorP3uiv: Binding for glSecondaryColorP3uiv.
		/// </summary>
		/// <param name="type">
		/// A <see cref="T:PackedVertexType"/>.
		/// </param>
		/// <param name="color">
		/// A <see cref="T:UInt32[]"/>.
		/// </param>
		[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
		[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
		public static void SecondaryColorP3(PackedVertexType type, UInt32[] color)
		{
			unsafe {
				fixed (UInt32* p_color = color)
				{
					Debug.Assert(Delegates.pglSecondaryColorP3uiv != null, "pglSecondaryColorP3uiv not implemented");
					Delegates.pglSecondaryColorP3uiv((Int32)type, p_color);
					LogCommand("glSecondaryColorP3uiv", null, type, color					);
				}
			}
			DebugCheckErrors(null);
		}

		internal unsafe static partial class Delegates
		{
			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ARB_blend_func_extended", Api = "gl|glcore")]
			[RequiredByFeature("GL_EXT_blend_func_extended", Api = "gles2", EntryPoint = "glBindFragDataLocationIndexedEXT")]
			[SuppressUnmanagedCodeSecurity()]
			internal delegate void glBindFragDataLocationIndexed(UInt32 program, UInt32 colorNumber, UInt32 index, String name);

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ARB_blend_func_extended", Api = "gl|glcore")]
			[RequiredByFeature("GL_EXT_blend_func_extended", Api = "gles2", EntryPoint = "glBindFragDataLocationIndexedEXT")]
			[ThreadStatic]
			internal static glBindFragDataLocationIndexed pglBindFragDataLocationIndexed;

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ARB_blend_func_extended", Api = "gl|glcore")]
			[RequiredByFeature("GL_EXT_blend_func_extended", Api = "gles2", EntryPoint = "glGetFragDataIndexEXT")]
			[SuppressUnmanagedCodeSecurity()]
			internal delegate Int32 glGetFragDataIndex(UInt32 program, String name);

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ARB_blend_func_extended", Api = "gl|glcore")]
			[RequiredByFeature("GL_EXT_blend_func_extended", Api = "gles2", EntryPoint = "glGetFragDataIndexEXT")]
			[ThreadStatic]
			internal static glGetFragDataIndex pglGetFragDataIndex;

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ES_VERSION_3_0", Api = "gles2")]
			[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate void glGenSamplers(Int32 count, UInt32* samplers);

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ES_VERSION_3_0", Api = "gles2")]
			[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
			[ThreadStatic]
			internal static glGenSamplers pglGenSamplers;

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ES_VERSION_3_0", Api = "gles2")]
			[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate void glDeleteSamplers(Int32 count, UInt32* samplers);

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ES_VERSION_3_0", Api = "gles2")]
			[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
			[ThreadStatic]
			internal static glDeleteSamplers pglDeleteSamplers;

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ES_VERSION_3_0", Api = "gles2")]
			[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
			[SuppressUnmanagedCodeSecurity()]
			internal delegate bool glIsSampler(UInt32 sampler);

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ES_VERSION_3_0", Api = "gles2")]
			[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
			[ThreadStatic]
			internal static glIsSampler pglIsSampler;

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ES_VERSION_3_0", Api = "gles2")]
			[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
			[SuppressUnmanagedCodeSecurity()]
			internal delegate void glBindSampler(UInt32 unit, UInt32 sampler);

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ES_VERSION_3_0", Api = "gles2")]
			[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
			[ThreadStatic]
			internal static glBindSampler pglBindSampler;

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ES_VERSION_3_0", Api = "gles2")]
			[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
			[SuppressUnmanagedCodeSecurity()]
			internal delegate void glSamplerParameteri(UInt32 sampler, Int32 pname, Int32 param);

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ES_VERSION_3_0", Api = "gles2")]
			[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
			[ThreadStatic]
			internal static glSamplerParameteri pglSamplerParameteri;

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ES_VERSION_3_0", Api = "gles2")]
			[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate void glSamplerParameteriv(UInt32 sampler, Int32 pname, Int32* param);

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ES_VERSION_3_0", Api = "gles2")]
			[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
			[ThreadStatic]
			internal static glSamplerParameteriv pglSamplerParameteriv;

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ES_VERSION_3_0", Api = "gles2")]
			[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
			[SuppressUnmanagedCodeSecurity()]
			internal delegate void glSamplerParameterf(UInt32 sampler, Int32 pname, float param);

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ES_VERSION_3_0", Api = "gles2")]
			[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
			[ThreadStatic]
			internal static glSamplerParameterf pglSamplerParameterf;

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ES_VERSION_3_0", Api = "gles2")]
			[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate void glSamplerParameterfv(UInt32 sampler, Int32 pname, float* param);

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ES_VERSION_3_0", Api = "gles2")]
			[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
			[ThreadStatic]
			internal static glSamplerParameterfv pglSamplerParameterfv;

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ES_VERSION_3_2", Api = "gles2")]
			[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
			[RequiredByFeature("GL_EXT_texture_border_clamp", Api = "gles2", EntryPoint = "glSamplerParameterIivEXT")]
			[RequiredByFeature("GL_OES_texture_border_clamp", Api = "gles2", EntryPoint = "glSamplerParameterIivOES")]
			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate void glSamplerParameterIiv(UInt32 sampler, Int32 pname, Int32* param);

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ES_VERSION_3_2", Api = "gles2")]
			[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
			[RequiredByFeature("GL_EXT_texture_border_clamp", Api = "gles2", EntryPoint = "glSamplerParameterIivEXT")]
			[RequiredByFeature("GL_OES_texture_border_clamp", Api = "gles2", EntryPoint = "glSamplerParameterIivOES")]
			[ThreadStatic]
			internal static glSamplerParameterIiv pglSamplerParameterIiv;

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ES_VERSION_3_2", Api = "gles2")]
			[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
			[RequiredByFeature("GL_EXT_texture_border_clamp", Api = "gles2", EntryPoint = "glSamplerParameterIuivEXT")]
			[RequiredByFeature("GL_OES_texture_border_clamp", Api = "gles2", EntryPoint = "glSamplerParameterIuivOES")]
			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate void glSamplerParameterIuiv(UInt32 sampler, Int32 pname, UInt32* param);

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ES_VERSION_3_2", Api = "gles2")]
			[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
			[RequiredByFeature("GL_EXT_texture_border_clamp", Api = "gles2", EntryPoint = "glSamplerParameterIuivEXT")]
			[RequiredByFeature("GL_OES_texture_border_clamp", Api = "gles2", EntryPoint = "glSamplerParameterIuivOES")]
			[ThreadStatic]
			internal static glSamplerParameterIuiv pglSamplerParameterIuiv;

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ES_VERSION_3_0", Api = "gles2")]
			[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate void glGetSamplerParameteriv(UInt32 sampler, Int32 pname, Int32* @params);

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ES_VERSION_3_0", Api = "gles2")]
			[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
			[ThreadStatic]
			internal static glGetSamplerParameteriv pglGetSamplerParameteriv;

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ES_VERSION_3_2", Api = "gles2")]
			[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
			[RequiredByFeature("GL_EXT_texture_border_clamp", Api = "gles2", EntryPoint = "glGetSamplerParameterIivEXT")]
			[RequiredByFeature("GL_OES_texture_border_clamp", Api = "gles2", EntryPoint = "glGetSamplerParameterIivOES")]
			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate void glGetSamplerParameterIiv(UInt32 sampler, Int32 pname, Int32* @params);

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ES_VERSION_3_2", Api = "gles2")]
			[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
			[RequiredByFeature("GL_EXT_texture_border_clamp", Api = "gles2", EntryPoint = "glGetSamplerParameterIivEXT")]
			[RequiredByFeature("GL_OES_texture_border_clamp", Api = "gles2", EntryPoint = "glGetSamplerParameterIivOES")]
			[ThreadStatic]
			internal static glGetSamplerParameterIiv pglGetSamplerParameterIiv;

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ES_VERSION_3_0", Api = "gles2")]
			[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate void glGetSamplerParameterfv(UInt32 sampler, Int32 pname, float* @params);

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ES_VERSION_3_0", Api = "gles2")]
			[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
			[ThreadStatic]
			internal static glGetSamplerParameterfv pglGetSamplerParameterfv;

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ES_VERSION_3_2", Api = "gles2")]
			[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
			[RequiredByFeature("GL_EXT_texture_border_clamp", Api = "gles2", EntryPoint = "glGetSamplerParameterIuivEXT")]
			[RequiredByFeature("GL_OES_texture_border_clamp", Api = "gles2", EntryPoint = "glGetSamplerParameterIuivOES")]
			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate void glGetSamplerParameterIuiv(UInt32 sampler, Int32 pname, UInt32* @params);

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ES_VERSION_3_2", Api = "gles2")]
			[RequiredByFeature("GL_ARB_sampler_objects", Api = "gl|glcore")]
			[RequiredByFeature("GL_EXT_texture_border_clamp", Api = "gles2", EntryPoint = "glGetSamplerParameterIuivEXT")]
			[RequiredByFeature("GL_OES_texture_border_clamp", Api = "gles2", EntryPoint = "glGetSamplerParameterIuivOES")]
			[ThreadStatic]
			internal static glGetSamplerParameterIuiv pglGetSamplerParameterIuiv;

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ARB_timer_query", Api = "gl|glcore")]
			[RequiredByFeature("GL_EXT_disjoint_timer_query", Api = "gles2", EntryPoint = "glQueryCounterEXT")]
			[SuppressUnmanagedCodeSecurity()]
			internal delegate void glQueryCounter(UInt32 id, Int32 target);

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ARB_timer_query", Api = "gl|glcore")]
			[RequiredByFeature("GL_EXT_disjoint_timer_query", Api = "gles2", EntryPoint = "glQueryCounterEXT")]
			[ThreadStatic]
			internal static glQueryCounter pglQueryCounter;

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ARB_timer_query", Api = "gl|glcore")]
			[RequiredByFeature("GL_EXT_disjoint_timer_query", Api = "gles2", EntryPoint = "glGetQueryObjecti64vEXT")]
			[RequiredByFeature("GL_EXT_timer_query", EntryPoint = "glGetQueryObjecti64vEXT")]
			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate void glGetQueryObjecti64v(UInt32 id, Int32 pname, Int64* @params);

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ARB_timer_query", Api = "gl|glcore")]
			[RequiredByFeature("GL_EXT_disjoint_timer_query", Api = "gles2", EntryPoint = "glGetQueryObjecti64vEXT")]
			[RequiredByFeature("GL_EXT_timer_query", EntryPoint = "glGetQueryObjecti64vEXT")]
			[ThreadStatic]
			internal static glGetQueryObjecti64v pglGetQueryObjecti64v;

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ARB_timer_query", Api = "gl|glcore")]
			[RequiredByFeature("GL_EXT_disjoint_timer_query", Api = "gles2", EntryPoint = "glGetQueryObjectui64vEXT")]
			[RequiredByFeature("GL_EXT_timer_query", EntryPoint = "glGetQueryObjectui64vEXT")]
			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate void glGetQueryObjectui64v(UInt32 id, Int32 pname, UInt64* @params);

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ARB_timer_query", Api = "gl|glcore")]
			[RequiredByFeature("GL_EXT_disjoint_timer_query", Api = "gles2", EntryPoint = "glGetQueryObjectui64vEXT")]
			[RequiredByFeature("GL_EXT_timer_query", EntryPoint = "glGetQueryObjectui64vEXT")]
			[ThreadStatic]
			internal static glGetQueryObjectui64v pglGetQueryObjectui64v;

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ES_VERSION_3_0", Api = "gles2")]
			[RequiredByFeature("GL_ANGLE_instanced_arrays", Api = "gles2", EntryPoint = "glVertexAttribDivisorANGLE")]
			[RequiredByFeature("GL_ARB_instanced_arrays", Api = "gl|glcore", EntryPoint = "glVertexAttribDivisorARB")]
			[RequiredByFeature("GL_EXT_instanced_arrays", Api = "gles2", EntryPoint = "glVertexAttribDivisorEXT")]
			[RequiredByFeature("GL_NV_instanced_arrays", Api = "gles2", EntryPoint = "glVertexAttribDivisorNV")]
			[SuppressUnmanagedCodeSecurity()]
			internal delegate void glVertexAttribDivisor(UInt32 index, UInt32 divisor);

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ES_VERSION_3_0", Api = "gles2")]
			[RequiredByFeature("GL_ANGLE_instanced_arrays", Api = "gles2", EntryPoint = "glVertexAttribDivisorANGLE")]
			[RequiredByFeature("GL_ARB_instanced_arrays", Api = "gl|glcore", EntryPoint = "glVertexAttribDivisorARB")]
			[RequiredByFeature("GL_EXT_instanced_arrays", Api = "gles2", EntryPoint = "glVertexAttribDivisorEXT")]
			[RequiredByFeature("GL_NV_instanced_arrays", Api = "gles2", EntryPoint = "glVertexAttribDivisorNV")]
			[ThreadStatic]
			internal static glVertexAttribDivisor pglVertexAttribDivisor;

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Api = "gl|glcore")]
			[SuppressUnmanagedCodeSecurity()]
			internal delegate void glVertexAttribP1ui(UInt32 index, Int32 type, bool normalized, UInt32 value);

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Api = "gl|glcore")]
			[ThreadStatic]
			internal static glVertexAttribP1ui pglVertexAttribP1ui;

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Api = "gl|glcore")]
			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate void glVertexAttribP1uiv(UInt32 index, Int32 type, bool normalized, UInt32* value);

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Api = "gl|glcore")]
			[ThreadStatic]
			internal static glVertexAttribP1uiv pglVertexAttribP1uiv;

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Api = "gl|glcore")]
			[SuppressUnmanagedCodeSecurity()]
			internal delegate void glVertexAttribP2ui(UInt32 index, Int32 type, bool normalized, UInt32 value);

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Api = "gl|glcore")]
			[ThreadStatic]
			internal static glVertexAttribP2ui pglVertexAttribP2ui;

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Api = "gl|glcore")]
			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate void glVertexAttribP2uiv(UInt32 index, Int32 type, bool normalized, UInt32* value);

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Api = "gl|glcore")]
			[ThreadStatic]
			internal static glVertexAttribP2uiv pglVertexAttribP2uiv;

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Api = "gl|glcore")]
			[SuppressUnmanagedCodeSecurity()]
			internal delegate void glVertexAttribP3ui(UInt32 index, Int32 type, bool normalized, UInt32 value);

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Api = "gl|glcore")]
			[ThreadStatic]
			internal static glVertexAttribP3ui pglVertexAttribP3ui;

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Api = "gl|glcore")]
			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate void glVertexAttribP3uiv(UInt32 index, Int32 type, bool normalized, UInt32* value);

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Api = "gl|glcore")]
			[ThreadStatic]
			internal static glVertexAttribP3uiv pglVertexAttribP3uiv;

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Api = "gl|glcore")]
			[SuppressUnmanagedCodeSecurity()]
			internal delegate void glVertexAttribP4ui(UInt32 index, Int32 type, bool normalized, UInt32 value);

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Api = "gl|glcore")]
			[ThreadStatic]
			internal static glVertexAttribP4ui pglVertexAttribP4ui;

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Api = "gl|glcore")]
			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate void glVertexAttribP4uiv(UInt32 index, Int32 type, bool normalized, UInt32* value);

			[RequiredByFeature("GL_VERSION_3_3")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Api = "gl|glcore")]
			[ThreadStatic]
			internal static glVertexAttribP4uiv pglVertexAttribP4uiv;

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity()]
			internal delegate void glVertexP2ui(Int32 type, UInt32 value);

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[ThreadStatic]
			internal static glVertexP2ui pglVertexP2ui;

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate void glVertexP2uiv(Int32 type, UInt32* value);

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[ThreadStatic]
			internal static glVertexP2uiv pglVertexP2uiv;

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity()]
			internal delegate void glVertexP3ui(Int32 type, UInt32 value);

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[ThreadStatic]
			internal static glVertexP3ui pglVertexP3ui;

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate void glVertexP3uiv(Int32 type, UInt32* value);

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[ThreadStatic]
			internal static glVertexP3uiv pglVertexP3uiv;

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity()]
			internal delegate void glVertexP4ui(Int32 type, UInt32 value);

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[ThreadStatic]
			internal static glVertexP4ui pglVertexP4ui;

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate void glVertexP4uiv(Int32 type, UInt32* value);

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[ThreadStatic]
			internal static glVertexP4uiv pglVertexP4uiv;

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity()]
			internal delegate void glTexCoordP1ui(Int32 type, UInt32 coords);

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[ThreadStatic]
			internal static glTexCoordP1ui pglTexCoordP1ui;

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate void glTexCoordP1uiv(Int32 type, UInt32* coords);

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[ThreadStatic]
			internal static glTexCoordP1uiv pglTexCoordP1uiv;

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity()]
			internal delegate void glTexCoordP2ui(Int32 type, UInt32 coords);

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[ThreadStatic]
			internal static glTexCoordP2ui pglTexCoordP2ui;

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate void glTexCoordP2uiv(Int32 type, UInt32* coords);

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[ThreadStatic]
			internal static glTexCoordP2uiv pglTexCoordP2uiv;

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity()]
			internal delegate void glTexCoordP3ui(Int32 type, UInt32 coords);

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[ThreadStatic]
			internal static glTexCoordP3ui pglTexCoordP3ui;

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate void glTexCoordP3uiv(Int32 type, UInt32* coords);

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[ThreadStatic]
			internal static glTexCoordP3uiv pglTexCoordP3uiv;

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity()]
			internal delegate void glTexCoordP4ui(Int32 type, UInt32 coords);

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[ThreadStatic]
			internal static glTexCoordP4ui pglTexCoordP4ui;

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate void glTexCoordP4uiv(Int32 type, UInt32* coords);

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[ThreadStatic]
			internal static glTexCoordP4uiv pglTexCoordP4uiv;

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity()]
			internal delegate void glMultiTexCoordP1ui(Int32 texture, Int32 type, UInt32 coords);

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[ThreadStatic]
			internal static glMultiTexCoordP1ui pglMultiTexCoordP1ui;

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate void glMultiTexCoordP1uiv(Int32 texture, Int32 type, UInt32* coords);

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[ThreadStatic]
			internal static glMultiTexCoordP1uiv pglMultiTexCoordP1uiv;

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity()]
			internal delegate void glMultiTexCoordP2ui(Int32 texture, Int32 type, UInt32 coords);

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[ThreadStatic]
			internal static glMultiTexCoordP2ui pglMultiTexCoordP2ui;

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate void glMultiTexCoordP2uiv(Int32 texture, Int32 type, UInt32* coords);

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[ThreadStatic]
			internal static glMultiTexCoordP2uiv pglMultiTexCoordP2uiv;

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity()]
			internal delegate void glMultiTexCoordP3ui(Int32 texture, Int32 type, UInt32 coords);

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[ThreadStatic]
			internal static glMultiTexCoordP3ui pglMultiTexCoordP3ui;

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate void glMultiTexCoordP3uiv(Int32 texture, Int32 type, UInt32* coords);

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[ThreadStatic]
			internal static glMultiTexCoordP3uiv pglMultiTexCoordP3uiv;

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity()]
			internal delegate void glMultiTexCoordP4ui(Int32 texture, Int32 type, UInt32 coords);

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[ThreadStatic]
			internal static glMultiTexCoordP4ui pglMultiTexCoordP4ui;

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate void glMultiTexCoordP4uiv(Int32 texture, Int32 type, UInt32* coords);

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[ThreadStatic]
			internal static glMultiTexCoordP4uiv pglMultiTexCoordP4uiv;

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity()]
			internal delegate void glNormalP3ui(Int32 type, UInt32 coords);

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[ThreadStatic]
			internal static glNormalP3ui pglNormalP3ui;

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate void glNormalP3uiv(Int32 type, UInt32* coords);

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[ThreadStatic]
			internal static glNormalP3uiv pglNormalP3uiv;

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity()]
			internal delegate void glColorP3ui(Int32 type, UInt32 color);

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[ThreadStatic]
			internal static glColorP3ui pglColorP3ui;

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate void glColorP3uiv(Int32 type, UInt32* color);

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[ThreadStatic]
			internal static glColorP3uiv pglColorP3uiv;

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity()]
			internal delegate void glColorP4ui(Int32 type, UInt32 color);

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[ThreadStatic]
			internal static glColorP4ui pglColorP4ui;

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate void glColorP4uiv(Int32 type, UInt32* color);

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[ThreadStatic]
			internal static glColorP4uiv pglColorP4uiv;

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity()]
			internal delegate void glSecondaryColorP3ui(Int32 type, UInt32 color);

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[ThreadStatic]
			internal static glSecondaryColorP3ui pglSecondaryColorP3ui;

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[SuppressUnmanagedCodeSecurity()]
			internal unsafe delegate void glSecondaryColorP3uiv(Int32 type, UInt32* color);

			[RequiredByFeature("GL_VERSION_3_3", Profile = "compatibility")]
			[RequiredByFeature("GL_ARB_vertex_type_2_10_10_10_rev", Profile = "compatibility")]
			[ThreadStatic]
			internal static glSecondaryColorP3uiv pglSecondaryColorP3uiv;

		}
	}

}
